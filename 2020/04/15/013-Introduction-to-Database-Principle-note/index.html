<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  
  <title>数据库系统概论总结笔记</title>
  <meta name="author" content="Zachary Zhang">
  <meta name="description" content="This is my personal blog, share knowledge, record life.">
  
  
  <meta property="og:title" content="数据库系统概论总结笔记"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="=Zachary&#39;s blogs="/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="=Zachary&#39;s blogs=" type="application/atom+xml">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  <div class="description">
    &nbsp;Hope to have what you need
  </div>
</div>


  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        数据库系统概论总结笔记
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2020-04-14T16:00:00.000Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2020-04-15
</time>


    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/categories/Database/">Database</a>





    </div>
    <hr>
    <div>
    
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-text">第一章 绪论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">第二章 关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="toc-text">一.关系模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C.%E5%85%B3%E7%B3%BB%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">二.关系完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89.%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-text">三.关系代数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B.%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80-sql"><span class="toc-text">四.关系数据库标准语言 SQL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"><span class="toc-text">第六章 关系数据理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">数据依赖的公理系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E5%AE%9A%E4%B9%89"><span class="toc-text">模式分解定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">第七章 数据库设计概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-sql-%E7%BC%96%E7%A8%8B"><span class="toc-text">第八章 SQL 编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">第九章 查询优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-text">第十章 数据库恢复技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">第十一章 并发控制</span></a></li></ol>
    
    </div>
    <div class="picture-container">
      
    </div>
    <p>I have recently studied the database again, so take a note</p>
<a id="more"></a>
<h1 id="第一章-绪论">第一章 绪论</h1>
<h4 id="数据管理技术的发展阶段">1. <strong>数据管理技术的发展阶段</strong> :</h4>
<ul>
<li>人工管理阶段</li>
<li>文件系统阶段</li>
<li>数据库阶段</li>
</ul>
<p><em>其中文件阶段到数据库阶段是质的飞跃.</em></p>
<h4 id="名词概念">2. <strong>名词概念</strong></h4>
<ul>
<li>数据 描述事务的符号被称为数据.</li>
<li>DB DataBase 数据库,是长期存储在计算机内,有组织,可共享的大量数据集合.</li>
<li>DBMS 数据库管理系统.</li>
<li>DBS 数据库系统,由 DB+DBMS+应用程序+数据库管理员(DBA)</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>人工管理阶段</strong></th>
<th><strong>文件系统阶段</strong></th>
<th><strong>数据库系统阶段</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>背景</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>应用背景</strong></td>
<td>科学计算</td>
<td>科学计算,数据管理</td>
<td>大规模数据管理</td>
</tr>
<tr class="odd">
<td><strong>硬件背景</strong></td>
<td>无直接存储设备</td>
<td>硬盘,磁鼓</td>
<td>大容量磁盘,磁盘阵列</td>
</tr>
<tr class="even">
<td><strong>软件背景</strong></td>
<td>没有操作系统</td>
<td>有文件系统</td>
<td>有数据库管理系统</td>
</tr>
<tr class="odd">
<td><strong>处理方式</strong></td>
<td>批处理</td>
<td>联机实时处理,批处理</td>
<td>联机实时处理,批处理,分布处理</td>
</tr>
<tr class="even">
<td><em>特点</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>数据管理者</strong></td>
<td>用户(程序员)</td>
<td>文件系统</td>
<td>数据库管理系统</td>
</tr>
<tr class="even">
<td><strong>数据面向的对象</strong></td>
<td>应用程序</td>
<td>应用</td>
<td>现实世界(如:一个企业)</td>
</tr>
<tr class="odd">
<td><strong>数据的共享程度</strong></td>
<td>无共享,冗余度最大</td>
<td>共享性差,冗余度大</td>
<td>共享性高,冗余度小</td>
</tr>
<tr class="even">
<td><strong>数据的独立性</strong></td>
<td>不独立,完全依赖程序</td>
<td>独立性差</td>
<td>高度物理独立性和一定逻辑独立性</td>
</tr>
<tr class="odd">
<td><strong>数据的结构化</strong></td>
<td>无结构</td>
<td>记录内有结构,整体无结构</td>
<td>整体结构化,模型描述</td>
</tr>
<tr class="even">
<td><strong>数据控制能力</strong></td>
<td>程序控制</td>
<td>程序控制</td>
<td>数据管理系统</td>
</tr>
</tbody>
</table>
<p><strong>数据模型</strong> :对现实数据特征的抽象 (现实世界-&gt;信息时间诶-&gt;机器世界)</p>
<h4 id="数据模型的基本概念关系模型">3. 数据模型的基本概念(关系模型)</h4>
<table>
<thead>
<tr class="header">
<th>名次</th>
<th>英文名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>实体</td>
<td>enity</td>
<td>客观存在并可相互区别的事物</td>
</tr>
<tr class="even">
<td>属性</td>
<td>attribute</td>
<td>实体所具有的某一特性</td>
</tr>
<tr class="odd">
<td>码</td>
<td>key</td>
<td>唯一标识实体的属性称为码</td>
</tr>
<tr class="even">
<td>实体型</td>
<td>entitty</td>
<td>用实体名及其属性名集合来抽象和刻画同类实体</td>
</tr>
<tr class="odd">
<td>实体集</td>
<td>enityset</td>
<td>同一类实体的集合</td>
</tr>
<tr class="even">
<td>联系</td>
<td>relationship</td>
<td>实体内部联系常指组成实体的各属性之间的联系,实体之间的联系指不同实体集之间的联系</td>
</tr>
<tr class="odd">
<td>联系的种类</td>
<td></td>
<td>一对一,一对多,多对多</td>
</tr>
<tr class="even">
<td>关系</td>
<td>relation</td>
<td>一对关系对应一张表</td>
</tr>
<tr class="odd">
<td>元组</td>
<td>tuple</td>
<td>表中一行为一个元组</td>
</tr>
<tr class="even">
<td>属性</td>
<td>attitude</td>
<td>表中一列为一个属性</td>
</tr>
<tr class="odd">
<td>码</td>
<td>key</td>
<td>又称码键,表中的某一个属性可以唯一确认一个元组</td>
</tr>
<tr class="even">
<td>域</td>
<td>domain</td>
<td>具有相同数据类型的值的集合</td>
</tr>
<tr class="odd">
<td>分量</td>
<td></td>
<td>元组中的一个属性值</td>
</tr>
<tr class="even">
<td>关系模式</td>
<td></td>
<td>对关系的表述,一般表示为:关系名(attitude1, attitude2 ...)</td>
</tr>
</tbody>
</table>
<h4 id="数据模型分类.">4. 数据模型分类.</h4>
<p><strong>根据应用不同,第一类是概念模型,第二类是逻辑模型和物理模型</strong>.</p>
<ul>
<li><strong>概念模型</strong> :也称为信息模型,是按用户的观点来对数据和信息建模,主要用于数据库设计.其中一种表示方法: <em>实体-联系方法</em>又称 <code>E-R</code> 方法, 使用 <code>E-R</code> 图实现.</li>
<li><strong>逻辑模型</strong> :主要包括 层次模型 网状模型 关系模型,另外还有 面象对象数据模型 对象关系模型 半结构化模型 等,是按计算机系统的观点对数据建模,主要用于数据库管理系统的实现.</li>
<li><strong>物理模型</strong> :是对数据最底层的抽象,它描述数据在系统内部的表示方式和存储方法,或在磁盘或磁带上的存储方式和存取方法,是面向计算机的.</li>
</ul>
<p><strong>层次模型</strong></p>
<pre><code>定义:
    1. 有且只有一个节点没有双亲节点
    2. 根以外其他节点有且只有一个双亲节点
优点:
    1. 数据结构较清晰
    2. 查询效率高
    3. 提供了良好的完整性支持
缺点:
    1. 现实世界大多不是层次关系
    2. 查询子女节点必须通过双亲节点
    3. 结构过于严密,层次命令趋于程序化</code></pre>
<p><strong>网状模型</strong></p>
<pre><code>定义:
    1. 允许一个以上的节点无双亲节点
    2. 一个节点可有多于一个的双亲节点
优点:
    1. 更直接的描述世界
    2. 具有良好的性能,存取效率高
缺点:
    1. 结构较复杂
    2. 需要嵌入高级语言,用户不易掌握,不易使用
    3. 记录之间的联系通过存取路径实现,因此用户必须了解系统结构的细节</code></pre>
<p><strong>关系模型</strong></p>
<pre><code>定义:
    要求关系必须是规范化的,即每一个分量不可再分
优点:
    1. 建立在严格的数学概念上
    2. 概念单一,数据结构简单,清晰
    3. 存取路径对用户透明,数据的独立性,安全保密性更好
缺点:
    查询效率低,需要优化</code></pre>
<h4 id="数据模型">5. 数据模型</h4>
<p><strong>组成要素: <code>数据结构</code>+<code>数据操作</code>+<code>数据完整行约束条件</code></strong></p>
<ul>
<li>数据结构: 描述数据库的组成对象及对象之间的联系.</li>
<li>数据操作: 指对数据库中各种对象的实例(值)允许执行的操作的集合,包括操作及有关的操作规则.</li>
<li>完整性约束条件: 是一组完整性规则.</li>
</ul>
<h4 id="三级结构模式">6. 三级结构模式</h4>
<p><strong>数据库的体系结构分为三级: <code>内部级</code>, <code>概念级</code>和<code>外部级</code>.</strong></p>
<ul>
<li>模式(概念级): 是数据库中全体数据的逻辑结构和特征的描述,是所有用户的公共数据视图.</li>
<li>外模式(外部级): 能够看见和使用的局部数据的逻辑结构和特征的描述,是数据库用户的数据视图.</li>
<li>内模式(内部级): 也称为存储模式,一个数据库只有一个内模式,最接近物理存储,涉及到实际数据存储的结构,是数据在数据库内部的组织方式.</li>
</ul>
<h4 id="两层映像">7. 两层映像</h4>
<p>(<strong>保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性</strong>)</p>
<ul>
<li><p>模式/内模式映像: 用于定义概念模式和内模式之间的对应性.一般在内模式中描述.</p></li>
<li><p>外模式/模式映像: 用于定义外模式和概念模式之间的对应性.一般在外模式中描述.</p></li>
</ul>
<h4 id="两级数据独立性">8. 两级数据独立性</h4>
<ul>
<li>物理数据独立性:修改内模式时尽量不影响概念模式及外模式,则达到物理数据独立性.</li>
<li>逻辑数据独立性: 修改概念模式时尽量不影响外模式和应用程序.</li>
</ul>
<h4 id="硬件平台及数据库">9. 硬件平台及数据库</h4>
<ul>
<li>要足够大的内存</li>
<li>足够大的磁盘或磁盘阵列等设备存放数据库,作数据备份</li>
<li>系统有较高的通道能力,以提高数据传送效率</li>
</ul>
<h4 id="软件">10. 软件</h4>
<ul>
<li>DBMS</li>
<li>支持 DBMS 的 OS</li>
<li>相应的高级语言操作数据库</li>
<li>以 DBMS 为核心的开发工具</li>
</ul>
<h4 id="人员">12. 人员</h4>
<ul>
<li>DMA:
<ol type="1">
<li>决定数据库的信息内容和结构.</li>
<li>决定数据库的存储结构和存取策略.</li>
<li>定义数据的安全性要求和完整约束条件.</li>
<li>监控数据库的运行和使用.</li>
<li>数据库的改进和重构.</li>
</ol></li>
<li>系统分析员和数据库设计人员</li>
<li>应用程序人员</li>
</ul>
<h1 id="第二章-关系数据库">第二章 关系数据库</h1>
<h2 id="一.关系模型">一.关系模型</h2>
<blockquote>
<p>可形式化表示为 <code>R(U, D, DOM, F)</code><br> <code>R</code> 为关系名，<code>U</code> 为属性名集合，<code>D</code> 为 <code>U</code> 中属性所来自的域<br> <code>DOM</code> 为属性向域的映像集合，<code>F</code> 为属性间数据的依赖关系集合<br> 关系模型只包含单一的数据结构——关系（是笛卡尔积的有限子集）<br> 用户看来其中的数据逻辑结构是一张扁平的二维表<br></p>
</blockquote>
<h4 id="码">1. 码</h4>
<p><strong>由一个或几个属性组成</strong></p>
<ul>
<li>候选码: 可以唯一标识每一组的属性组</li>
<li>主码: 用户选做元组标识的一个候选键位主键</li>
<li>外码: 某个关系的主码相应的属性在另一关系中出现,此时主键就是另一个关系的外码</li>
</ul>
<h4 id="三种关系类型">2. 三种关系类型</h4>
<ol type="1">
<li>基本关系(或基表,是实际存在的表,实际存储数据的逻辑表示),</li>
<li>查询表(是查询结果对应的表),</li>
<li>视图表(是由基本表或其他试图表导出,是虚表).</li>
</ol>
<h4 id="基本关系的六条性质">3. 基本关系的六条性质</h4>
<ol type="1">
<li>列是同质的</li>
<li>不同列可出自同一域</li>
<li>列的顺序无所谓</li>
<li>行的顺序无所谓</li>
<li>任意两个元组的候选码不能同值</li>
<li>分量必须是原子值,即每一个分量都是比不可分的</li>
</ol>
<h2 id="二.关系完整性">二.关系完整性</h2>
<blockquote>
<p>关系模型有三类: <code>实体完整性</code>, <code>参照完整性</code>, <code>用户定义完整性</code>.前两个必须满足,称为关系的两个不变性.</p>
</blockquote>
<ul>
<li>实体完整性规则: 要求关系中组成主码的属性不能有空值</li>
<li>参照完整性规则: 要求不引用不存在的实体,但可以空值</li>
<li>用户自定义完整性规则: 有具体应用环境决定,系统提供定义和检验这类完整性的机制</li>
</ul>
<h2 id="三.关系代数">三.关系代数</h2>
<blockquote>
<p>一种抽象的查询语言,是对关系运算来表达查询</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>∪</th>
<th>∩</th>
<th>-</th>
<th>×</th>
<th>σ</th>
<th>Π</th>
<th>⋈</th>
<th>÷</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>含义</td>
<td>并</td>
<td>交</td>
<td>差</td>
<td>迪卡尔积</td>
<td>选择</td>
<td>投影</td>
<td>连接</td>
<td>除</td>
</tr>
</tbody>
</table>
<p><em>注:前四个<code>集合运算</code>, 后四个<code>关系运算</code></em></p>
<p>设关系 <span class="math inline">\(R\)</span> 关系 <span class="math inline">\(S\)</span> 具有相同的目 <span class="math inline">\(n\)</span> (即两个关系都有 <span class="math inline">\(n\)</span> 个属性)，且相应的属性取自同一个域， <span class="math inline">\(t\)</span> 是元组变量， <span class="math inline">\(t\in R\)</span> 表示 <span class="math inline">\(t\)</span> 是 <span class="math inline">\(R\)</span> 的一个元组。</p>
<ul>
<li><p>关系 <span class="math inline">\(R\)</span> 与关系 <span class="math inline">\(S\)</span> 的<strong>并(union)</strong>记作：<span class="math inline">\(R \bigcup S=\{ t| t \in R \bigvee t \in S \}\)</span>，其结果仍为 <span class="math inline">\(n\)</span> 目关系，由属于 <span class="math inline">\(R\)</span> 或属于 <span class="math inline">\(S\)</span> 的元组组成。</p></li>
<li><p>关系 <span class="math inline">\(R\)</span> 与关系 <span class="math inline">\(S\)</span> 的<strong>差(except)</strong>记作：<span class="math inline">\(R-S=\{ t| t \in R \bigwedge t \notin S \}\)</span>，其结果仍未 <span class="math inline">\(n\)</span> 目关系，由属于 <span class="math inline">\(R\)</span> 而不属于 <span class="math inline">\(S\)</span> 的所有元组组成。</p></li>
<li><p>关系 <span class="math inline">\(R\)</span> 与关系 <span class="math inline">\(S\)</span> 的<strong>交(intersection)</strong>记作：<span class="math inline">\(R \bigcap S=\{ t|t \in R \bigwedge t \in S \}\)</span>，其结果仍未 <span class="math inline">\(n\)</span> 目关系，由既属于 <span class="math inline">\(R\)</span> 又属于 <span class="math inline">\(S\)</span> 元组组成。用差表示为：<span class="math inline">\(R \bigcap S=R-(R-S)\)</span></p></li>
<li><p><strong>迪卡尔积(cartesian product)</strong>，这里严格来讲应该是广义迪卡尔积，因为这里迪卡尔积的元素是元组。<span class="math inline">\(R \times S=\{ \hat{t_rt_s}|t_r \in R \bigwedge t_s \in S \}\)</span></p></li>
</ul>
<p><br></p>
<ul>
<li><p><strong>选择(selection)</strong>又称之为限制(restriction)，记做：<span class="math inline">\(\sigma_F(R)=\{ t| t \in R \bigwedge F(t)=&#39;真&#39; \}\)</span>，其中 <span class="math inline">\(F\)</span> 表示选择条件，它是一个逻辑表达式。</p></li>
<li><p><strong>投影(projection)</strong>关系 <span class="math inline">\(R\)</span> 上的投影是从 <span class="math inline">\(R\)</span> 中选择出若干属性列组成新的关系。记做：<span class="math inline">\(\Pi_A(R)=\{ t[A]| t \in R \}\)</span>，其中 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(R\)</span> 的属性列。</p></li>
<li><p><strong>连接(join)</strong>也称为 <span class="math inline">\(\theta\)</span> 连接。从两个关系的迪卡尔积中选取属性间满足一定条件的元组。记做：<span class="math inline">\(R {\infty \atop A \theta B} S=\{ \hat{t_rt_s}|t_r \in R \bigwedge t_s \in S \bigwedge t_r[A] \theta t_s[B] \}\)</span></p></li>
<li><p><strong>除(division)</strong> ，记做：<span class="math inline">\(R\div S=\{ t_r[X]|t_r \in R \bigwedge \Pi_Y(S) \subseteq Y_x \}\)</span>，其中 <span class="math inline">\(Y_x\)</span> 为 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(R\)</span> 中的象集，<span class="math inline">\(x=t_r[X]\)</span>。</p></li>
</ul>
<h2 id="四.关系数据库标准语言-sql">四.关系数据库标准语言 SQL</h2>
<h3 id="sql-特点">1. SQL 特点</h3>
<ul>
<li>综合统一</li>
<li>高度非过程化</li>
<li>面向集合的操作方式</li>
<li>以同一中语法结构提供多种使用方式</li>
<li>语言简单,易学易用</li>
</ul>
<h3 id="数据定义-模型定义表定义视图索引">2. 数据定义: <code>模型定义</code>,<code>表定义</code>,<code>视图</code>,<code>索引</code></h3>
<ul>
<li><p>创建模式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>表定义<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>视图定义<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>授权定义<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>删除模式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE <span class="operator">|</span> RESTRICT<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>创建表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]</span><br><span class="line">    [, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]]</span><br><span class="line">    ...</span><br><span class="line">    [, <span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE <span class="operator">|</span> RESTRICT<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>修改表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束]]</span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT] ]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span> [RESTRICT <span class="operator">|</span> CASCADE] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]  [, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]] ... );</span><br></pre></td></tr></table></figure></li>
<li><p>修改索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX <span class="operator">&lt;</span>旧索引名<span class="operator">&gt;</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>新索引名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数据查询">3. 数据查询</h3></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span> [, <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] ...</span><br><span class="line">    <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span> [, <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span> ...] <span class="operator">|</span> (<span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span>) [<span class="keyword">AS</span>] <span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">    [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th><strong>查询条件</strong></th>
<th><strong>谓词</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>比较</td>
<td><code>=</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>!=</code> <code>&lt;&gt;</code> <code>!&gt;</code> <code>!&lt;</code></td>
</tr>
<tr class="even">
<td>确定范围</td>
<td><code>BETWEEN AND</code> <code>NOT BETWEEN AND</code></td>
</tr>
<tr class="odd">
<td>确定集合</td>
<td><code>IN</code> <code>NOT IN</code></td>
</tr>
<tr class="even">
<td>字符匹配</td>
<td><code>LIKE</code> <code>NOT LIKE</code></td>
</tr>
<tr class="odd">
<td>空值</td>
<td><code>IS NULL</code> <code>IS NOT NULL</code></td>
</tr>
<tr class="even">
<td>逻辑运算</td>
<td><code>AND</code> <code>OR</code> <code>NOT</code></td>
</tr>
</tbody>
</table>
<p><strong>聚集函数</strong></p>
<table>
<thead>
<tr class="header">
<th><strong>函数名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>COUNT(*)</code></td>
<td>统计元组个数</td>
</tr>
<tr class="even">
<td><code>COUNT( [DISTINCT/ALL] &lt;列名&gt; )</code></td>
<td>统计一列中值的个数</td>
</tr>
<tr class="odd">
<td><code>SUM( [DISTINCT/ALL] &lt;列名&gt; )</code></td>
<td>计算一列值的总和</td>
</tr>
<tr class="even">
<td><code>AVG( [DISTINCT/ALL] &lt;列名&gt; )</code></td>
<td>计算一列值的平均值</td>
</tr>
<tr class="odd">
<td><code>MAX( [DISTINCT/ALL] &lt;列名&gt; )</code></td>
<td>求一列的最大值</td>
</tr>
<tr class="even">
<td><code>MIN( [DISTINCT/ALL] &lt;列名&gt; )</code></td>
<td>求一列的最小值</td>
</tr>
</tbody>
</table>
<p><strong>GROUP BY 子句</strong></p>
<p>将查询结果按某一列或多列的值分组,值相等的为一组</p>
<blockquote>
<p>(分组后聚集函数将作用于每一个组,即每一个组都有一个函数值)</p>
</blockquote>
<h3 id="数据更新">4. 数据更新</h3>
<ul>
<li><p>插入元组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>] ...)]</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>] ...);</span><br></pre></td></tr></table></figure></li>
<li><p>插入子查询结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [, <span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>] ...)]</span><br><span class="line">子查询;</span><br></pre></td></tr></table></figure></li>
<li><p>修改数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>] ...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="视图">5. 视图</h3></li>
<li><p>创建视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] ...)]</span><br><span class="line"><span class="keyword">AS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure></li>
<li><p>删除视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE];</span><br></pre></td></tr></table></figure></li>
<li><p>更新视图: 对视图的查询和基本表相同,但是更新操作受到以下三条规则限制</p>
<ul>
<li>如果视图从多个基本表使用联合操作导出,则不允许更新</li>
<li>如果导出的视图使用了分组和聚合操作,也不允许更新</li>
<li>如果视图从单个基本表使用选择和投影导出,并包括了主码或某个候选码,则可以操作</li>
</ul></li>
</ul>
<h3 id="数据安全性">6. 数据安全性</h3>
<p>数据安全性是指保护数据库以防止不合法使用所造成的数据泄漏,更改或破坏</p>
<h4 id="i.-数据的不安全因素">I. 数据的不安全因素</h4>
<ul>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄漏</li>
<li>安全环境的脆弱性</li>
</ul>
<h4 id="ii.-实现数据库系统安全的技术和方法">II. 实现数据库系统安全的技术和方法</h4>
<p>有多种,最重要的是 <code>存取控制技术</code> 和 <code>审计技术</code>,目前许多大型 DBMS 达到的 <strong>C2</strong> 级,其安全版本达到 <strong>B1</strong>.</p>
<p><strong>C2</strong> 级的 DBMS 必须具有自主存取控制功能和审计功能,<strong>B1</strong> 级的必须具有强制存取控制功能和增强的审计功能.</p>
<p>自主存取控制功能一般是通过 <strong>SQL</strong> 的 <code>GRANT</code> 语句和 <code>REVOKE</code> 语句来实现.</p>
<h4 id="iii.-常用存取控制方法">III. 常用存取控制方法</h4>
<ul>
<li><p>自主存取控制 (Discretionary Access Control,DAC)</p>
<p>同一用户对于不同的数据对象有不同的存取权限,不同用户对同一对象也不同权限,用户还可以将其拥有的存取权限转授其他用户</p></li>
<li><p>强制存取控制 (Mandatory Access Control,MAC)</p>
<p>每一个数据对象被标记一定的密级,每一个用户也被授予某一个级别的许可证,对于任意一个对象,只有具有合法许可证的用户才可以存取</p></li>
</ul>
<h3 id="数据完整性">7. 数据完整性</h3>
<h4 id="i.-维护数据库的完整性dbms-必须实现">I. 维护数据库的完整性,DBMS 必须实现:</h4>
<ul>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>进行违约处理</li>
</ul>
<h4 id="ii.-实体完整性检查和违约处理">II. 实体完整性检查和违约处理:</h4>
<blockquote>
<p>在列级,表级定义主码后,每更新一次,DBMS 将自动检查(有全表扫描,B+树索引)</p>
</blockquote>
<ul>
<li>检查主码值是否唯一,如果不唯一则拒绝插入或修改</li>
<li>检查主码的各个属性是否为空值,只有一个空值就拒绝插入或修改</li>
</ul>
<h4 id="iii.-参照完整性">III. 参照完整性</h4>
<blockquote>
<p>用 <code>FOREIGN KEY</code> 短语定义哪些列为外码<br> 用 <code>reference</code> 指明这些外码参照哪些表的主码,参照完整性检查和违约处理</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>被参照表</th>
<th>参照表</th>
<th>违约处理</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>可能破坏参照完整性</td>
<td>插入元组</td>
<td>拒绝</td>
</tr>
<tr class="even">
<td>可能破坏参照完整性</td>
<td>修改外码值</td>
<td>拒绝</td>
</tr>
<tr class="odd">
<td>删除元组</td>
<td>可能破坏参照完整性</td>
<td>拒绝/联级删除/设置为空值</td>
</tr>
<tr class="even">
<td>修改主码值</td>
<td>可能破坏参照完整性</td>
<td>拒绝/联级操作/设置为空值</td>
</tr>
</tbody>
</table>
<p><em>备注:拒绝(NO ACTION),联级(CASCADE)</em></p>
<h4 id="iv.-用户定义完整性">IV. 用户定义完整性</h4>
<ul>
<li><p>属性上约束条件的定义: 包括列值非空(<code>NOT NULL</code>),列值唯一(<code>UNIQUE</code>),检查列值是否满足一个条件表达式(<code>CKECK sentence</code>)</p>
<p>属性上约束条件的检查和违约处理: 当往表中插入元组或修改属性的值时,DBMS 将检查属性上的约束条件是否被满足,不满足拒绝执行.</p></li>
<li><p>元组上约束条件的定义: 与属性上类似,用 CHECK 定义元组上的约束条件,即元组级限制(可设置不同属性之间的相互约束条件)</p>
<p>元组上约束条件的检查和违约处理: 当往表中插入元组或修改属性的值时,DBMS 将检查元组的约束条件是否被满足,不满足拒绝执行.</p></li>
</ul>
<h4 id="v.-完整性约束命名句子">V. 完整性约束命名句子</h4>
<ul>
<li>完整性约束命名句子</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束条件命名<span class="operator">&gt;</span> <span class="operator">&lt;</span>完整约束条件<span class="operator">&gt;</span></span><br><span class="line">   # 完整性约束条件包括: <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">UNIQUE</span>, <span class="keyword">PRIMARY</span> KEY, FOREEIGN KEY, CHAECK 短语等</span><br></pre></td></tr></table></figure>
<ul>
<li>修改完整性约束条件: 使用 <code>ALTER TABLE sentence</code></li>
</ul>
<h4 id="vi.-断言">VI. 断言</h4>
<p>通过声明性断言(declarative assertions)来制定更具有一般性的约束,可以定义设计多个表或聚集操作的比较复杂的完整性思想,断言创建后任何涉及关系的操作都会触发 DBMS 对断言的检查.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建断言</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">删除断言</span><br><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="vii.-触发器">VII. 触发器</h4>
<p>触发器又叫做<u>事件-条件-动作</u>(event-condition-action)规则, 是用户定义在关系表上的一类由事件驱动的特殊过程, 当特定的系统事件(如表的增删改查操作,事物的结束)发生时,对规则的条件进行检查,若成立则执行</p>
<ul>
<li><p>定义触发器</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span>  #每当触发事件发生时,该触发器被激活</span><br><span class="line">    &#123;BEFORE|AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt; #指明触发器激活时是在触发器事件前或后</span><br><span class="line">    <span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="operator">|</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>  #<span class="keyword">REFERENCING</span> 指出引用的变量</span><br><span class="line">    FOR EACH &#123;ROW|STATEMENT&#125;  #定义触发器的类型,指明动作体的频率</span><br><span class="line">    [<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发器条件<span class="operator">&gt;</span>] <span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span>  #仅当触发条件为真时才执行触发动作体</span><br></pre></td></tr></table></figure></li>
<li><p>激活触发器: 发器的执行是由触发事件激活并由数据库服务器自动执行, 激活应遵循如下执行顺序</p>
<ol type="1">
<li>执行该表上的 BEFORE 触发器</li>
<li>激活触发器的 SQL 语句</li>
<li>执行该表上的 AFTER 触发器</li>
</ol></li>
<li><p>删除触发器</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="第六章-关系数据理论">第六章 关系数据理论</h1></li>
</ul>
<blockquote>
<p>(一个好的关系模式应当不会发生 <code>插入异常</code>, <code>删除异常</code> 和 <code>更新异常</code>,数据冗余应尽可能少.)</p>
</blockquote>
<ul>
<li><p>数据依赖是一个关系内部属性与属性之间的约束关系,这种关系是通过属性之间的相等与否体现出来的数据相关联系;其中最重要的是 <code>函数依赖</code> 和 <code>多值依赖</code></p></li>
<li><p>规范化: 一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模型的集合,这个过程就是规范化.</p>
<ul>
<li><p>1NF: 第一范式.每一个分量必须不可再分的数据项.</p>
<p><em>缺点: 数据冗余,插入异常,删除异常,更新异常</em></p></li>
<li><p>2NF: 第二范式.首先属于 <code>1NF</code>,且每一个非主属性完全函数依赖与任何一个候选码.</p>
<p><em>缺点: 插入异常,删除异常,修改复杂</em></p></li>
<li><p>3NF: 第三范式.首先属于 <code>2NF</code>,且不存在依赖传递.</p>
<p><em>并不能完全消除各种异常情况和数据冗余</em></p></li>
<li><p>BCNF: 修正第三范式.基本消除了任何属性对码的依赖传递和部分依赖.性质:</p>
<ol type="1">
<li>所有非主属性对每一个码都是完全依赖关系</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性</li>
</ol></li>
<li><p>4NF: 第四范式.不允许有非平凡且非函数依赖的多值依赖,允许的非平凡多值依赖的函数依赖</p></li>
</ul></li>
</ul>
<figure>
<img src="http://dl.iteye.com/upload/attachment/318920/fa4fcfba-7888-310d-bd10-a736ef1ac97d.gif" alt="fanshi" /><figcaption aria-hidden="true">fanshi</figcaption>
</figure>
<h2 id="数据依赖的公理系统">数据依赖的公理系统</h2>
<h4 id="armstrong-公理系统">1. Armstrong 公理系统</h4>
<p>Armstrong 是一个有效且完备的公理系统, 公理系统是模式分解算法的理论基础</p>
<p>设 <span class="math inline">\(U\)</span> 为属性集总体: <span class="math inline">\(F\)</span> 是 <span class="math inline">\(U\)</span> 上的一组函数依赖,于是有关系模型 <span class="math inline">\(R&lt;U,F&gt;\)</span> .对于 <span class="math inline">\(R&lt;U,F&gt;\)</span> 来说有以下推理规则:</p>
<ul>
<li>自反律(reflexivity rule): 若 <span class="math inline">\(Y⊆X⊆U\)</span>,则 <span class="math inline">\(X\rightarrow Y\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含</li>
<li>增广律(augmentation rule): 若 <span class="math inline">\(X \rightarrow Y\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含,且 <span class="math inline">\(Z⊆U\)</span>, 则 <span class="math inline">\(XZ \rightarrow YZ\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含</li>
<li>传递律(transitivity rule): 若 <span class="math inline">\(X\rightarrow Y\)</span> 及 <span class="math inline">\(Y\rightarrow Z\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含,则 <span class="math inline">\(X\rightarrow Z\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含</li>
</ul>
<p>推导:</p>
<ul>
<li>合并规则(union rule):由 <span class="math inline">\(X\rightarrow Y\)</span>, <span class="math inline">\(X\rightarrow Z\)</span>,有 <span class="math inline">\(X\rightarrow YZ\)</span></li>
<li>伪传递规则(pseudo transivity rule):由 <span class="math inline">\(X\rightarrow Y\)</span>, <span class="math inline">\(WY\rightarrow Z\)</span>,有 <span class="math inline">\(XW\rightarrow Z\)</span></li>
<li>分解规则(decomposition rule):由 <span class="math inline">\(X\rightarrow Y\)</span> 及 <span class="math inline">\(Z⊆Y\)</span>,有 <span class="math inline">\(X\rightarrow Z\)</span></li>
</ul>
<h4 id="闭包-f">2. 闭包 F+</h4>
<p>在关系模式 <span class="math inline">\(R&lt;U,F&gt;\)</span> 中为 <span class="math inline">\(F\)</span> 所逻辑蕴含的函数依赖的全体叫作 <span class="math inline">\(F\)</span> 的闭包,即为 <span class="math inline">\(F+\)</span>.</p>
<h4 id="x-关于函数依赖集-f-的闭包-xf">3. X 关于函数依赖集 F 的闭包 XF+</h4>
<p>定义:设 <span class="math inline">\(F\)</span> 为属性集 <span class="math inline">\(U\)</span> 上的一组函数依赖, <span class="math inline">\(X⊆U\)</span>, <span class="math inline">\(X_{F^+}=\{A|X\rightarrow A能由F根据Armstrong公理导出\}\)</span>,<span class="math inline">\(X_{F^+}\)</span> 称为属性集 <span class="math inline">\(X\)</span> 关于函数依赖集 <span class="math inline">\(F\)</span> 的闭包</p>
<h4 id="最小依赖集">4. 最小依赖集</h4>
<p>又称最小覆盖,满足以下条件:</p>
<ul>
<li><span class="math inline">\(F\)</span> 中任一函数依赖的右部只含有一个属性</li>
<li><span class="math inline">\(F\)</span> 中不存在这样的函数依赖 <span class="math inline">\(X\rightarrow A\)</span>,使得 <span class="math inline">\(F\)</span> 与 <span class="math inline">\(F-{X\rightarrow A}\)</span> 等价</li>
<li><span class="math inline">\(F\)</span> 中不存在这样的函数依赖 <span class="math inline">\(X\rightarrow A\)</span>, <span class="math inline">\(X\)</span> 有真子集 <span class="math inline">\(Z\)</span> 使得 <span class="math inline">\(F-{X\rightarrow A}∪{Z\rightarrow A}\)</span> 与 <span class="math inline">\(F\)</span> 等价</li>
</ul>
<h2 id="模式分解定义">模式分解定义</h2>
<p><strong>三种不同的定义:</strong></p>
<ul>
<li><strong>无损连接性</strong></li>
<li><strong>保持函数依赖</strong></li>
<li><strong>既要保持函数依赖又要具有无损连接性</strong></li>
</ul>
<h4 id="关于模式分解的重要事实">1. 关于模式分解的重要事实:</h4>
<ul>
<li>若要求分解保持函数依赖,那一定可以达到 3NF,不一定达到 BCNF</li>
<li>若要求分解保持函数依赖,又具有无损连接性,可以达到 3NF,不一定达到 BCNF</li>
<li>若要求分解具有无损连接性,那一定可以达到 4NF</li>
</ul>
<h4 id="损连接性分解">2. 损连接性分解</h4>
<p><strong>分解后的关系自然连接,完全等于分解前的关系,则这个分解相对于 F 是无损连接分解.</strong></p>
<p>判断分解无损连接性的算法:</p>
<ul>
<li>表格法</li>
<li>设 <span class="math inline">\(R\)</span> 的分解为 <span class="math inline">\(ρ=\{R1,R2\}\)</span>, <span class="math inline">\(F\)</span> 为 <span class="math inline">\(R\)</span> 所满足的函数依赖集，则分解 <span class="math inline">\(ρ\)</span> 具有无损联接性的充分必要条件是：<span class="math inline">\(R_1∩R_2→(R_1-R_2)\)</span> 或者 <span class="math inline">\(R_1∩R_2→(R_2-R_1)\)</span></li>
</ul>
<h4 id="保持函数依赖的分解">3. 保持函数依赖的分解</h4>
<p><code>Let F' = F1U … FiU .. UFn</code> , 若 <code>F</code> 与 <code>F'</code> 等价，即 <code>F'+ = F+</code> ，则保持函数依赖。</p>
<p>判断方法：<code>F</code> 所有原函数依赖可以由 <code>F'</code> 的函数依赖逻辑导出</p>
<h1 id="第七章-数据库设计概述">第七章 数据库设计概述</h1>
<h4 id="数据库应用系统">1. 数据库应用系统</h4>
<p>数据库应用系统其开发也是一项软件工程,称为数据库工程.</p>
<p>数据库应用系统也有生存期的概念,通常包括六个阶段:</p>
<ol type="1">
<li>需求分析阶段: 需求收集,分析,处理-&gt;DD(数据字典)和 DFD(数据流图)</li>
<li>概念设计阶段: 设计概念结构-&gt;E-R 图</li>
<li>逻辑设计阶段: 设计逻辑结构和数据模型</li>
<li>物理设计阶段: 关系模式存取方法(B+树,hash 索引,聚簇存取),设计物理文件存储结构</li>
<li>实现阶段: 物理实现,实验性运行</li>
<li>运行维护阶段: 使用,维护数据库</li>
</ol>
<h4 id="概念设计的主要步骤">2. 概念设计的主要步骤</h4>
<ol type="1">
<li>进行数据抽象,设计局部概念模式</li>
<li>将局部概念模式综合成全局概念模式</li>
<li>评审</li>
</ol>
<h4 id="e-r-法进行数据库概念设计">3. E-R 法进行数据库概念设计</h4>
<ol type="1">
<li>首先设计局部 E-R 模式</li>
<li>然后把各局部 E-R 模式综合成全局 E-R 模式</li>
<li>最后对全局 E-R 模式进行优化</li>
</ol>
<h4 id="逻辑结构设计">4. 逻辑结构设计</h4>
<p>把 E-R 图转换为与选用 DBMS 支持的数据模型相符合的逻辑结构</p>
<h4 id="数据模型优化">5. 数据模型优化</h4>
<p>数据模型优化其结果不唯一,方法为:</p>
<ol type="1">
<li>确定数据依赖</li>
<li>消除冗余关系</li>
<li>确定关系模式处于第几范式</li>
<li>根据需求分析确定哪种模式适合应用环境(并非范式化越高越优)</li>
</ol>
<h4 id="e-r-图向关系转化的原则">6. E-R 图向关系转化的原则</h4>
<ul>
<li>一个<u>实体型</u>转换为一个<u>关系模式</u>.(属性, 码)</li>
<li><code>1:1</code> 联系可转为独立关系模式,也可与其一合并.(若合并,联系的属性也一同合并)</li>
<li><code>1:n</code> 联系可转为独立关系模式,也可与 n 端合并.(若合并,联系的属性也一同合并)</li>
<li>三个或三个以上实体间的多元联系应转为一个关系模式.</li>
<li>具有相同码的关系可合并.</li>
</ul>
<h1 id="第八章-sql-编程">第八章 SQL 编程</h1>
<p>主语言为 C,其格式为 <code>EXEC SQL &lt;SQL语句&gt;</code></p>
<p>主语言为 Java,其格式为 <code># SQL &#123;&lt;SQL语句&gt;&#125;</code></p>
<p>建立嵌入式 SQL 的连接语法: <code>EXEC SQL CONNECT TO target [AS connect-name][USERT user-name]</code> (备注:target 是要连接的数据库服务器)</p>
<h4 id="存储过程">1. 存储过程</h4>
<ol type="1">
<li>创建存储过程:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SQL</span> REPLACE <span class="keyword">PROCEDURE</span> 过程名 ([参数<span class="number">1</span>,参数<span class="number">2</span>,...])</span><br><span class="line">    <span class="keyword">AS</span> <span class="operator">&lt;</span>过程化<span class="keyword">SQL</span>块<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>执行存储过程:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span><span class="operator">/</span>PERFORM <span class="keyword">PROCEDURE</span> 过程名 ([参数<span class="number">1</span>,参数<span class="number">2</span>,...]);</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>修改存储过程:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> 过程名<span class="number">1</span> RENAME <span class="keyword">TO</span> 过程名<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>删除存储过程:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 过程名;</span><br></pre></td></tr></table></figure>
<h4 id="odbc">2. ODBC</h4>
<p>由用户 <em>应用程序</em> + <em>ODBC 驱动程序管理器</em> + <em>数据库驱动程序</em> + <em>数据源构成</em>.</p>
<p>其工作流程:</p>
<ul>
<li>配置数据源</li>
<li>初始化环境</li>
<li>建立连接</li>
<li>分配语句句柄</li>
<li>执行 SQL 语句</li>
<li>结果处理集</li>
<li>终止处理</li>
</ul>
<h1 id="第九章-查询优化">第九章 查询优化</h1>
<p>步骤为:</p>
<ol type="1">
<li>查询分析:语法,词法</li>
<li>查询检查:语义,权限,安全性检查</li>
<li>查询优化:代数优化,物理优化</li>
<li>查询执行:代码生成</li>
</ol>
<p>查询优化的目的就是为了系统在执行时既省时间又能提高效率，在关系代数运算中，通常是先进行笛卡尔积或联接运算，再进行选择和投影，恰当地安排选择、投影和联接的顺序，就可实现查询优化。优化的策略主要有以下几点：</p>
<ul>
<li>在关系代数表达式中尽可能早地执行选择操作(早做选择).</li>
<li>把笛卡尔积和随后的选择操作合并成连接运算 (尽可能做自然连接或等值连接，不做笛卡尔积).</li>
<li>同时计算一连串的选择和投影操作，使操作对象尽可能变小。</li>
<li>连接多个对象时，先做连接结果小的连接。</li>
<li>计算表达式之前先估计一下怎么计算合算</li>
</ul>
<h1 id="第十章-数据库恢复技术">第十章 数据库恢复技术</h1>
<h5 id="事务">1. 事务</h5>
<p>事务是数据库的逻辑工作单位，其特点:原子性、一致性、隔离性和持续性</p>
<p>定义事务的语句一般有三条:<code>BEGIN TRANSATION</code>; <code>COMMIT</code>; <code>ROLLBACK</code>;</p>
<ol type="1">
<li>事务开始通常由 <code>BEGIN TRANSACTION</code>, <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束,</li>
<li><code>commit</code> 提交事务的所有操作,</li>
<li><code>rollback</code> 表示回滚,即事务运行中发生了故障,系统将事务中对数据库的所有已完成的操作全部撤销,回滚到事务开始的状态</li>
</ol>
<h4 id="故障类型">2. 故障类型</h4>
<p>事物故障, 系统故障和介质故障</p>
<h4 id="恢复中最常用的技术">3. 恢复中最常用的技术</h4>
<p>数据库转储, 登记日志文件</p>
<h4 id="恢复的基本原理">4. 恢复的基本原理</h4>
<p>利用存储的备份副本, 日志文件 或 数据库镜像中冗余的数据 来重建数据库</p>
<h4 id="常用恢复技术">5. 常用恢复技术</h4>
<ul>
<li>事物故障的回复:UNDO</li>
<li>系统故障的恢复:未提交的事物做 UNDO,以提交的做 REDO</li>
<li>介质事物的恢复:重装备份并恢复到一致性状态 + REDO</li>
</ul>
<h4 id="提高恢复效率的技术">6. 提高恢复效率的技术</h4>
<p>检查点技术</p>
<ul>
<li>可以提高系统故障的恢复效率</li>
<li>可以在一定程度上提高利用动态转储备份进行介质故障恢复的效率</li>
</ul>
<p>镜像技术</p>
<ul>
<li>镜像技术可以改善介质故障的恢复效率</li>
</ul>
<h1 id="第十一章-并发控制">第十一章 并发控制</h1>
<h4 id="并发控制机制">1. 并发控制机制</h4>
<p>数据库的并发控制以事务为单位,每一时刻只有一个事务在运行(在单处理机系统中,事务的并行执行实际上是并行操作轮流交叉运行)</p>
<p>数据库的并发控制通常使用封锁机制(也有时间戳,乐观控制法,多本并发控制等其他方法), 其基本类型有两种排他锁(又称写锁, X 锁)和共享锁(又称读锁, S 锁)</p>
<table>
<thead>
<tr class="header">
<th>横向为事务 T1,纵向为事务 T2</th>
<th>X</th>
<th>S</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr class="even">
<td>S</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="odd">
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="even">
<td>备注:Y 相容请求,N 不相容请求</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="常用的封锁协议">2. 常用的封锁协议</h4>
<p>不同级别的封锁协议提供不同的数据一致性保证,提供不同的数据共享度.</p>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>一级</td>
<td>事务 T 在修改数据 R 前必须先加 X 锁,直到事务结束才释放</td>
<td>可以防止丢失修改并保证事务可恢复</td>
<td>不保证可重复读和不读脏数据</td>
</tr>
<tr class="even">
<td>二级</td>
<td>在一级基础上,增加事务 T 在读取数据 R 前必须加 S 锁,读完后立即释放</td>
<td>可防止丢失修改和读脏数据</td>
<td>不保证可重复读</td>
</tr>
<tr class="odd">
<td>三级</td>
<td>在一级基础上,增加事务 T 读取数据 R 前必须加 S 锁,直到事务结束才释放</td>
<td>可防止丢失修改和读脏数据</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="正确的判别准则">3. 正确的判别准则</h4>
<p>并发控制机制调度并发事务操作是否正确的判别准则是可串行性</p>
<ul>
<li><p>并发操作的正确准则性通常由两段锁协议保证(2PL)</p>
<ul>
<li>获得封锁,在对任何数据读写之前要申请并获取对该数据的封锁</li>
<li>释放封锁,释放封锁之后,事务不再申请和获得任何其他锁</li>
</ul></li>
<li><p>两段锁协议是可串行化调度的充分条件,但不是并要条件</p></li>
</ul>
<h4 id="对象数据施加封锁带来的问题">4. 对象数据施加封锁带来的问题</h4>
<ul>
<li>活锁:解决额方法,先来先服务</li>
<li>死锁:预防方法,一次封锁法,顺序封锁法</li>
</ul>
<h4 id="死锁的诊断与解除">5. 死锁的诊断与解除</h4>
<p>超时法和等待图法</p>
<h4 id="封锁粒度">6. 封锁粒度:</h4>
<p>封锁的粒度越大-&gt;数据库能封锁的数据单元越少,并发度越小,系统开销越小;粒度越小,则相反.</p>
<p>多粒度封锁分为:</p>
<ul>
<li>显式封锁:直接加到数据对象上的封锁</li>
<li>隐式封锁:由于其上级结点加锁而使该数据对象加锁</li>
</ul>
<h4 id="意向锁intention-lock">7. 意向锁(intention lock)</h4>
<ul>
<li>目的:提高对某个数据对象加锁时系统的检查效率</li>
<li>IS, IX, SIX 锁</li>
</ul>


  </article>
  </script>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <div class="busuanzi center">
    page PV:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    site PV:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    site UV:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © zachary 2018-2021
    </div>
    <div class="secondrow">
        <a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
