title: Introduction to Database Principle note
category: Database

---
I have recently studied the database again, so take a note
<!--more-->

# 第一章 绪论
#### 1. **数据管理技术的发展阶段** :
- 人工管理阶段
- 文件系统阶段
- 数据库阶段

*其中文件阶段到数据库阶段是质的飞跃.*

#### 2. **名词概念** 
- 数据 描述事务的符号被称为数据.
- DB DataBase数据库,是长期存储在计算机内,有组织,可共享的大量数据集合.
- DBMS 数据库管理系统.
- DBS 数据库系统,由DB+DBMS+应用程序+数据库管理员(DBA)


|                    | **人工管理阶段**    | **文件系统阶段**        | **数据库系统阶段**             |
| ------------------ | ------------------- | ----------------------- | ------------------------------ |
| *背景*             |                     |                         |                                |
| **应用背景**       | 科学计算            | 科学计算,数据管理       | 大规模数据管理                 |
| **硬件背景**       | 无直接存储设备      | 硬盘,磁鼓               | 大容量磁盘,磁盘阵列            |
| **软件背景**       | 没有操作系统        | 有文件系统              | 有数据库管理系统               |
| **处理方式**       | 批处理              | 联机实时处理,批处理     | 联机实时处理,批处理,分布处理   |
| *特点*             |                     |                         |                                |
| **数据管理者**     | 用户(程序员)        | 文件系统                | 数据库管理系统                 |
| **数据面向的对象** | 应用程序            | 应用                    | 现实世界(如:一个企业)          |
| **数据的共享程度** | 无共享,冗余度最大   | 共享性差,冗余度大       | 共享性高,冗余度小              |
| **数据的独立性**   | 不独立,完全依赖程序 | 独立性差                | 高度物理独立性和一定逻辑独立性 |
| **数据的结构化**   | 无结构              | 记录内有结构,整体无结构 | 整体结构化,模型描述            |
| **数据控制能力**   | 程序控制            | 程序控制                | 数据管理系统                   |

**数据模型** :对现实数据特征的抽象 (现实世界_->信息时间诶->机器世界)

#### 3. 数据模型的基本概念(关系模型)

| 名次       | 英文名       | 解释                                                                        |
|------------|--------------|-----------------------------------------------------------------------------|
| 实体       | enity        | 客观存在并可相互区别的事物                                                  |
| 属性       | attribute    | 实体所具有的某一特性                                                        |
| 码         | key          | 唯一标识实体的属性称为码                                                    |
| 实体型     | entitty      | 用实体名及其属性名集合来抽象和刻画同类实体                                  |
| 实体集     | enityset     | 同一类实体的集合                                                            |
| 联系       | relationship | 实体内部联系常指组成实体的各属性之间的联系,之间的联系指不同实体集之间的联系 |
| 联系的种类 |              | 一对一,一对多,多对多                                                        |
| 关系       | relation     | 一对关系对应一张表                                                          |
| 元组       | tuple        | 表中一行为一个元组                                                          |
| 属性       | attitude     | 表中一列为一个属性                                                          |
| 码         | key          | 又称码键,表中的某一个属性可以唯一确认一个元组                               |
| 域         | domain       | 具有相同数据类型的值的集合                                                  |
| 分量       |              | 元组中的一个属性值                                                          |
| 关系模式   |              | 对关系的表述,一般表示为:关系名(attitude1, attitude2 ...)                    |

#### 4. 数据模型分类.
**根据应用不同,第一类是概念模型,第二类是逻辑模型和物理模型**.

- **概念模型** :也称为信息模型,是按用户的观点来对数据和信息建模,主要用于数据库设计.其中一种表示方法: *实体-联系方法*又称 `E-R` 方法, 使用 `E-R` 图实现.
- **逻辑模型** :主要包括 层次模型 网状模型 关系模型,另外还有 面象对象数据模型 对象关系模型 半结构化模型 等,是按计算机系统的观点对数据建模,主要用于数据库管理系统的实现.
- **物理模型** :是对数据最底层的抽象,它描述数据在系统内部的表示方式和存储方法,或在磁盘或磁带上的存储方式和存取方法,是面向计算机的.

**层次模型** 

    定义:
        1. 有且只有一个节点没有双亲节点 
        2. 根以外其他节点有且只有一个双亲节点 
    优点:
        1. 数据结构较清晰 
        2. 查询效率高 
        3. 提供了良好的完整性支持   
    缺点:
        1. 现实世界大多不是层次关系 
        2. 查询子女节点必须通过双亲节点 
        3. 结构过于严密,层次命令趋于程序化 


**网状模型**

    定义:
        1. 允许一个以上的节点无双亲节点 
        2. 一个节点可有多于一个的双亲节点    
    优点:
        1. 更直接的描述世界 
        2. 具有良好的性能,存取效率高  
    缺点:
        1. 结构较复杂 
        2. 需要嵌入高级语言,用户不易掌握,不易使用 
        3. 记录之间的联系通过存取路径实现,因此用户必须了解系统结构的细节 


**关系模型**

    定义:
        要求关系必须是规范化的,即每一个分量不可再分    
    优点:
        1. 建立在严格的数学概念上 
        2. 概念单一,数据结构简单,清晰 
        3. 存取路径对用户透明,数据的独立性,安全保密性更好 
    缺点:
        查询效率低,需要优化  

#### 5. 数据模型
**组成要素: `数据结构`+`数据操作`+`数据完整行约束条件`**

- 数据结构: 描述数据库的组成对象及对象之间的联系.
- 数据操作: 指对数据库中各种对象的实例(值)允许执行的操作的集合,包括操作及有关的操作规则.
- 完整性约束条件: 是一组完整性规则.

#### 6. 三级结构模式
**数据库的体系结构分为三级: `内部级`, `概念级`和`外部级`.**

- 模式(概念级): 是数据库中全体数据的逻辑结构和特征的描述,是所有用户的公共数据视图.
- 外模式(外部级): 能够看见和使用的局部数据的逻辑结构和特征的描述,是数据库用户的数据视图.
- 内模式(内部级): 也称为存储模式,一个数据库只有一个内模式,最接近物理存储,涉及到实际数据存储的结构,是数据在数据库内部的组织方式.

#### 7. 两层映像 
(**保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性**)
- 模式/内模式映像: 用于定义概念模式和内模式之间的对应性.一般在内模式中描述.
- 外模式/模式映像: 用于定义外模式和概念模式之间的对应性.一般在外模式中描述.

#### 8. 两级数据独立性
- 物理数据独立性:修改内模式时尽量不影响概念模式及外模式,则达到物理数据独立性.
- 逻辑数据独立性: 修改概念模式时尽量不影响外模式和应用程序.

#### 9. 硬件平台及数据库
- 要足够大的内存
- 足够大的磁盘或磁盘阵列等设备存放数据库,作数据备份
- 系统有较高的通道能力,以提高数据传送效率

#### 10. 软件
- DBMS
- 支持DBMS的OS
- 相应的高级语言操作数据库
- 以DBMS为核心的开发工具

#### 12. 人员
- DMA:
    1. 决定数据库的信息内容和结构.
    2. 决定数据库的存储结构和存取策略.
    3. 定义数据的安全性要求和完整约束条件.
    4. 监控数据库的运行和使用.
    5. 数据库的改进和重构.
- 系统分析员和数据库设计人员
- 应用程序人员

# 第二章 
## 一.关系模型
>可形式化表示为 `R(U, D, DOM, F)`<br>
`R` 为关系名，`U` 为属性名集合，`D` 为 `U` 中属性所来自的域<br>
`DOM` 为属性向域的映像集合，`F` 为属性间数据的依赖关系集合<br>
关系模型只包含单一的数据结构——关系（是笛卡尔积的有限子集）<br>
用户看来其中的数据逻辑结构是一张扁平的二维表<br>

#### 1. 码
 **由一个或几个属性组成**
- 候选码: 可以唯一标识每一组的属性组
- 主码: 用户选做元组标识的一个候选键位主键
- 外码: 某个关系的主码相应的属性在另一关系中出现,此时主键就是另一个关系的外码

#### 2. 三种关系类型
1. 基本关系(或基表,是实际存在的表,实际存储数据的逻辑表示),
1. 查询表(是查询结果对应的表),
1. 视图表(是由基本表或其他试图表导出,是虚表).

#### 3. 基本关系的六条性质
1. 列是同质的
1. 不同列可出自同一域
1. 列的顺序无所谓
1. 行的顺序无所谓
1. 任意两个元组的候选码不能同值
1. 分量必须是原子值,即每一个分量都是比不可分的

## 二.关系完整性
>关系模型有三类: `实体完整性`, `参照完整性`, `用户定义完整性`.前两个必须满足,称为关系的两个不变性.

- 实体完整性规则: 要求关系中组成主码的属性不能有空值
- 参照完整性规则: 要求不引用不存在的实体,但可以空值
- 用户自定义完整性规则: 有具体应用环境决定,系统提供定义和检验这类完整性的机制

## 三.关系代数
>一种抽象的查询语言,是对关系运算来表达查询

| 符号 | ∪  | ∩  | -  | ×        | σ    | Π    | ⋈    | ÷  |
|------|----|----|----|----------|------|------|------|----|
| 含义 | 并 | 交 | 差 | 迪卡尔积 | 选择 | 投影 | 连接 | 除 |

*注:前四个`集合运算`, 后四个`关系运算`*

## 四.关系数据库标准语言SQL
### 1. SQL特点
- 综合统一
- 高度非过程化
- 面向集合的操作方式
- 以同一中语法结构提供多种使用方式
- 语言简单,易学易用

### 2. 数据定义: `模型定义`,`表定义`,`视图`,`索引`
- 创建模式

    ```sql
    CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义>|<视图定义>|<授权定义>];
    ```

- 删除模式

    ```sql
    DROP SCHEMA <模式名> <CASCADE | RESTRICT>;
    ```

- 创建表

    ```sql
    CREATE TABLE <表名> (<列名><数据类型> [列级完整性约束条件]
    [, <列名><数据类型> [列级完整性约束条件]]
    ...
    [, <表级完整性约束条件>]
    );
    ```

- 删除表

    ```sql
    DROP TABLE <表名> <CASCADE | RESTRICT>;
    ```

- 修改表

    ```sql
    ALTER TABLE <表名>
    [ADD [COLUMN] <新列名> <数据类型> [完整性约束]]
    [ADD <表级完整性约束>]
    [DROP [COLUMN] <列名> [CASCADE | RESTRICT] ]
    [DROP CONSTRAINT <完整性约束名> [RESTRICT | CASCADE] ]
    [ALTER COLUMN <列名> <数据类型>]
    ;
    ```

- 创建索引

    ```sql
    CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
    ON <表名>( <列名> [<次序>]  [, <列名> [<次序>]] ... );
    ```

- 修改索引

    ```sql
    ALTER INDEX <旧索引名> RENAME TO <新索引名>;
    ```

- 删除索引

    ```sql
    DROP INDEX <索引名>;
    ```
### 3. 数据查询
```sql
SELECT [ALL | DISTINCT] <目标列表达式> [, <目标列表达式>] ...
    FROM <表名|视图名> [, <表名|视图名> ...] | (<SELECT语句>) [AS] <别名>
    [WHERE <条件表达式>]
    [GROUP BY <列名1> [HAVING <条件表达式>]]
    [ORDER BY <列名2> [ASC|DESC]]
    ;
```

| **查询条件**   | **谓词**                                  |
| -------------- | -----------------------------             |
| 比较           | `=` `>` `<` `>=` `<=` `!=` `<>` `!>` `!<` |
| 确定范围       | `BETWEEN AND` `NOT BETWEEN AND`           |
| 确定集合       | `IN` `NOT IN`                             |
| 字符匹配       | `LIKE` `NOT LIKE`                         |
| 空值           | `IS NULL` `IS NOT NULL`                   |
| 逻辑运算       | `AND` `OR` `NOT`                          |

**聚集函数**

| **函数名**                       | **含义**             |
| -------------------------------- | -------------------- |
| `COUNT(*)`                       | 统计元组个数         |
| `COUNT( [DISTINCT/ALL] <列名> )` | 统计一列中值的个数   |
| `SUM( [DISTINCT/ALL] <列名> )`   | 计算一列值的总和     |
| `AVG( [DISTINCT/ALL] <列名> )`   | 计算一列值的平均值   |
| `MAX( [DISTINCT/ALL] <列名> )`   | 求一列的最大值       |
| `MIN( [DISTINCT/ALL] <列名> )`   | 求一列的最小值       |

**GROUP BY 子句**

将查询结果按某一列或多列的值分组,值相等的为一组
>(分组后聚集函数将作用于每一个组,即每一个组都有一个函数值)

### 4. 数据更新
- 插入元组

    ```sql
    INSERT INTO <表名> [(<属性列1> [,<属性列2>] ...)]
    VALUES(<常量1> [,<常量2>] ...);
    ```

- 插入子查询结构

    ```sql
    INSERT INTO <表名> [(<属性列1> [, <属性列2>] ...)]
    子查询;
    ```

- 修改数据

    ```sql
    UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>] ...
    [WHERE <条件>];
    ```

- 删除数据

    ```sql
    DELETE
    FROM <表名>
    [WHERE <条件>]
    ;
    ```

### 5. 视图
- 创建视图

    ```sql
    CREATE VIEW <视图名> [(<列名> [,<列名>] ...)]
    AS <子查询>
    [WITH CHECK OPTION]
    ;
    ```

- 删除视图

    ```sql
    DROP VIEW <视图名> [CASCADE];
    ```

- 更新视图: 对视图的查询和基本表相同,但是更新操作受到以下三条规则限制
    - 如果试图从多个基本表使用联合操作导出,则不允许更新
    - 如果导出的视图使用了分组和聚合操作,也不允许更新
    - 如果视图从单个基本表使用选择和投影导出,并包括了主码或某个候选码,则可以操作

### 6. 数据安全性
>数据安全性是指保护数据库以防止不合法使用所造成的数据泄漏,更改或破坏

#### I. 数据的不安全因素
- 非授权用户对数据库的恶意存取和破坏
- 数据库中重要或敏感的数据被泄漏
- 安全环境的脆弱性

#### II. 实现数据库系统安全的技术和方法
有多种,最重要的是`存取控制技术`和`审计技术`,目前许多大型DBMS达到的**C2**级,其安全版本达到**B1**.

**C2**级的DBMS必须具有自主存取控制功能和审计功能,**B1**级的必须具有强制存取控制功能和增强的审计功能.

自主存取控制功能一般是通过**SQL**的`GRANT`语句和`REVOKE`语句来实现.

#### III. 常用存取控制方法
- 自主存取控制 (Discretionary Access Control,DAC)

    同一用户对于不同的数据对象有不同的存取权限,不同用户对同一对象也不同权限,用户还可以将其拥有的存取权限转授其他用户
- 强制存取控制 (Mandatory Access Control,MAC)

    每一个数据对象被标记一定的密级,每一个用户也被授予某一个级别的许可证,对于任意一个对象,只有具有合法许可证的用户才可以存取

### 7. 数据完整性
#### I. 维护数据库的完整性,DBMS必须实现:
- 提供定义完整性约束条件的机制
- 提供完整性检查的方法
- 进行违约处理

#### II. 实体完整性检查和违约处理:
>在列级,表级定义主码后,每更新一次,DBMS将自动检查(有全表扫描,B+树索引)
- 检查主码值是否唯一,如果不唯一则拒绝插入或修改
- 检查主码的各个属性是否为空值,只有一个空值就拒绝插入或修改

#### III. 参照完整性
>用`FOREIGN KEY`短语定义哪些列为外码<br>
用`reference`指明这些外码参照哪些表的主码,参照完整性检查和违约处理

| 被参照表           | 参照表             | 违约处理                 |
|--------------------|--------------------|--------------------------|
| 可能破坏参照完整性 | 插入元组           | 拒绝                     |
| 可能破坏参照完整性 | 修改外码值         | 拒绝                     |
| 删除元组           | 可能破坏参照完整性 | 拒绝/联级删除/设置为空值 |
| 修改主码值         | 可能破坏参照完整性 | 拒绝/联级操作/设置为空值 |

*备注:拒绝(NO ACTION),联级(CASCADE)*

#### IV. 用户定义完整性
- 属性上约束条件的定义: 包括列值非空(`NOT NULL`),列值唯一(`UNIQUE`),检查列值是否满足一个条件表达式(CKECK sentence)

    属性上约束条件的检查和违约处理: 当往表中插入元组或修改属性的值时,DBMS将检查属性上的约束条件是否被满足,不满足拒绝执行.

- 元组上约束条件的定义: 与属性上类似,用CHECK定义元组上的约束条件,即元组级限制(可设置不同属性之间的相互约束条件)

    元组上约束条件的检查和违约处理: 当往表中插入元组或修改属性的值时,DBMS将检查元组的约束条件是否被满足,不满足拒绝执行.

#### V. 完整性约束命名句子
- 完整性约束命名句子
```sql
CONSTRAINT <完整性约束条件命名> <完整约束条件>
   # 完整性约束条件包括: NOT NULL, UNIQUE, PRIMARY KEY, FOREEIGN KEY, CHAECK 短语等
```
- 修改完整性约束条件: 使用`ALTER TABLE sentence`

#### VI. 断言
通过声明性断言(declarative assertions)来制定更具有一般性的约束,可以定义设计多个表或聚集操作的比较复杂的完整性思想,断言创建后任何涉及关系的操作都会触发DBMS对断言的检查.

```sql
#创建断言
CREATE ASSERTION <断言名> <CHECK 子句>
#删除断言
DROP ASSERTION <断言名>
```
#### VII. 触发器
触发器又叫做事件-条件-动作(event-condition-action)规则, 是用户定义在关系表上的一类由事件驱动的特殊过程, 当特定的系统事件(如表的增删改查操作,事物的结束)发生时,对规则的条件进行检查,若成立则执行

- 定义触发器

    ```sql
    CREATE TRIGGER <触发器名>  #每当触发事件发生时,该触发器被激活
        {BEFORE|AFTER} <触发事件> ON <表名> #指明触发器激活时是在触发器事件前或后
        REFERENCING NEW | OLD ROW AS <变量>  #REFERENCING 指出引用的变量
        FOR EACH {ROW|STATEMENT}  #定义触发器的类型,指明动作体的频率
        [WHEN <触发器条件>] <触发动作体>  #仅当触发条件为真时才执行触发动作体
    ```

- 激活触发器: 发器的执行是由触发事件激活并由数据库服务器自动执行, 激活应遵循如下执行顺序
    1. 执行该表上的BEFORE触发器
    1. 激活触发器的SQL语句
    1. 执行该表上的AFTER触发器

- 删除触发器

    ```sql
    DROP TRIGGER <触发器名> ON <表名>;
    ```

# 第六章 关系数据理论

(一个好的关系模式应当不会发生`插入异常`,`删除异常`和`更新异常`,数据冗余应尽可能少.)

- 数据依赖是一个关系内部属性与属性之间的约束关系,这种关系是通过属性之间的相等与否体现出来的数据相关联系;其中最重要的是 `函数依赖` 和 `多值依赖`
- 规范化: 一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模型的集合,这个过程就是规范化.

    - 1NF: 第一范式.每一个分量必须不可再分的数据项.

        *缺点: 数据冗余,插入异常,删除异常,更新异常*
    - 2NF: 第二范式.首先属于 `1NF`,且每一个非主属性完全函数依赖与任何一个候选码.

        *缺点: 插入异常,删除异常,修改复杂*
    - 3NF: 第三范式.首先属于 `2NF`,且不存在依赖传递.

        *并不能完全消除各种异常情况和数据冗余*
    - BCNF: 修正第三范式.基本消除了任何属性对码的依赖传递和部分依赖.性质:

        1. 所有非主属性对每一个码都是完全依赖关系
        2. 所有主属性对每一个不包含它的码也是完全函数依赖
        3. 没有任何属性完全函数依赖于非码的任何一组属性

    - 4NF: 第四范式.不允许有非平凡且非函数依赖的多值依赖,允许的非平凡多值依赖的函数依赖

![fanshi](http://dl.iteye.com/upload/attachment/318920/fa4fcfba-7888-310d-bd10-a736ef1ac97d.gif)

## 数据依赖的公理系统
#### 1. Armstrong公理系统
Armstrong是一个有效且完备的公理系统, 公理系统是模式分解算法的理论基础

设 U 为属性集总体: F是U上的一组函数依赖,于是有关系模型R<U,F>.对于R<U,F>来说有以下推理规则:
- 自反律: 若Y⊆X⊆U,则X->Y为F所蕴含
- 增广律: 若X->Y为F所蕴含,且Z⊆U, 则XZ->YZ为F所蕴含
- 传递律: 若X->Y及Y->Z为F所蕴含,则X->Z为F所蕴含

推导:
- 合并规则:由X->Y, X->Z,有X->YZ
- 伪传递规则:由X->Y, WY->Z,有XW->Z
- 分解规则:由X->Y及Z⊆Y,有X->Z

#### 2. 闭包F+
在关系模式R<U,F>中为F所逻辑蕴含的函数依赖的全体叫作F的闭包,即为F+.

#### 3. X关于函数依赖集F的闭包XF+
定义:设$F$为属性集$U$上的一组函数依赖, $X⊆U$,$X_{F^+}=\{A|X->A能由F根据Armstrong公理导出\}$,$X_{F^+}$称为属性集X关于函数依赖集F的闭包

#### 4. 最小依赖集
又称最小覆盖,满足以下条件:
- F中任一函数依赖的右部只含有一个属性
- F中不存在这样的函数依赖X->A,使得F与F-{X->A}等价
- F中不存在这样的函数依赖X->A,X有真子集Z使得F-{X->A}∪{Z->A}与F等价

## 模式分解定义
**分解具有: 无损连接性, 保持函数依赖, 既要保持函数依赖又要具有无损连接性** 

#### 1. 关于模式分解的重要事实:
- 若要求分解保持函数依赖,那一定可以达到3NF,不一定达到BCNF
- 若要求分解保持函数依赖,又具有无损连接性,可以达到3NF,不一定达到BCNF
- 若要求分解具有无损连接性,那一定可以达到4NF

#### 2. 损连接性分解
**分解后的关系自然连接,完全等于分解前的关系,则这个分解相对于F是无损连接分解.**

判断分解无损连接性的算法:
- 表格法
- 设R的分解为ρ={R1,R2},F为R所满足的函数依赖集，则分解ρ具有无损联接性的充分必要条件是：R1∩R2→(R1-R2) 或者 R1∩R2→(R2-R1)

#### 3. 保持函数依赖的分解
`Let F' = F1U … FiU .. UFn` , 若`F`与`F'`等价，即`F'+ = F+` ，则保持函数依赖。

判断方法：`F`所有原函数依赖可以由`F'`的函数依赖逻辑导出

# 第七章 数据库设计概述
#### 1. 数据库应用系统的开发也是一项软件工程,称为数据库工程.

数据库应用系统也有生存期的概念,通常包括六个阶段:
- 需求分析阶段: 需求收集,分析,处理->DD(数据字典)和DFD(数据流图)
- 概念设计阶段: 设计概念结构->E-R图
- 逻辑设计阶段: 设计逻辑结构和数据模型
- 物理设计阶段: 关系模式存取方法(B+树,hash索引,聚簇存取),设计物理文件存储结构
- 实现阶段: 物理实现,实验性运行
- 运行维护阶段: 使用,维护数据库

#### 2. 概念设计的主要步骤:
1. 机型数据抽象,设计局部概念模式
2. 将局部概念模式综合成全局概念模式
3. 评审

#### 3. 采用E-R法进行数据库概念设计分三步:
1. 首先设计局部E-R模式
2. 然后把各局部E-R模式综合成全局E-R模式
3. 最后对全局E-R模式进行优化

#### 4. 逻辑结构设计: 把E-R图转换为与选用DBMS支持的数据模型相符合的逻辑结构

#### 5. 数据模型优化:其结果不唯一,方法为:
1. 确定数据依赖
2. 消除冗余关系
3. 确定关系模式处于第几范式
4. 根据需求分析确定哪种模式适合应用环境(并非范式化越高越优)

#### 6. E-R图向关系转化的原则:
- 一个实体型转换为一个关系模式.(属性, 码)
- 1:1联系可转为独立关系模式,也可与其一合并.(若合并,联系的属性也一同合并)
- 1:n联系可转为独立关系模式,也可与n端合并.(若合并,联系的属性也一同合并)
- 三个或三个以上实体间的多元联系应转为一个关系模式.
- 具有相同码的关系可合并

# 第八章 SQL编程
主语言为C,其格式为 `EXEC SQL <SQL语句>`

主语言为Java,其格式为 `# SQL {<SQL语句>}`

建立嵌入式SQL的连接语法: `EXEC SQL CONNECT TO target [AS connect-name][USERT user-name]` (备注:target是要连接的数据库服务器)

#### 1. 存储过程
1. 创建存储过程:

```sql
CREATE SQL REPLACE PROCEDURE 过程名 ([参数1,参数2,...])
    AS <过程化SQL块>;
```

2. 执行存储过程:

```sql
CALL/PERFORM PROCEDURE 过程名 ([参数1,参数2,...]);
```

3. 修改存储过程:

```sql
ALTER PROCEDURE 过程名1 RENAME TO 过程名2;
```
4. 删除存储过程:

```sql
DROP PROCEDURE 过程名;
```

#### 2. ODBC: 由用户应用程序+ODBC驱动程序管理器+数据库驱动程序+数据源构成
- 其工作流程:
- 配置数据源
- 初始化环境
- 建立连接
- 分配语句句柄
- 执行SQL语句
- 结果处理集
- 终止处理

# 第九章 查询优化
步骤为:

- 查询分析:语法,词法
- 查询检查:语义,权限,安全性检查
- 查询优化:代数优化,物理优化
- 查询执行:代码生成

查询优化的目的就是为了系统在执行时既省时间又能提高效率，在关系代数运算中，通常是先进行笛卡尔积或联接运算，再进行选择和投影，恰当地安排选择、投影和联接的顺序，就可实现查询优化。优化的策略主要有以下几点：
- 在关系代数表达式中尽可能早地执行选择操作(早做选择).
- 把笛卡尔积和随后的选择操作合并成连接运算 (尽可能做自然连接或等值连接，不做笛卡尔积).
- 同时计算一连串的选择和投影操作，使操作对象尽可能变小。
- 连接多个对象时，先做连接结果小的连接。
- 计算表达式之前先估计一下怎么计算合算

# 第十章 数据库恢复技术
##### 1. 事务是数据库的逻辑工作单位，其特点:原子性、一致性、隔离性和持续性
定义事务的语句一般有三条:`BEGIN TRANSATION`; `COMMIT`; `ROLLBACK`;
1. 事务开始通常由BEGIN TRANSACTION, COMMIT或ROLLBACK结束,

2. commit提交事务的所有操作,

3. rollback表示回滚,即事务运行中发生了故障,系统将事务中对数据库的所有已完成的操作全部撤销,回滚到事务开始的状态

#### 2. 故障类型: 
事物故障,系统故障和介质故障

#### 3. 恢复中最常用的技术:
数据库转储,登记日志文件

#### 4. 恢复的基本原理:
利用存储的备份副本,日志文件或数据库镜像中冗余的数据来重建数据库

#### 5. 常用恢复技术:
- 事物故障的回复:UNDO
- 系统故障的恢复:未提交的事物做UNDO,以提交的做REDO
- 介质事物的恢复:重装备份并恢复到一致性状态+REDO

#### 6. 提高恢复效率的技术
检查点技术
- 可以提高系统故障的恢复效率
- 可以在一定程度上提高利用动态转储备份进行介质故障恢复的效率

镜像技术
- 镜像技术可以改善介质故障的恢复效率

# 第十一章 并发控制
#### 1. 数据库的并发控制以事务为单位,每一时刻只有一个事务在运行(在单处理机系统中,事务的并行执行实际上是并行操作轮流交叉运行)

#### 2. 数据库的并发控制通常使用封锁机制(也有时间戳,乐观控制法,多本并发控制等其他方法), 其基本类型有两种排他锁(又称写锁, X锁)和共享锁(又称读锁, S锁)

| 横向为事务T1,纵向为事务T2   | X | S | - |
|-----------------------------|---|---|---|
| X                           | N | N | Y |
| S                           | N | Y | Y |
| --------------------------- | Y | Y | Y |
| 备注:Y相容请求,N不相容请求  |   |   |   |

#### 3. 常用的封锁协议
不同级别的封锁协议提供不同的数据一致性保证,提供不同的数据共享度.

| 名称 | 定义                                                          | 优点                             | 缺点                       |
|------|---------------------------------------------------------------|----------------------------------|----------------------------|
| 一级 | 事务T在修改数据R前必须先加X锁,直到事务结束才释放              | 可以防止丢失修改并保证事务可恢复 | 不保证可重复读和不读脏数据 |
| 二级 | 在一级基础上,增加事务T在读取数据R前必须加S锁,读完后立即释放   | 可防止丢失修改和读脏数据         | 不保证可重复读             |
| 三级 | 在一级基础上,增加事务T读取数据R前必须加S锁,直到事务结束才释放 | 可防止丢失修改和读脏数据         | -                          |

#### 4. 并发控制机制调度并发事务操作是否正确的判别准则是可串行性
- 并发操作的正确准则性通常由两段锁协议保证(2PL)

    - 获得封锁,在对任何数据读写之前要申请并获取对该数据的封锁
    - 释放封锁,释放封锁之后,事务不再申请和获得任何其他锁

- 两段锁协议是可串行化调度的充分条件,但不是并要条件

#### 5. 对象数据施加封锁,带来问题
- 活锁:解决额方法,先来先服务
- 死锁:预防方法,一次封锁法,顺序封锁法

#### 6. 死锁的诊断与解除: 
超时法和等待图法

#### 7. 封锁粒度:
封锁的粒度越大->数据库能封锁的数据单元越少,并发度越小,系统开销越小;粒度越小,则相反.

多粒度封锁分为:
- 显式封锁:直接加到数据对象上的封锁
- 隐式封锁:由于其上级结点加锁而使该数据对象加锁

#### 8. 意向锁(intention lock)
- 目的:提高对某个数据对象加锁时系统的检查效率
- IS, IX, SIX锁
