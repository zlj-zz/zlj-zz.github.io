<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3 compoistion API [setup()]</title>
      <link href="2021/03/24/040-vue3-composition-api/"/>
      <url>2021/03/24/040-vue3-composition-api/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-compoistion-api">什么是 compoistion API</h1><p>若果你使用过 vue2 的话，那么就肯定对 Options API 不陌生。如果有人不知到什么是 Options API，那么看到下面这段代码就明白了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">plus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">dou</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.count * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="function"><span class="title">count</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">      consolo.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式的就是 Options API。这样的方式我们用的很舒服，但是问题，尤其是当您的应用程序变得非常大时-考虑一下数百个组件。 当处理如此大的应用程序时，共享和重用代码变得尤为重要。</p><p>或者的单页面的逻辑十分的复杂，你会有很多的 <code>data</code> 和 <code>method</code>。然而你 <code>data</code> 和它相对应的 <code>method</code> 并不能发在一起，那么当你要修改时就变得麻烦了。而且相信你复杂的单组件中大概率存在和其他组件重复的逻辑。</p><p>为了解决这种问题，给使用者提供等多的选择，在 Vue3 中了加入 Compositions API， 其实就 <code>setup()</code> 方法。</p><p>而且 Compositions API 和 Options API 可以一起使用的。</p><h1 id="setup">setup()</h1><p>使用设置函数时，它将带有两个参数：</p><ul><li><code>props</code><ul><li>然而，因为 <code>props</code> 是反应性的，你不能使用 ES6 解构，因为它会移除道具的反应性。 如果你需要解构你的道具，你可以通过使用设置函数中的 <code>toRefs</code> 来完成:</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    consolo.log(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 props 中带有一个属性叫 name</span></span><br><span class="line">    <span class="keyword">let</span> &#123; name &#125; = toRefs(props);</span><br><span class="line">    consolo.log(name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>context</code><ul><li>传递给 setup 函数的第二个参数是上下文。<code>context</code> 是一个普通的 JavaScript 对象，它公开了三个组件属性: <code>attrs</code>,<code>slots</code>,<code>emit</code></li><li><code>context</code> 对象是一个普通的 JavaScript 对象，也就是说，它不是被动的，这意味着您可以在 <code>context</code> 上安全地使用 ES6 解构。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    consolo.log(context.attrs);</span><br><span class="line">    consolo.log(context.slots);</span><br><span class="line">    consolo.log(context.emit);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; attrs, slots, emit &#125;</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="data">data</h2><p>那么怎么在 setup 中像 Options API 的 data 一样定义变量， Vue3 提供了 <code>ref</code> 和 <code>reactive</code> 两个方法。</p><ul><li><code>ref</code> 接受参数并将其包装在一个对象中，并返回一个 <code>value</code> 属性，然后可用于访问或更改反应变量的值, <code>ref</code> 会推导数据类型，所以直接初始值给入就 OK 了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>reactive 当我们需要定义一个对象,并且要求里面的每一个属性都是响应式时，我们可使用它。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> student = reactive(&#123;</span><br><span class="line">      name: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">      age: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; student &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="method">method</h2><p>如果你想在 setup 中定义方法十分的简单， 你只需要像定义普通的方法一样定义你的方法，最后 <code>return</code> 出来就可以模版中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; count, plus &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lifehook">lifehook</h2><p>为了使 Composition API 与 Options API 相比功能更完整，还需要一种在其中注册生命周期挂钩的方法。 由于 Vue3 导出了几个新功能，因此可以实现这一点。 Composition API 上的生命周期挂钩与 Options API 的名称相同，但前缀为 on。除了 <code>beforeCreate</code> 和 <code>created</code>， 想达到一样的效果，直接在 setup 中执行你的方法就 OK 了。</p><ul><li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li><li><code>mounted</code> -&gt; <code>onMounted</code></li><li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li><li><code>updated</code> -&gt; <code>onUpdated</code></li><li><code>beforeUnmount</code> -&gt; <code>onBeforeUnmount</code></li><li><code>unmounted</code> -&gt; <code>onUnmounted</code></li><li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li><li><code>renderTracked</code> -&gt; <code>onRenderTracked</code></li><li><code>renderTriggered</code> -&gt; <code>onRenderTriggered</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wel = ref(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initWelcome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      wel.value = <span class="string">&quot;welcome vue3 compoistion API&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// just like `beforeCreate` or `created`</span></span><br><span class="line">    initWelcome();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is `mounted`</span></span><br><span class="line">    onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      initWelcome();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; wel &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="computed">computed</h2><p>如同 <code>ref</code> 和 <code>watch</code>，也可以通过从 vue 中导入的方式在 Vue 组件创建计算属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> dou = computed(<span class="function">() =&gt;</span> count.value * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; count, dou &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="watch">watch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    watch(count, <span class="function">(<span class="params">oldVal, newVal</span>) =&gt;</span> &#123;</span><br><span class="line">      consolo.log(<span class="string">&quot;old:&quot;</span>, oldVal, <span class="string">&quot;new:&quot;</span>, <span class="string">&quot;newVal&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="和模版一起使用">和模版一起使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>count: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>double count: &#123;&#123; dou &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;plus&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in student&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;: &#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; ref, reactive, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      title: <span class="built_in">String</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> dou = computed(<span class="function">() =&gt;</span> count.value * <span class="number">2</span>);</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        readersNumber.value++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> student = reactive(&#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">&quot;tom&quot;</span>,</span></span><br><span class="line"><span class="javascript">        age: <span class="string">&quot;20&quot;</span>,</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// expose to template</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        count,</span><br><span class="line">        dou,</span><br><span class="line">        plus,</span><br><span class="line">        student,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>部署 vue 项目</title>
      <link href="2021/02/28/039-deploy-vue-porject/"/>
      <url>2021/02/28/039-deploy-vue-porject/</url>
      
        <content type="html"><![CDATA[<h1 id="通用指南">通用指南</h1><p>如果你用 Vue CLI 处理静态资源并和后端框架一起作为部署的一部分，那么你需要的仅仅是确保 Vue CLI 生成的构建文件在正确的位置，并遵循后端框架的发布方式即可。</p><p>如果你独立于后端部署前端应用——也就是说后端暴露一个前端可访问的 API，然后前端实际上是纯静态应用。那么你可以将 dist 目录里构建的内容部署到任何静态文件服务器中，但要确保正确的 <code>publicPath</code>。</p><h1 id="docker-nginx">Docker (Nginx)</h1><p>在 Docker 容器中使用 Nginx 部署你的应用。</p><ol type="1"><li><p>安装 Docker</p><p>使用官方安装脚本自动安装</p><p>安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录创建 Dockerfile 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">node:10</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">./</span> <span class="string">/app</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/app</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="string">FROM</span> <span class="string">nginx</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">/app</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">--from=0</span> <span class="string">/app/dist</span> <span class="string">/app</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">nginx.conf</span> <span class="string">/etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure></li><li><p>在项目根目录创建 <code>.dockerignore</code> 文件</p><p>设置 <code>.dockerignore</code> 文件能防止 <code>node_modules</code> 和其他中间构建产物被复制到镜像中导致构建问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**&#x2F;node_modules</span><br><span class="line">**&#x2F;dist</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录创建 <code>nginx.conf</code> 文件</p><p><code>Nginx</code> 是一个能在 Docker 容器中运行的 HTTP(s) 服务器。它使用配置文件决定如何提供内容、要监听的端口等。参阅 Nginx 设置文档</p><p>以了解所有可能的设置选项。</p><p>下面是一个简单的 Nginx 设置文件，它会在 <code>80</code> 端口上提供你的 Vue 项目。<code>页面未找到</code> / <code>404</code> 错误使用的是 <code>index.html</code>，这让我们可以使用基于 <code>pushState()</code> 的路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">  default_type  application&#x2F;octet-stream;</span><br><span class="line">  log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">  access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">  sendfile        on;</span><br><span class="line">  keepalive_timeout  65;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;app;</span><br><span class="line">      index  index.html;</span><br><span class="line">      try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">      root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建你的 Docker 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t my-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sending build context to Docker daemon  884.7kB</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Successfully built 4b00e5ee82ae</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Successfully tagged my-app:latest</span></span><br></pre></td></tr></table></figure></li><li><p>运行你的 Docker 镜像</p><p>这个例子基于官方 Nginx 镜像，因此已经设置了日志重定向并关闭了自我守护进程。它也提供了其他有利于 Nginx 在 Docker 容器中运行的默认设置。更多信息参阅 Nginx Docker 仓库。</p><h2 id="section"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 my-app</span><br><span class="line">curl localhost:8080</span><br></pre></td></tr></table></figure></h2></li></ol><p>参考 （<a href="https://cli.vuejs.org/zh/guide/deployment.html#docker-nginx">部署｜ CLI</a>）</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry Pi 构建恢复分区，自动恢复系统</title>
      <link href="2021/02/04/038-raspberry-pi-recovery/"/>
      <url>2021/02/04/038-raspberry-pi-recovery/</url>
      
        <content type="html"><![CDATA[<p>首先要将树莓派的磁盘挂载到另一台电脑上，以便后续的操作。</p><h1 id="创建分区">创建分区</h1><p>第一步就是要创建一个新的分区用于恢复系统。你可以使用 <code>fdisk</code> 命令去创建。也可以使用一些图形化的工具。</p><blockquote><p><strong>Note</strong>: 记得分区时留下足够的空间去安装系统和存放备份镜像。</p></blockquote><p>这里我是在 <strong>Ubuntu</strong> 下使用 <code>gparted</code> 工具来分去的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gparted</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210204165914976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="GParted" /> 分区完了之后我们用 <code>sudo lsblk --fs</code> 看一看结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NAME           FSTYPE LABEL      UUID                                 MOUNTPOINT</span><br><span class="line">sdd</span><br><span class="line">├─sdd2         ext4   rootfs     80571af6-21c9-48a0-9df5-cffb60cf79af &#x2F;media&#x2F;ubuntu&#x2F;rootfs</span><br><span class="line">├─sdd3         ext4   recoveryfs a7adb26a-8b87-4729-99c8-9f5ac069d51e &#x2F;media&#x2F;ubuntu&#x2F;recoveryfs</span><br><span class="line">└─sdd1         vfat   boot       6341-C9E5                            &#x2F;media&#x2F;ubuntu&#x2F;boot</span><br><span class="line">sdb</span><br><span class="line">├─sdb4         ext4              3eb0c4d3-d782-44f8-b136-be73e8aa1ac4 &#x2F;media&#x2F;ubuntu&#x2F;3eb0c4d3-d782-44f8-b136-be73e8aa1ac4</span><br><span class="line">├─sdb2         ntfs              5EE0C595E0C57435                     &#x2F;media&#x2F;ubuntu&#x2F;5EE0C595E0C57435</span><br><span class="line">├─sdb5         swap              652b8cfb-fdfd-49c2-8041-3643892aa97d</span><br><span class="line">│ └─cryptswap1 swap              e68424e3-2799-4f72-8754-dacd7ad1a61c [SWAP]</span><br><span class="line">├─sdb3         vfat              1441-F786</span><br><span class="line">└─sdb1</span><br><span class="line">sda</span><br><span class="line">├─sda4         ext4              aab4fc34-f6f3-43b4-a7c2-7d70f189d0da &#x2F;</span><br><span class="line">├─sda2         vfat              0AB2-A61D                            &#x2F;boot&#x2F;efi</span><br><span class="line">├─sda5         ntfs              103ED30C3ED2EA2C</span><br><span class="line">├─sda3</span><br><span class="line">└─sda1         ntfs   恢复       320AB1060AB0C85D</span><br></pre></td></tr></table></figure><p>这里 <code>sdd</code> 就是我们的树莓派硬盘：</p><ul><li><code>sdd1</code>: boot 引导分区</li><li><code>sdd2</code>: 正常系统分区</li><li><code>sdd2</code>: 恢复系统分区</li></ul><h1 id="安装镜像">安装镜像</h1><p>这里推荐<strong>Raspberry Pi OS Lite</strong>，比较小。下载地址：<a href="https://www.raspberrypi.org/software/operating-systems/">https://www.raspberrypi.org/software/operating-systems/</a></p><p>这里你是不能直接用 <code>dd</code> 去安装的。因为你的目标是一个分区，而镜像中可能包含了多个分区。这时就需要 <code>losetup</code> 命令。</p><h4 id="查看镜像信息">查看镜像信息</h4><p><code>sudo fdisk -lu &lt;xxx.img&gt;</code> 用来查看镜像的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-MRC-WX0:~$ sudo fdisk -lu 2021-01-11-raspios-buster-armhf-lite.img</span><br><span class="line">Disk 2021-01-11-raspios-buster-armhf-lite.img: 1.8 GiB, 1862270976 bytes, 3637248 sectors</span><br><span class="line">Units: sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xe8af6eb2</span><br><span class="line"></span><br><span class="line">Device                                    Boot  Start     End Sectors  Size Id Type</span><br><span class="line">2021-01-11-raspios-buster-armhf-lite.img1        8192  532479  524288  256M  c W95 FAT32 (LBA)</span><br><span class="line">2021-01-11-raspios-buster-armhf-lite.img2      532480 3637247 3104768  1.5G 83 Linux</span><br></pre></td></tr></table></figure><h4 id="使用-losetup-创建回环设备">使用 losetup 创建回环设备</h4><p>由上图可知 <code>2021-01-11-raspios-buster-armhf-lite.img</code> 有 2 个分区，大小单位为 512 字节，转为字节计算后如下。 2021-01-11-raspios-buster-armhf-lite.img1：</p><ul><li>开始=8192x512=4194304 大小=(532479-8192)x512=268434944</li></ul><p>2021-01-11-raspios-buster-armhf-lite.img2：</p><ul><li>开始=532480x512=272629760 大小=(3637247-532480)x512=1589640704</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-MRC-WX0:~$ sudo losetup -f -o 272629760 --sizelimit 1589640704 2021-01-11-raspios-buster-armhf-lite.img</span><br><span class="line">ubuntu@ubuntu-MRC-WX0:~$ losetup -a</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;loop0: []: (&#x2F;home&#x2F;ubuntu&#x2F;2021-01-11-raspios-buster-armhf-lite.img), offset 272629760, sizelimit 1589640704</span><br></pre></td></tr></table></figure><h4 id="写入分区">写入分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/dev/loop0 of=/dev/sdd3 bs=4M status=progress</span><br><span class="line">sudo losetup --detach-all</span><br></pre></td></tr></table></figure><p>写入后，可能由于镜像的原因都是分区变小了，不过这很好解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo e2fsck -f /dev/sdd3</span><br><span class="line">sudo resize2fs /dev/sdd3</span><br></pre></td></tr></table></figure><h1 id="配置分区">配置分区</h1><p>首先我们给新的分区设置新的 lable，默认会是 rootfs： <code>e2label /dev/loop0p2 recoveryfs</code></p><p>然后我们需要修改一些文件，让它们可以正确被引导。</p><ol type="1"><li><p>使用 <code>sudo blkid</code> 查看 <code>PARTUUID</code>，结果像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdd1: LABEL&#x3D;&quot;boot&quot; UUID&#x3D;&quot;6341-C9E5&quot; TYPE&#x3D;&quot;vfat&quot; PARTUUID&#x3D;&quot;ea7d04d6-01&quot;</span><br><span class="line">&#x2F;dev&#x2F;sdd2: LABEL&#x3D;&quot;rootfs&quot; UUID&#x3D;&quot;80571af6-21c9-48a0-9df5-cffb60cf79af&quot; TYPE&#x3D;&quot;ext4&quot; PARTUUID&#x3D;&quot;ea7d04d6-02&quot;</span><br><span class="line">&#x2F;dev&#x2F;sdd3: LABEL&#x3D;&quot;recoveryfs&quot; UUID&#x3D;&quot;80571af6-21c9-48a0-9df5-cffb60cf79af&quot; TYPE&#x3D;&quot;ext4&quot; PARTUUID&#x3D;&quot;ea7d04d6-03&quot;</span><br></pre></td></tr></table></figure></li><li><p>将恢复分区挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdd3 /mnt</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>etc/fstab</code> 文件，修改对应的 PARTUUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc            /proc           proc    defaults          0       0</span><br><span class="line">PARTUUID=ea7d04d6-01  /boot           vfat    defaults          0       2</span><br><span class="line">PARTUUID=ea7d04d6-03  /               ext4    defaults,noatime  0       1</span><br><span class="line"><span class="comment"># a swapfile is not a swap partition, no line here</span></span><br><span class="line"><span class="comment">#   use  dphys-swapfile swap[on|off]  for that</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>boot</code> 中的 <code>cmdline.txt</code> 文件中的 PAERUUID 来指定启动分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;serial0,115200 console&#x3D;tty1 root&#x3D;PARTUUID&#x3D;ea7d04d6-02 rootfstype&#x3D;ext4 elevator&#x3D;deadline fsck.repair&#x3D;yes quiet splash plymouth.ignore-serial-consoles</span><br></pre></td></tr></table></figure><p>将 <code>PARTUUID=</code> 后面的 8 个字符的代码改为我们查到到的值，并将下面的 <code>-02</code> 改为 <code>-03</code>，告诉 Raspbian 引导到第三个分区。</p></li></ol><h1 id="备份镜像">备份镜像</h1><p>接下来就是要备份我们的主分区了，我们也是使用 <code>dd</code> 命令并通过 <code>gzip</code> 进行压缩。</p><p><strong>备份</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line">sudo dd <span class="keyword">if</span>=/dev/sdd2 bs=4M status=progress | gzip -6 &gt; recovery.img.gz</span><br></pre></td></tr></table></figure><p><strong>恢复</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dc recovery.img.gz | sudo dd of=/dev/sdd2 bs=4M status=progress</span><br></pre></td></tr></table></figure><h1 id="恢复脚本">恢复脚本</h1><p>我们将脚本创建在 <code>/boot</code> 中，这样在两个系统中都可以使用</p><p><strong>boot_to_recovery</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$EUID</span>&quot;</span> -ne 0 ]</span><br><span class="line">  <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Please run as root&quot;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Rebooting to recovery partition <span class="keyword">in</span> 5 seconds</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;restore&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Automatic restore selected</span><br><span class="line">    touch /boot/restore</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sleep 5</span><br><span class="line">sed -i <span class="string">&#x27;s/-02/-03/&#x27;</span> /boot/cmdline.txt</span><br><span class="line">touch /boot/ssh</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>boot_to_root</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$EUID</span>&quot;</span> -ne 0 ]</span><br><span class="line">  <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Please run as root&quot;</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Rebooting to root partition <span class="keyword">in</span> 5 seconds</span><br><span class="line">sleep 5</span><br><span class="line">sed -i <span class="string">&#x27;s/-03/-02/&#x27;</span> /boot/cmdline.txt</span><br><span class="line">touch /boot/ssh</span><br><span class="line">reboot</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p><strong>restore_root</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/boot/restore&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Restoring rootfs</span><br><span class="line">    <span class="comment">#dd if=/recovery.img of=/dev/mmcblk0p3 conv=fsync status=progress bs=4M</span></span><br><span class="line">    gzip -dc recovery.img.gz | sudo dd of=/dev/sdd2 bs=4M status=progress</span><br><span class="line">    unlink /boot/restore</span><br><span class="line">    /boot/boot_to_root</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><h3 id="自动恢复">自动恢复</h3><p>如果你想在启动恢复分区时自动运行脚本，可以将它添加到恢复分区的 <code>/etc/rc.local</code> 文件，</p><p>在 <code>exit 0</code> 之前加上 <code>/boot/restore_root</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Z-shell zsh 让终端不在只是终端</title>
      <link href="2021/01/19/037-what-is-zsh/"/>
      <url>2021/01/19/037-what-is-zsh/</url>
      
        <content type="html"><![CDATA[<p>很久之前有说到 fish，一个开箱即用的优质 shell。这次来讲讲 zsh，让你深度定制自己的 shell。使你的终端独一无二。</p><figure><img src="https://img-blog.csdnimg.cn/20210119000431880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="Screenshot" /><figcaption aria-hidden="true">Screenshot</figcaption></figure><h1 id="什么是-zsh">什么是 Zsh</h1><p>Zsh 是一个强大的 shell，既可以作为交互式 shell，也可以作为脚本语言解释器。用户社区网站"<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>"收集 Z shell 的第三方插件及主题。[8]截止于 2018 年，其 GitHub 源共有超过 1000 位贡献者、200 多款插件和超过 140 款主题。</p><p>相比于 bash，zsh 在很多方面做出了优化。例如：自带对数百条命令的补全支持；本身就可以通过文件扩展来匹配文件；自带拼写检查；可编程的命令行界面；自带一些常用的命令，如 <code>where</code>.于此同时，zsh 是兼容 bash 的，而 fish 并不是。</p><p>选择了 zsh，你会拥有比 bash 更好的使用体验，比 fish 更灵活的自定义空间。</p><h1 id="安装-zsh">安装 Zsh</h1><h2 id="linux">Linux</h2><p>安装 zsh 是非常简单的，任何的 <strong>Linux</strong> 都可以使用自带的包管理器来安装 zsh， 例如 Ubuntu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h2 id="mac">Mac</h2><p>Mac 从 2019 年开始就将默认的 shell 从 bash 替换成了 zsh，所以也许你根本不需要安装就已经拥有了 zsh。当然，如果你的 mac 是 2019 以前的，没有 zsh， 用 <code>brew</code> 安装它也十分容易。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure><h2 id="windows">Windows</h2><p>在 windows 中安装 zsh 就显得麻烦多了。首先，你需要安装 <a href="https://cygwin.com/install.html"><strong>Cygwim</strong></a>，它可以帮你在在 windows 中构建 Unix 环境，在 windows 中感受 Liunx 的感觉。</p><p>运行安装程序时，请按照说明操作，确保安装程序安装在 <code>C:\cygwin64</code>。</p><p><img src="https://img-blog.csdnimg.cn/20210119010300363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p>在包选择页面，搜索 wget 展开所有在 Web 下选择最新版本在 wget 的 bin 下，不需要选择源。然后继续</p><figure><img src="https://img-blog.csdnimg.cn/20210119010321466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>我们将使用 Cygwin 安装一些软件包，这些软件包将有助于在 Windows 上使用 Linux 系统。我们将安装 <code>apt-cyg</code>，它将像 <code>apt-get</code> 一样工作，还将安装许多其他包，像 vim 一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget rawgit.com/transcode-open/apt-cyg/master/apt-cyg</span><br><span class="line">install apt-cyg /bin</span><br><span class="line">apt-cyg install zsh git</span><br></pre></td></tr></table></figure><h2 id="让-zsh-成为默认">让 Zsh 成为默认</h2><p>在 Linux 和 Mac 中，你只需要打开 terminal， 输入下面的命令就可将 zsh 设置成默认的 shell。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh -s $(<span class="built_in">which</span> zsh)</span><br></pre></td></tr></table></figure><h1 id="配置你的-zsh">配置你的 Zsh</h1><p>一开进入 zsh，你可能觉得很一般。因为 zsh 的默认几乎和 bash 差不多。但 zsh 拥有许多强大的插件，这些插件可以在<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>中找到。</p><p>这里呢，我推荐使用 <a href="https://github.com/zimfw/zimfw">zimfw</a> 来安装插件。Zim 是一个 Zsh 配置框架，具有极快的速度和模块化扩展。Zim 非常容易定制，并且提供了一组丰富的模块和功能。</p><p>Zim 提供了两种安装方式。</p><ul><li><p>With curl:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh</span><br></pre></td></tr></table></figure></li><li><p>With wget:</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -nv -O - https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh</span><br></pre></td></tr></table></figure></code></pre><p>然后，就可以在 <code>~/.zimrc</code> 中配置你想要的插件，这里我也推荐几个：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zmodule completion</span><br><span class="line"></span><br><span class="line">zmodule zsh-users&#x2F;zsh-completions</span><br><span class="line"></span><br><span class="line">zmodule zsh-users&#x2F;zsh-autosuggestions</span><br><span class="line"></span><br><span class="line"># Fish-like history search (up arrow) for Zsh.</span><br><span class="line"># zsh-users&#x2F;zsh-history-substring-search must be sourced after zsh-users&#x2F;zsh-syntax-highlighting</span><br><span class="line">zmodule zsh-users&#x2F;zsh-history-substring-search</span><br><span class="line"></span><br><span class="line"># Enables and configures smart and extensive tab completion.</span><br><span class="line"># completion must be sourced after zsh-users&#x2F;zsh-completions</span><br><span class="line">zmodule zdharma&#x2F;fast-syntax-highlighting</span><br></pre></td></tr></table></figure><p>配置好你想要的模块后，记得使用 <code>zimfw install</code> 来安装它们。</p><p>同样的，安装主题就和安装模块一样，放在配置文件中， install 就好了。</p><p><a href="https://github.com/zimfw/zimfw/wiki/Themes">https://github.com/zimfw/zimfw/wiki/Themes</a></p><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></p><h1 id="深度定制-zsh">深度定制 Zsh</h1><h2 id="停止重复安装它">停止重复安装它</h2><p>在完成插件和主题的安装后，想必你的 zsh 已经相当的好用了。</p><p>Ok，现在你基本配置好了你喜欢的 zsh，但如果换了电脑不就要再来一次这些安装过程，实在是太麻烦了。我们可以将配置上传到 github 上并写一个自动安装的脚本，这样下一次，我们只需要 clone 代码，运行脚本就重新配置好 zsh 了。</p><p>这里我给出我的脚本，作为参考。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PLUG_DIR=<span class="variable">$HOME</span>/.zim</span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="variable">$PLUG_DIR</span> ]]; <span class="keyword">then</span></span><br><span class="line">    curl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh</span><br><span class="line">    rm ~/.zimrc</span><br><span class="line">    ln -s ~/.config/zsh/zimrc ~/.zimrc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;source ~/.config/zsh/zshrc&quot;</span>&gt;&gt;~/.zshrc</span><br><span class="line">    zimfw install</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="像-vim-一样使用">像 vim 一样使用</h2><p>如果你是一个 Vim 或者 Neovim 的使用者，想必一定十分喜爱 vim 的模式。那么，恭喜你，zsh 刚好支持 vim 模式和键位的绑定。</p><p>创建一个文件 <code>vi.zsh</code>，内容是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bindkey</span> -v</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;i&quot;</span> vi-insert</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;I&quot;</span> vi-insert-bol</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;h&quot;</span> vi-backward-char</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;l&quot;</span> vi-forward-char</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;0&quot;</span> vi-beginning-of-line</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;4&quot;</span> vi-end-of-line</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;j&quot;</span> down-line-or-history</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;k&quot;</span> up-line-or-history</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;u&quot;</span> undo</span><br><span class="line"><span class="comment">#bindkey -M vicmd &quot;-&quot; vi-rev-repeat-search</span></span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;=&quot;</span> vi-repeat-search</span><br><span class="line"><span class="built_in">bindkey</span> -M vicmd <span class="string">&quot;e&quot;</span> vi-forward-word-end</span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&quot;^D&quot;</span> autosuggest-accept</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> zle-line-init zle-keymap-select &#123;</span><br><span class="line">    RPS1=<span class="string">&quot;<span class="variable">$&#123;<span class="variable">$&#123;KEYMAP/vicmd/-- NOR --&#125;</span>/(main|viins)/-- INS --&#125;</span>&quot;</span></span><br><span class="line">    RPS2=<span class="variable">$RPS1</span></span><br><span class="line">    <span class="built_in">zle</span> reset-prompt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> zle-keymap-select &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$&#123;KEYMAP&#125;</span> == vicmd ]] || [[ <span class="variable">$1</span> = <span class="string">&#x27;block&#x27;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -ne <span class="string">&#x27;\e[1 q&#x27;</span></span><br><span class="line">  <span class="keyword">elif</span> [[ <span class="variable">$&#123;KEYMAP&#125;</span> == main ]] || [[ <span class="variable">$&#123;KEYMAP&#125;</span> == viins ]] || [[ <span class="variable">$&#123;KEYMAP&#125;</span> = <span class="string">&#x27;&#x27;</span> ]] || [[ <span class="variable">$1</span> = <span class="string">&#x27;beam&#x27;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -ne <span class="string">&#x27;\e[5 q&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">zle</span> -N zle-keymap-select</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -ne <span class="string">&#x27;\e[5 q&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">preexec</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> -ne <span class="string">&#x27;\e[5 q&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">_fix_cursor</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> -ne <span class="string">&#x27;\e[5 q&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">precmd_functions+=(_fix_cursor)</span><br><span class="line"></span><br><span class="line"><span class="built_in">zle</span> -N zle-line-init</span><br><span class="line"><span class="built_in">zle</span> -N zle-keymap-select</span><br><span class="line"></span><br><span class="line">KEYTIMEOUT=1</span><br></pre></td></tr></table></figure><p>然后在 <code>~/.zshrc</code> 中使用 <code>source</code> 命令载入它，你就可以像使用 vim 一样使用 zsh。</p><h1 id="我的-zsh">我的 Zsh</h1><p>最后，贴上我的 zsh 配置，供有需要的人参考。 <a href="https://github.com/zlj-zz/dotconfig/tree/master/zsh">https://github.com/zlj-zz/dotconfig/tree/master/zsh</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter 按钮用法小记</title>
      <link href="2020/11/17/036-flutter-button/"/>
      <url>2020/11/17/036-flutter-button/</url>
      
        <content type="html"><![CDATA[<h1 id="flutter-按钮">Flutter 按钮</h1><p>知识是人类进步的阶梯，总结笔记就是...... 额，管他的呢，挺好。那今天就聊聊 Flutter 中的按钮组件。</p><p>Flutter 中已经定义好了一些默认的按钮组件供我们直接使用，所以先请它们登场</p><ol type="1"><li><code>RaisedButton</code>: 凸起的按钮</li><li><code>FlatButton</code>: 扁平的按钮</li><li><code>OutlineButton</code>: 边框按钮</li><li><code>IconButton</code>: 图标按钮</li></ol><blockquote><p>前面三个都继承自 <code>MaterialButton</code>，最后一个继承自 <code>StatelessWidget</code>。</p></blockquote><p>为了去使用它们，那得再了解了解其内在（属性），下面就给出一张表：</p><table><thead><tr class="header"><th>属性</th><th>值类型</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>onPressed</td><td>VoidCallback</td><td>一般接收一个方法 必填参数，按下按钮时触发的回调，传 <code>null</code> 表示按钮禁用，会显示禁用相关样式</td></tr><tr class="even"><td>child</td><td>Widget</td><td>文本控件</td></tr><tr class="odd"><td>textColor</td><td>Color</td><td>文本颜色</td></tr><tr class="even"><td>color</td><td>Color</td><td>按钮的颜色</td></tr><tr class="odd"><td>disabledColor</td><td>Color</td><td>按钮禁用时的颜色</td></tr><tr class="even"><td>disabledTextColor</td><td>Color</td><td>按钮禁用时的文本颜色</td></tr><tr class="odd"><td>splashColor</td><td>Color</td><td>点击按钮时水波纹的颜色</td></tr><tr class="even"><td>highlightColor</td><td>Color</td><td>点击（长按）按钮后按钮的颜色</td></tr><tr class="odd"><td>elevation</td><td>double</td><td>阴影的范围，值越大阴影范围越大</td></tr><tr class="even"><td>padding</td><td>EdgeInsetsGeometry （抽象类）</td><td>内边距</td></tr><tr class="odd"><td>shape</td><td>ShapeBorder（抽象类）</td><td>设置按钮的形状</td></tr><tr class="even"><td>minWidth</td><td>double</td><td>最小宽度</td></tr><tr class="odd"><td>height</td><td>double</td><td>高度</td></tr></tbody></table><p>上面这些属性呢，就是大多按钮都有的。但是，有那么几个我们的单独说一下（怕你不会用啊）。</p><p><strong>padding</strong></p><p>内边距，其接收值的类型是<code>EdgeInsetsGeometry</code>类型的，是一个抽象类。所以一般都用<code>EdgeInsets</code>类中的方法来设置，先看看这个类中的常用方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单独设置左上右下的间距，四个参数都要填写</span></span><br><span class="line"><span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.right, <span class="keyword">this</span>.bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独设置左上右下的间距，四个均为可选参数</span></span><br><span class="line">  <span class="keyword">const</span> EdgeInsets.only(&#123;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="number">0.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.bottom = <span class="number">0.0</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性设置上下左右的间距</span></span><br><span class="line"><span class="keyword">const</span> EdgeInsets.all(<span class="built_in">double</span> value)</span><br><span class="line">  : left = value, top = value, right = value, bottom = value;</span><br></pre></td></tr></table></figure><p>看到这些方法，想必大家应该知道怎么用了吧，这里我就不举例了哈。（啥？有人说不会。唉！那我就写一个吧）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">      onPressed: <span class="keyword">null</span>,</span><br><span class="line">      child: Text(<span class="string">&quot;按钮&quot;</span>),</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">      textColor: Colors.white,</span><br><span class="line">      padding: EdgeInsets.only(top: <span class="number">30</span>),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong>shape</strong></p><p>shape 用来设置按钮的形状，其接收值是 ShapeBorder 类型，也是一个抽象类。它的实现类还是蛮多的，我们主要来看看常用的就好了。</p><ul><li><code>BeveledRectangleBorder</code> 六边形</li><li><code>CircleBorder</code> 圆形</li><li><code>RoundedRectangleBorder</code> 圆角矩形</li><li><code>StadiumBorder</code> 两端是半圆</li></ul><p>它们主要用的属性就两个，<code>side</code> 和 <code>borderRadius</code></p><p><code>side</code> 接收一个 <code>BorderSide</code> 类型的值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BorderSide(&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>), <span class="comment">// 颜色</span></span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">1.0</span>,                     <span class="comment">// 宽度</span></span><br><span class="line">    <span class="keyword">this</span>.style = BorderStyle.solid,       <span class="comment">// 样式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>borderRadius</code> 接收一个 <code>BorderRadius</code> 类型的值，常用方法也不多。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BorderRadius.all()        <span class="comment">// 配置所有方向</span></span><br><span class="line">BorderRadius.cricular()   <span class="comment">// 环形配置，跟all效果差不多，直接接收double类型的值</span></span><br><span class="line">BorderRadius.horizontal() <span class="comment">// 只配置左右方向</span></span><br><span class="line">BorderRadius.only()       <span class="comment">// 可选左上，右上，左下，右下配置</span></span><br><span class="line">BorderRadius.vertical()   <span class="comment">// 只配置上下方向</span></span><br></pre></td></tr></table></figure><p><strong>OutlineButton</strong></p><p><code>OutlineButton</code> 是一个有默认边线且背景透明的按钮，也就是说我们设置其边线和颜色是无效的。</p><p><strong>IconButton</strong></p><p><code>IconButton</code> 是直接继承自 <strong>StatelessWidget </strong>的，默认没有背景,所以有个 <code>icon</code> 参数是必填的。下面给出参考代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">      icon: Icon(Icons.home),</span><br><span class="line">      onPressed: <span class="keyword">null</span>,</span><br><span class="line">      color: Colors.blueAccent,</span><br><span class="line">      highlightColor: Colors.red,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>Icon 除了用 flutter 提供的之外还可以使用图片去自定义图形图标，下面也会给出参考代码</p><blockquote><p><strong>叮</strong> 图片一定要 png，加载出来是纯色的背景图片哦</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget getImageIcon()&#123;</span><br><span class="line">    <span class="keyword">return</span> ImageIcon(</span><br><span class="line">          AssetImage(<span class="string">&#x27;images/test.png&#x27;</span>),</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          size: <span class="number">50</span>,</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IconButton(</span><br><span class="line">      icon: getImageIcon(),</span><br><span class="line">      onPressed: <span class="keyword">null</span>,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>当然也可以使用图片</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget getImage() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Image.asset(</span><br><span class="line">      <span class="string">&#x27;images/test.png&#x27;</span>,</span><br><span class="line">      width: <span class="number">300.0</span>,</span><br><span class="line">      height: <span class="number">300.0</span>,</span><br><span class="line">      matchTextDirection: <span class="keyword">false</span>,</span><br><span class="line">      fit: BoxFit.fitWidth,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 路由小谈</title>
      <link href="2020/11/17/034-flutter-route/"/>
      <url>2020/11/17/034-flutter-route/</url>
      
        <content type="html"><![CDATA[<h2 id="直接跳转">直接跳转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;newpage.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Navigator.of(context).push(</span><br><span class="line">    MaterialPageRoute(builder: (context)=&gt;NewPage())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>如果跳转的页面需要参数，可以直接传入。</p></blockquote><h2 id="初始化执行路线">初始化执行路线</h2><p>定义路由集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> routes = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: (context) =&gt; Loading(),</span><br><span class="line">  <span class="string">&#x27;/home&#x27;</span>: (context) =&gt; Home(),</span><br><span class="line">  <span class="string">&#x27;/settings&#x27;</span>: (context) =&gt; Settings(),</span><br><span class="line">  <span class="string">&#x27;/update&#x27;</span>: (context) =&gt; UpdatePage(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用路由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> runApp(MarsApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarsApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> MaterialApp(</span><br><span class="line">  initialRoute: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  routes: routes,</span><br><span class="line">);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">&#x27;/stats&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="pushandremoveuntil"><code>pushAndRemoveUntil</code></h2><p>这个方式是跳转到某个页面，然后移除路由直到<code>...</code>为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通使用</span></span><br><span class="line">Navigator.of(context).pushAndRemoveUntil(</span><br><span class="line">    MaterialPageRoute(builder: (context) =&gt; MyPage()), (route) =&gt; route == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由方式</span></span><br><span class="line">Navigator.pushNamedAndRemoveUntil(context, <span class="string">&#x27;/&#x27;</span>, (route) =&gt; route == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>上面的两种使用方式都可以达到禁止返回上一级的作用，应为这里给出的是 <code>route == null</code>, 所以会将路由栈里的元素全部移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">&#x27;/setting&#x27;</span>,ModalRoute.withName(<span class="string">&#x27;/&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面的方式可以在跳转到<code>setting</code>页面后，若返回则直接到<code>/</code>页面。</p><h2 id="pushreplancementnamed"><code>pushReplancementNamed</code></h2><p>使用该方法跳转页面，会在路由栈中用新页面替换老页面。这时完成跳转后返回则好似返回上上个页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pushReplacementNamed(<span class="string">&#x27;/page&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="popuntil"><code>popUntil</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.popUntil(context,ModalRoute.withName(<span class="string">&#x27;/&#x27;</span>));</span><br></pre></td></tr></table></figure><p>与 <code>pushAndRemoveUntil</code> 配套，退回到某个指定页面。</p><h2 id="popandpushnamed"><code>popAndPushNamed</code></h2><p>与<code>pushReplacementNamed</code>方法类似，其执行结果栈是的路由栈与<code>pushReplacementNamed</code>方法的效果是一致的。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter应用打包、修改图标和app名字</title>
      <link href="2020/11/17/035-flutter-build-package/"/>
      <url>2020/11/17/035-flutter-build-package/</url>
      
        <content type="html"><![CDATA[<h1 id="打包-flutter-app">打包 flutter app</h1><h2 id="创建密钥">创建密钥</h2><p>如果您已有密钥库，请跳到下一步。 如果没有，请在命令行中运行以下命令来创建一个：</p><p>在 Mac / Linux 上，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -<span class="built_in">alias</span> key</span><br></pre></td></tr></table></figure><p>在 Windows 上，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -v -keystore c:\Users\USER_NAME\key.jks -storetype JKS -keyalg RSA -keysize 2048 -validity 10000 -<span class="built_in">alias</span> key</span><br></pre></td></tr></table></figure><p>此命令将<code>key.jks</code>文件存储在主目录中。 如果要将其存储在其他位置，请更改传递给<code>-keystore</code>参数的参数。 但是，请将密钥库文件保持私有状态； 不要将其检入公共源代码控制中！</p><blockquote><p><strong>注意</strong>：</p><ul><li><code>keytool</code>命令可能不在您的路径中，它是 Java 的一部分，而 Java 是作为 Android Studio 的一部分安装的。 对于具体路径，请运行<code>flutter doctor -v</code>并找到在'Java binary at:'之后打印的路径。 然后使用该标准路径将 Java（最后）替换为 keytool。 如果您的路径包含以空格分隔的名称（例如“Program Files”），请使用平台专用的名称表示法。 例如，在 Mac / Linux 上，使用 Program  Files，在 Windows 上，使用“ Program Files”。</li><li>只有 Java 9 或更高版本才需要<code>-storetype JKS</code>标记。 从 Java 9 版本开始，密钥库类型默认为<code>PKS12</code>。</li></ul></blockquote><h2 id="应用程序中引用密钥库">应用程序中引用密钥库</h2><p>创建一个名为<code>&lt;app dir&gt;/android/key.properties</code>的文件，其中包含对密钥库的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword&#x3D;&lt;password from previous step&gt;</span><br><span class="line">keyPassword&#x3D;&lt;password from previous step&gt;</span><br><span class="line">keyAlias&#x3D;key</span><br><span class="line">storeFile&#x3D;&lt;location of the key store file, such as &#x2F;Users&#x2F;&lt;user name&gt;&#x2F;key.jks&gt;</span><br></pre></td></tr></table></figure><h2 id="配置-gradle-登录">配置 Gradle 登录</h2><p>通过编辑<code>&lt;app dir&gt;/android/app/build.gradle</code>文件为您的应用配置签名。</p><ol type="1"><li><p>在 android 块之前添加代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用属性文件中的密钥库信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def keystoreProperties &#x3D; new Properties()</span><br><span class="line">def keystorePropertiesFile &#x3D; rootProject.file(&#39;key.properties&#39;)</span><br><span class="line">if (keystorePropertiesFile.exists()) &#123;</span><br><span class="line">    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>key.properties</code>文件加载到<code>keystoreProperties</code>对象中。</p></li><li><p>在 buildTypes 块之前添加代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: Add your own signing config for the release build.</span><br><span class="line">        &#x2F;&#x2F; Signing with the debug keys for now,</span><br><span class="line">        &#x2F;&#x2F; so &#96;flutter run --release&#96; works.</span><br><span class="line">        signingConfig signingConfigs.debug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用签名配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        keyAlias keystoreProperties[&#39;keyAlias&#39;]</span><br><span class="line">        keyPassword keystoreProperties[&#39;keyPassword&#39;]</span><br><span class="line">        storeFile keystoreProperties[&#39;storeFile&#39;] ? file(keystoreProperties[&#39;storeFile&#39;]) : null</span><br><span class="line">        storePassword keystoreProperties[&#39;storePassword&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模块的<code>build.gradle</code>文件中配置<code>signingConfigs</code>块。</p></li></ol><p>您的应用的发布版本现在将自动签名。</p><blockquote><p><strong>注意</strong>：更改 gradle 文件后，您可能需要运行<code>Flutter Clean</code>。 这样可以防止缓存的版本影响签名过程。</p></blockquote><h2 id="用-r8-缩小代码">用 R8 缩小代码</h2><p>R8 是 Google 推出的新代码缩减器，在您构建发行版 APK 或 AAB 时默认启用。 要禁用 R8，请传递<code>--no-shrink</code>标志在使用<code>flutter build apk</code>或<code>flutter build appbundle</code>。</p><blockquote><p><strong>注意</strong>：混淆和缩小会大大延长 Android 应用程序的编译时间。</p></blockquote><h2 id="查看应用清单">查看应用清单</h2><p>查看位于<code>&lt;app dir&gt;/android/app/src/main</code>中的默认<code>App Manifest</code>文件<code>AndroidManifest.xml</code>，并验证值是否正确，尤其是以下内容：</p><p><strong><em>应用</em></strong></p><p>在 application 标记中编辑<code>android：label</code>，以反映应用的最终名称。</p><p><strong><em>权限</em></strong></p><p>如果您的应用程序代码需要 Internet 访问，请添加<code>android.permission.INTERNET</code>权限。 标准模板不包含此标签，但允许在开发程中访问 Internet 以启用 Flutter 工具与正在运行的应用程序之间的通信</p><h2 id="查看构建配置">查看构建配置</h2><p>查看位于<code>&lt;app dir&gt;/android/app</code>中的默认 Gradle 构建文件文件<code>build.gradle</code>，并验证值是否正确，尤其是<code>defaultConfig</code>块中的以下值：</p><p><strong><em>applicationId</em></strong></p><p>指定最终的唯一（应用程序 ID）<code>appid</code></p><p><strong>versionCode &amp; versionName</strong></p><p>指定内部应用程序的版本号，以及版本号显示字符串。 您可以通过在<code>pubspec.yaml</code>文件中设置<code>version</code>属性来执行此操作。 请查阅版本文档中的版本信息指南。</p><p><strong><em>minSdkVersion，compilesdkVersion &amp; targetSdkVersion</em></strong></p><p>指定最低 API 级别，在其上编译应用程序的 API 级别以及在其上设计运行该应用程序的最大 API 级别。 有关详细信息，请查阅版本文档中的“ API 级别”部分。</p><p>指定您的应用使用的 Android SDK 构建工具的版本。 或者，您可以使用 Android Studio 中的[Android Gradle 插件]，它将自动为您的应用程序导入所需的最低构建工具，而无需使用此属性。</p><h2 id="构建要发布的应用">构建要发布的应用</h2><p>发布到 Play 商店时，您有两种可能的发行格式。</p><ul><li>App bundle（首选）</li><li>APK</li></ul><h3 id="创建-app-bundle">创建 app bundle</h3><p>如果您完成了签名步骤，则将对应用程序捆绑包进行签名。 此时，您可能会考虑混淆 Dart 代码，以使反向工程更加困难。 混淆代码涉及在构建命令中添加几个标志，并维护其他文件以消除对堆栈跟踪的混淆。</p><p>在命令行中：</p><ol type="1"><li><p>进入 <code>cd &lt;app dir&gt;</code></p><p>（将<code>&lt;app dir&gt;</code>替换为应用程序的目录。）</p></li><li><p>运行<code>flutter build appbundle</code></p><p>（运行<code>flutter build</code>默认为发布版本。）</p></li></ol><p>在<code>&lt;app dir&gt;/build/app/outputs/bundle/release/app.aab</code>中创建了您的应用程序的发行包。</p><p>默认情况下，应用程序捆绑包包含 Dart 代码和 Flutter 运行时，它们针对 armeabi-v7a（ARM 32 位），arm64-v8a（ARM 64 位）和 x86-64（x86 64 位）编译。</p><h3 id="创建-apk">创建 APK</h3><p>尽管应用捆绑包的优先级高于 APK，但有些商店尚不支持应用捆绑包。 在这种情况下，请为每个目标 ABI（应用程序二进制接口）构建一个发行版 APK。</p><p>如果您完成了签名步骤，则 APK 将被签名。 此时，您可能会考虑混淆 Dart 代码，以使反向工程更加困难。 混淆代码涉及在构建命令中添加几个标志。</p><p>在命令行中：</p><ol type="1"><li><p>进入 <code>cd &lt;app dir&gt;</code></p><p>（将<code>&lt;app dir&gt;</code>替换为应用程序的目录。）</p></li><li><p>运行<code>flutter build apk --split-per-abi</code></p><p>（运行<code>flutter build</code>默认为<code>--release</code>。）</p></li></ol><p>此命令产生三个 APK 文件：</p><ul><li><code>&lt;app dir&gt;/build/app/outputs/apk/release/app-armeabi-v7a-release.apk</code></li><li><code>&lt;app dir&gt;/build/app/outputs/apk/release/app-arm64-v8a-release.apk</code></li><li><code>&lt;app dir&gt;/build/app/outputs/apk/release/app-x86_64-release.apk</code></li></ul><p>删除<code>--split-per-abi</code>标志会生成一个 fat APK，其中包含为所有目标 ABI 编译的代码。 此类 APK 的大小要大于拆分后的对应文件，导致用户下载不适用于其设备架构的本机二进制文件。</p><h3 id="在设备上安装-apk">在设备上安装 APK</h3><p>请按照以下步骤在连接的 Android 设备上安装 APK。</p><p>在命令行中：https://flutter.dev/docs/deployment/android</p><ol type="1"><li>使用 USB 电缆将 Android 设备连接到计算机。</li><li>使用<code>cd &lt;app dir&gt;</code>，其中<code>&lt;app dir&gt;</code>是您的应用程序目录。</li><li>运行<code>flutter install</code>。</li></ol><p><a href="https://flutter.dev/docs/deployment/android">https://flutter.dev/docs/deployment/android</a></p><h1 id="修改图标和-app-名字">修改图标和 app 名字</h1><h2 id="android">Android</h2><ol type="1"><li><p>打开<code>&lt;app dir&gt;/android/app/src/main/AndroidMainifest.xml</code>，找到配置位置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">    android:name=&quot;io.flutter.app.FlutterApplication&quot;</span><br><span class="line">    android:label=&quot;flutter-app&quot;</span><br><span class="line">    android:icon=&quot;@mipmap/ic_luncher_logo&quot;&gt;</span><br><span class="line">    &lt;activity</span><br></pre></td></tr></table></figure><p><code>label</code>为 app 名字，<code>icon</code>为 app 图标。</p></li><li><p>图标存放位置在<code>&lt;app dir&gt;/android/app/src/main/res</code>下， &gt; <strong>注意</strong>: &gt; &gt; - 有好几个 mipmap 文件夹，这和 ios 是一样的，这几个是适配不同分辨率的手机。只需让美工出相应尺寸的图标放到相应的文件夹就可以了。 &gt; - 注意图片需要是 png 格式。</p></li></ol><h2 id="ios">IOS</h2><ol type="1"><li><p>打开<code>&lt;app dir&gt;/ios/Runner/info/plist</code>，找到配置位置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleDevelopmentRegion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>$(DEVELOPMENT_LANGUAGE)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleExecutable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>$(EXECUTABLE_NAME)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>$(PRODUCT_BUNDLE_IDENTIFIER)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleInfoDictionaryVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>6.0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>flutter-app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>CFBundleName</code>下面的字符串就是 app 的名称。</p></li><li><p>图标放到<code>&lt;app dir&gt;/ios/Runner/Assets.xcassets/AppIcon.appiconset</code>下，然后在<code>Contents.json</code>配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;images&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;size&quot;</span> : <span class="string">&quot;20x20&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;idiom&quot;</span> : <span class="string">&quot;iphone&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;filename&quot;</span> : <span class="string">&quot;Icon-App-20x20@2x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;scale&quot;</span> : <span class="string">&quot;2x&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;size&quot;</span> : <span class="string">&quot;20x20&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;idiom&quot;</span> : <span class="string">&quot;iphone&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;filename&quot;</span> : <span class="string">&quot;Icon-App-20x20@3x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;scale&quot;</span> : <span class="string">&quot;3x&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;size&quot;</span> : <span class="string">&quot;29x29&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;idiom&quot;</span> : <span class="string">&quot;iphone&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;filename&quot;</span> : <span class="string">&quot;Icon-App-29x29@1x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;scale&quot;</span> : <span class="string">&quot;1x&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;size&quot;</span> : <span class="string">&quot;29x29&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;idiom&quot;</span> : <span class="string">&quot;iphone&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;filename&quot;</span> : <span class="string">&quot;Icon-App-29x29@2x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;scale&quot;</span> : <span class="string">&quot;2x&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>过</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux remote connection, transmission, synchronization</title>
      <link href="2020/10/20/033-linux-remote-connection-transmission-synchronization/"/>
      <url>2020/10/20/033-linux-remote-connection-transmission-synchronization/</url>
      
        <content type="html"><![CDATA[<h1 id="use-rsync-to-synchronization">Use <code>rsync</code> to synchronization</h1><p>一般我们使用 rsync 有两种认证方式，</p><pre><code>rsync-daemon方式，需要配置本地文件，灵活性一般ssh方式，直接远程连接传输，简单粗暴</code></pre><p>记录一下相关命令参数，以防忘记。</p><p>同步需求</p><p>本机：本机用户 bear，/home/bear/mydir 目录</p><p>远程服务器：root@114.215.183.37 ，USE 用户 bear 下 /home/bear/workdir 目录</p><p>命令使用</p><h2 id="从本地同步到远程">从本地同步到远程</h2><p>默认 SSH 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz -e ssh /home/bear/mydir root@114.215.183.37:/home/bear/workdir</span><br></pre></td></tr></table></figure><p>指定 SSH 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz -e &#x27;ssh -p 5555&#x27; /home/bear/mydir root@114.215.183.37:/home/bear/workdir</span><br></pre></td></tr></table></figure><h2 id="从远程同步到本地">从远程同步到本地</h2><p>默认 SSH 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avzP -e ssh root@114.215.183.37:/home/bear/workdir /home/bear/mydir</span><br></pre></td></tr></table></figure><p>指定 SSH 端口</p><h2 id="section"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avzP -e &#x27;ssh -p 5555&#x27; root@114.215.183.37:/home/bear/workdir /home/bear/mydir</span><br></pre></td></tr></table></figure></h2><h1 id="linux-使用-sshfs-挂载远程目录到本地">Linux 使用 sshfs 挂载远程目录到本地</h1><p>挂载远程目录的方式很多，这里把 sshfs 记录一下备忘。</p><p>安装 sshfs</p><p>在 Ubuntu 下，只需要使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\$ sudo apt-get install sshfs</span><br></pre></td></tr></table></figure><p>一共才 140kB</p><p>挂载远程目录到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\$ sshfs user@hostIP:path MountDir</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\$ sshfs Suzzz@192.168.103.111:/home/Suzzz ~/Tmp/</span><br></pre></td></tr></table></figure><p>这样就把远程目录 <code>/home/Suzzz</code> 挂载到了本地的 <code>~/Tmp</code> 下</p><p>这样的挂载，在文件管理器中也是可见的。</p><p>现在可以在终端或者图形界面来访问这个目录了</p><p>卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fusermount -u MountDir</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How to create a BLE service</title>
      <link href="2020/10/20/032-python-how-to-create-ble-serve/"/>
      <url>2020/10/20/032-python-how-to-create-ble-serve/</url>
      
        <content type="html"><![CDATA[<p>Due to the needs of the Project, I need to build a BLE service and use <code>Python</code>. But since I haven't done it before, I first searched the Internet for any relevant cases. Unfortunately, there is basically no relevant content online. The network only has a large number of classic Bluetooth cases. So when I solved this problem, I shared the method.</p><p>You can from <a href="www.kernel.org/pub/linux/bluetooth/">here</a> to get a demo. Then, you need unzip the file.</p><p>Execute BLE GATT server example code.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bluez-5.43/test/example_gatt_server</span><br></pre></td></tr></table></figure><p>check the output, it should be like this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bluez/bluez-5.43/<span class="built_in">test</span>/example-gatt-server</span></span><br><span class="line">Registering GATT application...</span><br><span class="line">GetManagedObjects</span><br><span class="line">GATT application registered</span><br><span class="line">Battery Level drained: 98</span><br><span class="line">Battery Level drained: 96</span><br></pre></td></tr></table></figure><p>Now, the GATT server is running. Since the example code implements “Fake Battery service that emulates a draining battery”, it outputs “Battery Level drained” message on the console every 5 seconds.</p><p>Next I will tell you how to use the demo. We just need <code>example_gatt_server</code>, <code>example_gatt_client</code> and <code>example_advertisement</code>, you can copy them to your project fold. You need to change their name to add <code>.py</code> suffix.</p><p>Then we need to create our own BLE server file, e.g: <code>my_ble_server.py</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> dbus, dbus.mainloop.glib</span><br><span class="line"><span class="keyword">from</span> gi.repository <span class="keyword">import</span> GLib</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> gi.repository <span class="keyword">import</span> GObject</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> gobject <span class="keyword">as</span> GObject</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ai.bt.example_advertisement <span class="keyword">import</span> Advertisement</span><br><span class="line"><span class="keyword">from</span> ai.bt.example_advertisement <span class="keyword">import</span> register_ad_cb, register_ad_error_cb</span><br><span class="line"><span class="keyword">from</span> ai.bt.example_gatt_server <span class="keyword">import</span> Service, Characteristic</span><br><span class="line"><span class="keyword">from</span> ai.bt.example_gatt_server <span class="keyword">import</span> register_app_cb, register_app_error_cb</span><br><span class="line"></span><br><span class="line">BLUEZ_SERVICE_NAME = <span class="string">&#x27;org.bluez&#x27;</span></span><br><span class="line">DBUS_OM_IFACE = <span class="string">&#x27;org.freedesktop.DBus.ObjectManager&#x27;</span></span><br><span class="line">LE_ADVERTISING_MANAGER_IFACE = <span class="string">&#x27;org.bluez.LEAdvertisingManager1&#x27;</span></span><br><span class="line">GATT_MANAGER_IFACE = <span class="string">&#x27;org.bluez.GattManager1&#x27;</span></span><br><span class="line">GATT_CHRC_IFACE = <span class="string">&#x27;org.bluez.GattCharacteristic1&#x27;</span></span><br><span class="line">UART_SERVICE_UUID = <span class="string">&#x27;6e400001-b5a3-f393-00a9-e50e24dcca9e&#x27;</span></span><br><span class="line">UART_TX_CHARACTERISTIC_UUID = <span class="string">&#x27;6e400003-b5a3-f393-00a9-e50e24dcca9e&#x27;</span></span><br><span class="line">UART_SE_CHARACTERISTIC_UUID = <span class="string">&#x27;6e400006-b5a3-f393-00a9-e50e24dcca9e&#x27;</span></span><br><span class="line">mainloop = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoCharacteristic</span>(<span class="params">Characteristic</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bus, index, service</span>):</span></span><br><span class="line">        Characteristic.__init__(self, bus, index, UART_TX_CHARACTERISTIC_UUID,</span><br><span class="line">                                [<span class="string">&#x27;read&#x27;</span>, <span class="string">&#x27;write&#x27;</span>, <span class="string">&#x27;notify&#x27;</span>], service)</span><br><span class="line">        self.logger = ai.coloredlogging.get_logger(<span class="string">&quot;Play&quot;</span>,</span><br><span class="line">                                                   ai.coloredlogging.WHITE)</span><br><span class="line">        self.logger.addHandler(logging.NullHandler())</span><br><span class="line"></span><br><span class="line">        self.notifying = <span class="literal">False</span></span><br><span class="line">        <span class="comment">#GLib.io_add_watch(sys.stdin, GLib.IO_IN, self.notify_voic_command)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">WriteValue</span>(<span class="params">self, value, options</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Let client to write data to here.</span></span><br><span class="line"><span class="string">        Receive notify type data to change the notify type.</span></span><br><span class="line"><span class="string">        Receive command to enable and disable the control mode.</span></span><br><span class="line"><span class="string">        Receive action command to control MarsCat.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s = <span class="built_in">bytes</span>(value).decode()</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReadValue</span>(<span class="params">self, options</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Let client to read data from here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [dbus.Byte(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StartNotify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.notifying:</span><br><span class="line">            self.logger.debug(<span class="string">&#x27;Already notifying, nothing to do&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.notifying = <span class="literal">True</span></span><br><span class="line">        self.toggle_notification()</span><br><span class="line">        print(<span class="string">&#x27;start notify&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StopNotify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.notifying:</span><br><span class="line">            self.logger.debug(<span class="string">&#x27;Not notifying, nothing to do&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.notifying = <span class="literal">False</span></span><br><span class="line">        self.toggle_notification()</span><br><span class="line">        print(<span class="string">&#x27;stop notify&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify_any</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.notifying:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        send_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        send_dict[<span class="string">&#x27;voice&#x27;</span>] = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">        send_dict[<span class="string">&#x27;vision&#x27;</span>] = <span class="string">&#x27;face&#x27;</span></span><br><span class="line">        send_dict[<span class="string">&#x27;touch&#x27;</span>] = <span class="string">&#x27;head&#x27;</span></span><br><span class="line">        send_dict[<span class="string">&#x27;distance&#x27;</span>] = <span class="string">&#x27;199&#x27;</span></span><br><span class="line">        send_dict[<span class="string">&#x27;gyro&#x27;</span>] = <span class="string">&#x27;0-0&#x27;</span></span><br><span class="line"></span><br><span class="line">        data = json.dumps(send_dict)</span><br><span class="line">        print(<span class="string">&#x27;data : [&#123;&#125;]&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        value = []</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> data:</span><br><span class="line">            value.append(dbus.Byte(b.encode()))</span><br><span class="line"></span><br><span class="line">        self.PropertiesChanged(GATT_CHRC_IFACE, &#123;<span class="string">&#x27;Value&#x27;</span>: value&#125;, [])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_notify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        According the receive command to change the notify data.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.notify_any()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toggle_notification</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.notifying:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># each 1s notify one time.</span></span><br><span class="line">        GObject.timeout_add(<span class="number">1000</span>, self.do_notify)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCharacteristic</span>(<span class="params">Characteristic</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bus, index, service</span>):</span></span><br><span class="line">        Characteristic.__init__(self, bus, index, UART_SE_CHARACTERISTIC_UUID,</span><br><span class="line">                                [<span class="string">&#x27;read&#x27;</span>], service)</span><br><span class="line">        self.logger = ai.coloredlogging.get_logger(<span class="string">&quot;State&quot;</span>,</span><br><span class="line">                                                   ai.coloredlogging.RED)</span><br><span class="line">        self.logger.addHandler(logging.NullHandler())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReadValue</span>(<span class="params">self, options</span>):</span></span><br><span class="line">        v = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">        value = []</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> v:</span><br><span class="line">            value.append(dbus.Byte(b.encode()))</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UartService</span>(<span class="params">Service</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bus, index</span>):</span></span><br><span class="line">        Service.__init__(self, bus, index, UART_SERVICE_UUID, <span class="literal">True</span>)</span><br><span class="line">        self.add_characteristic(DemoCharacteristic(bus, <span class="number">0</span>, self))</span><br><span class="line">        self.add_characteristic(TestCharacteristic(bus, <span class="number">1</span>, self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>(<span class="params">dbus.service.Object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bus</span>):</span></span><br><span class="line">        self.path = <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        self.services = []</span><br><span class="line">        dbus.service.Object.__init__(self, bus, self.path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_path</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> dbus.ObjectPath(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_service</span>(<span class="params">self, service</span>):</span></span><br><span class="line">        self.services.append(service)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @dbus.service.method(<span class="params">DBUS_OM_IFACE, out_signature=<span class="string">&#x27;a&#123;oa&#123;sa&#123;sv&#125;&#125;&#125;&#x27;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetManagedObjects</span>(<span class="params">self</span>):</span></span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> service <span class="keyword">in</span> self.services:</span><br><span class="line">            response[service.get_path()] = service.get_properties()</span><br><span class="line">            chrcs = service.get_characteristics()</span><br><span class="line">            <span class="keyword">for</span> chrc <span class="keyword">in</span> chrcs:</span><br><span class="line">                response[chrc.get_path()] = chrc.get_properties()</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UartApplication</span>(<span class="params">Application</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bus</span>):</span></span><br><span class="line">        Application.__init__(self, bus)</span><br><span class="line">        self.add_service(UartService(bus, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UartAdvertisement</span>(<span class="params">Advertisement</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bus, index</span>):</span></span><br><span class="line">        Advertisement.__init__(self, bus, index, <span class="string">&#x27;peripheral&#x27;</span>)</span><br><span class="line">        self.add_service_uuid(UART_SERVICE_UUID)</span><br><span class="line">        self.add_local_name(ai.parameters.CAT_BLE_NAME)</span><br><span class="line">        self.include_tx_power = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_adapter</span>(<span class="params">bus</span>):</span></span><br><span class="line">    remote_om = dbus.Interface(bus.get_object(BLUEZ_SERVICE_NAME, <span class="string">&#x27;/&#x27;</span>),</span><br><span class="line">                               DBUS_OM_IFACE)</span><br><span class="line">    objects = remote_om.GetManagedObjects()</span><br><span class="line">    <span class="keyword">for</span> o, props <span class="keyword">in</span> objects.items():</span><br><span class="line">        <span class="keyword">if</span> LE_ADVERTISING_MANAGER_IFACE <span class="keyword">in</span> props <span class="keyword">and</span> GATT_MANAGER_IFACE <span class="keyword">in</span> props:</span><br><span class="line">            <span class="keyword">return</span> o</span><br><span class="line">        print(<span class="string">&#x27;Skip adapter:&#x27;</span>, o)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">global</span> mainloop</span><br><span class="line">    dbus.mainloop.glib.DBusGMainLoop(set_as_default=<span class="literal">True</span>)</span><br><span class="line">    bus = dbus.SystemBus()</span><br><span class="line">    adapter = find_adapter(bus)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> adapter:</span><br><span class="line">        print(<span class="string">&#x27;BLE adapter not found&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    service_manager = dbus.Interface(</span><br><span class="line">        bus.get_object(BLUEZ_SERVICE_NAME, adapter), GATT_MANAGER_IFACE)</span><br><span class="line">    ad_manager = dbus.Interface(bus.get_object(BLUEZ_SERVICE_NAME, adapter),</span><br><span class="line">                                LE_ADVERTISING_MANAGER_IFACE)</span><br><span class="line"></span><br><span class="line">    app = UartApplication(bus)</span><br><span class="line">    adv = UartAdvertisement(bus, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    mainloop = GLib.MainLoop()</span><br><span class="line"></span><br><span class="line">    service_manager.RegisterApplication(app.get_path(), &#123;&#125;,</span><br><span class="line">                                        reply_handler=register_app_cb,</span><br><span class="line">                                        error_handler=register_app_error_cb)</span><br><span class="line">    ad_manager.RegisterAdvertisement(adv.get_path(), &#123;&#125;,</span><br><span class="line">                                     reply_handler=register_ad_cb,</span><br><span class="line">                                     error_handler=register_ad_error_cb)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mainloop.run()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        adv.Release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>You can also find other usages from the demo. You can at <a href="https://github.com/zlj-zz/python-ble-gatt-server">here</a> find my project demo.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use tools to create mode in Flutter</title>
      <link href="2020/10/17/028-flutter-create-mode/"/>
      <url>2020/10/17/028-flutter-create-mode/</url>
      
        <content type="html"><![CDATA[<p>At Flutter app, sometime we need to create <code>class</code> for mode. Although it can be done manaually, it takes too much time. So we can use some tools to complete this.</p><p>We can use these tools. You can view more usafe methods on the <a href="pub.dev">officail website</a>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">json_annotation</span><br><span class="line">shared_preferences</span><br><span class="line">json_model</span><br><span class="line">build_runner</span><br><span class="line">json_serializable</span><br></pre></td></tr></table></figure><p>First, we should add these package to your <code>pubspec.yaml</code>, like below. Then run the <code>pub get</code> command in terminal to install them. At this point we have made preparations.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">flutter_localizations:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">json_annotation:</span> <span class="string">^2.0.0</span></span><br><span class="line">  <span class="attr">shared_preferences:</span> <span class="string">^0.5.10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">flutter_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">json_model:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">&quot;https://github.com/wbtvc/json_model.git&quot;</span></span><br><span class="line">  <span class="attr">build_runner:</span> <span class="string">^1.6.0</span></span><br><span class="line">  <span class="attr">json_serializable:</span> <span class="string">^3.0.0</span></span><br></pre></td></tr></table></figure><p>Then we can create <code>jsons</code> fold to save our mode json file. The following is a case of caching mode, we can create mulitple json files corresponding to multiple modes.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;enable&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否启用缓存</span></span><br><span class="line">  <span class="attr">&quot;maxAge&quot;</span>: <span class="number">1000</span>, <span class="comment">// 缓存的最长时间，单位（秒）</span></span><br><span class="line">  <span class="attr">&quot;maxCount&quot;</span>: <span class="number">100</span> <span class="comment">// 最大缓存数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The producted model file:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">cacheConfig.dart</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;cacheConfig.g.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line">    CacheConfig();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> enable;</span><br><span class="line">    <span class="built_in">num</span> maxAge;</span><br><span class="line">    <span class="built_in">num</span> maxCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">factory</span> CacheConfig.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">dynamic</span>&gt; json) =&gt; _$CacheConfigFromJson(json);</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$CacheConfigToJson(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">cacheConfig.g.dart</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> of <span class="string">&#x27;cacheConfig.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************************************************</span></span><br><span class="line"><span class="comment">// JsonSerializableGenerator</span></span><br><span class="line"><span class="comment">// **************************************************************************</span></span><br><span class="line"></span><br><span class="line">CacheConfig _$CacheConfigFromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) &#123;</span><br><span class="line">  <span class="keyword">return</span> CacheConfig()</span><br><span class="line">    ..enable = json[<span class="string">&#x27;enable&#x27;</span>] <span class="keyword">as</span> <span class="built_in">bool</span></span><br><span class="line">    ..maxAge = json[<span class="string">&#x27;maxAge&#x27;</span>] <span class="keyword">as</span> <span class="built_in">num</span></span><br><span class="line">    ..maxCount = json[<span class="string">&#x27;maxCount&#x27;</span>] <span class="keyword">as</span> <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; _$CacheConfigToJson(CacheConfig instance) =&gt;</span><br><span class="line">    &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">&#x27;enable&#x27;</span>: instance.enable,</span><br><span class="line">      <span class="string">&#x27;maxAge&#x27;</span>: instance.maxAge,</span><br><span class="line">      <span class="string">&#x27;maxCount&#x27;</span>: instance.maxCount,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>Next we just should use <code>flutter packages pub run json_model</code> in terminal and wait a minute, we can see the mode file be producted in <code>lib/models</code>. We just include the fold's <code>index.dart</code> to use our mode.</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何流畅丝滑的使用git</title>
      <link href="2020/09/07/027-how-to-use-GIT/"/>
      <url>2020/09/07/027-how-to-use-GIT/</url>
      
        <content type="html"><![CDATA[<h1 id="git-使用">git 使用</h1><h2 id="basic">basic</h2><p><kbd>git init</kbd> 可以将一个文件夹初始化为一个 git 目录，会生成一个<code>.git</code>的隐藏目录。</p><p><kbd>git remote add &lt;remote&gt; &lt;branch&gt; &lt;url&gt;</kbd> 可以帮助我们连接到一个远程的仓库。</p><p><kbd>git clone [-b branch-name] &lt;url&gt; </kbd> 可以克隆一个远程仓库到本地，<code>-b</code>参数可以指定分支。</p><h2 id="view">view</h2><p><kbd>git status</kbd>查看工作树状态。</p><blockquote><p><code>-u</code>参数用来添加被追踪的文件，即新建文件不会被添加。</p></blockquote><p><kbd>git diff &lt;file&gt;</kbd>查看文件的改变。</p><p><kbd>git log</kbd> 查看<strong>commit</strong>提交信息日志。</p><blockquote><p><code>-graph</code>以图的形式显示。 <code>-all</code>查看全部分支。 <code>-oneline</code>条件信息只显示一行。</p></blockquote><h2 id="change">change</h2><p><kbd>git add &lt;file&gt;</kbd>可以添加文件的变化到暂存区，可以用<code>.</code>表示添加所有变化。</p><p><kbd>git commit</kbd>用来提交文件，回车后自动打开编辑器让你编辑提交信息。</p><blockquote><p>可以通过<code>-m &lt;msg&gt;</code>在命令行添加提交信息。 通过<code>-amend</code> 参数将本次提交添加到上一次提交中，加上<code>--no-edit</code>参数可以不同编辑提交信息。</p></blockquote><p><kbd>git push</kbd>将本地分支推送到远程，<code>-f</code>参数可以强制推送。</p><p><kbd>git fetch</kbd>将远程最新的内容拉到本地。</p><p><kbd>git fetch &lt;remote&gt; &lt;remotebranch&gt;:&lt;localebranch&gt; </kbd>将远程最新的内容拉到本地。</p><p><kbd>git merge [branch-name]</kbd>合并分支，默认合并远程分支；可以将指定分支合并到当前分支。</p><p><kbd>git pull</kbd>等于<code>git fetch</code>+<code>git merge</code></p><h2 id="option">option</h2><p><kbd>git branch [branch-name]</kbd>查看分支或者创建新分支。</p><p><kbd>git checkout</kbd>切换分支。</p><p><kbd>git checkout &lt;branch-name&gt; &lt;path-name&gt; [file-name]</kbd>合并分支制定文件</p><blockquote><p>使用<code>-b</code>参数创建并切换分支。 合并冲突时，<code>--ours|--theirs [file]</code>选择使用哪个分支。</p></blockquote><p><kbd>git stash</kbd> Can hide your uncommitted changes.</p><p><kbd>git stash pop</kbd> Can restore your hidden changes.</p><p><kbd>git reset</kbd> 复位操作，可以用于<code>add</code>, <code>commit</code></p><blockquote><p><code>git reset HEAD [file]</code> 撤销添加操作。 <code>git reset \&lt;HEAD~n|版本号\&gt;</code> 退回上 n 个版本或指定版本 <code>--hard</code> 清楚工作区 <code>--merged</code> 回滚时不清楚不要的版本工作区 <code>--soft</code> 仅撤回提交，工作区内容不变 <code>--keep</code> 清楚提交，保持工作区不变</p></blockquote><hr /><h1 id="git-设置">git 设置</h1><p>使用<code>HTTP</code>协议时，可以使用<kbd>git config credential.helper store</kbd>来记住用户名和密码。</p><p>可以使用<kbd>git config --global core.editor /usr/bin/vim</kbd>指定提交信息的编辑器。</p><hr /><h1 id="git-commit-信息规范">git commit 信息规范</h1><h3 id="why">why</h3><ol type="1"><li>提供更多的历史信息，方便快速浏览。</li><li>可以过滤某些 commit（比如文档改动），便于快速查找信息。</li><li>可以直接从 commit 生成 Change log。</li></ol><h3 id="angularjs-规范">AngularJS 规范</h3><blockquote><p>它是由 Google 推出的一套提交消息规范标准，也是目前使 用范围最广的规范。有一套合理的手册也较为系统化；并且还有配套的工具可以供我们使用。</p></blockquote><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMzI4NTk5LzIwMTkwMS8zMjg1OTktMjAxOTAxMjMxMDQxMDExNjAtODQ1MzY4MTYwLnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h5 id="格式">格式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><h5 id="要求">要求</h5><ul><li>消息只占用一行，任何行都不能超过 100 个字符</li><li>允许使用 GitHub 以及各种 Git 工具阅读消息</li><li>提交消息由页眉、正文和页脚组成，由空行分隔</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 悬浮弹出效果</title>
      <link href="2020/08/06/026-flutter-suspension-frame-effect/"/>
      <url>2020/08/06/026-flutter-suspension-frame-effect/</url>
      
        <content type="html"><![CDATA[<p>最近在 Flutter 的使用中需要做一个悬浮弹窗的效果。通过查阅资料了解 <code>Overlay</code> 可以做出悬浮框的效果，但没有弹出效果，不符合我的预期。后来发现其实并不一定要真的悬浮，通过 <code>showModalBouttonSheet</code>方法和 <code>Stack</code>组件，可以模拟出这样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future <span class="title">_createSelectViewWithContext</span><span class="params">()</span> async </span>&#123;</span><br><span class="line">  <span class="comment">//屏幕宽高</span></span><br><span class="line">  RenderBox renderBox = context.findRenderObject();</span><br><span class="line">  <span class="keyword">var</span> screenSize = renderBox.size;</span><br><span class="line">  <span class="keyword">final</span> option = <span class="function">await <span class="title">showModalBottomSheet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      context: context,</span></span></span><br><span class="line"><span class="function"><span class="params">      builder: (BuildContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StatefulBuilder(builder: (context, state) &#123;</span><br><span class="line">          <span class="keyword">return</span> Stack(</span><br><span class="line">              alignment: AlignmentDirectional.topCenter,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Container(</span><br><span class="line">                  color: Colors.black54,</span><br><span class="line">                  height: screenSize.height * <span class="number">0.37</span>,</span><br><span class="line">                  width: <span class="keyword">double</span>.infinity,</span><br><span class="line">                ),</span><br><span class="line">                Container(</span><br><span class="line">                  height: screenSize.height * <span class="number">0.35</span>,</span><br><span class="line">                  width: screenSize.width * <span class="number">0.95</span>,</span><br><span class="line">                  decoration: BoxDecoration(</span><br><span class="line">                      color: Colors.white,</span><br><span class="line">                      borderRadius: BorderRadius.all(Radius.circular(<span class="number">20.0</span>))),</span><br><span class="line">                  child: Column(</span><br><span class="line">                    children: &lt;Widget&gt;[</span><br><span class="line">                      Text(</span><br><span class="line">                        <span class="string">&#x27;This is a title&#x27;</span>,</span><br><span class="line">                        style: TextStyle(color: Colors.grey, fontSize: <span class="number">25</span>),</span><br><span class="line">                      ),</span><br><span class="line">                      Divider(),</span><br><span class="line">                      Expanded(</span><br><span class="line">                          child: ListView(</span><br><span class="line">                        children: &lt;Widget&gt;[</span><br><span class="line">                          ListTile(</span><br><span class="line">                            leading: Icon(Icons.home),</span><br><span class="line">                            title: Text(<span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">                            trailing: RaisedButton(</span><br><span class="line">                                onPressed: () &#123;&#125;,</span><br><span class="line">                                color: Colors.blue,</span><br><span class="line">                                shape: RoundedRectangleBorder(</span><br><span class="line">                                    borderRadius: BorderRadius.circular(<span class="number">20</span>)),</span><br><span class="line">                                child: Text(<span class="string">&#x27;botton&#x27;</span>)),</span><br><span class="line">                          ),</span><br><span class="line">                          ListTile(</span><br><span class="line">                            leading: Icon(Icons.hotel),</span><br><span class="line">                            title: Text(<span class="string">&#x27;hotel&#x27;</span>),</span><br><span class="line">                            trailing: RaisedButton(</span><br><span class="line">                                onPressed: () &#123;&#125;,</span><br><span class="line">                                color: Colors.blue,</span><br><span class="line">                                shape: RoundedRectangleBorder(</span><br><span class="line">                                    borderRadius: BorderRadius.circular(<span class="number">20</span>)),</span><br><span class="line">                                child: Text(<span class="string">&#x27;botton&#x27;</span>)),</span><br><span class="line">                          ),</span><br><span class="line">                        ],</span><br><span class="line">                      ))</span><br><span class="line">                    ],</span><br><span class="line">                  ),</span><br><span class="line">                )</span><br><span class="line">              ]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20200806162244613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python面试基础知识问题</title>
      <link href="2020/06/30/025-python-interview-questions/"/>
      <url>2020/06/30/025-python-interview-questions/</url>
      
        <content type="html"><![CDATA[<h1 id="简述函数式编程">1.简述函数式编程</h1><p><strong>函数</strong> 　　函数是 Python 内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p><p><strong>函数式编程（Functional Programming）</strong> 　　函数式编程是一种抽象程度很高的编程范式。纯粹的函数式编程语言编写的函数没有变量的，因此任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用的。而非纯粹的函数（允许使用变量的），由于函数内部的变量状态不确定，同样的输入，有可能得到不同的输出，因此，这种函数是有副作用的。</p><p><strong>函数式编程的特点</strong>：允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p><p><em>Python 对函数式编程提供部分的支持，由于 Python 允许使用变量，所以 Python 不是纯函数式编程语言。</em></p><h1 id="什么是匿名函数有什么局限性">2.什么是匿名函数，有什么局限性</h1><p>匿名函数就是不需要显示的定义函数，即不需要函数名。在 Python 中可以通过 <code>lambda</code> 关键字来定义匿名函数。</p><p>因为函数没有名字，不必担心函数名冲突。与 <code>map()</code>、<code>reduce()</code>、<code>filter()</code>结合使用可以使代码更加 pythoner。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。也可以把匿名函数作为返回值返回。</p><p>匿名函数也存在限制，就是只能有一个表达式，不用写 <code>return</code>，返回值就是该表达式的结果。其代码的可读性也比较差差，有时会难于理解。</p><h1 id="如何捕获异常常用的异常机制有哪些">3.如何捕获异常，常用的异常机制有哪些？</h1><p>Python 捕捉异常可以使用 <code>try/except</code> 语句。</p><p><code>try/except</code> 语句用来检测 <code>try</code> 语句块中的错误，从而让 <code>except</code> 语句捕获异常信息并处理。</p><p>如果你不想在异常发生时结束你的程序，只需在 <code>try</code> 里捕获它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果在try部份引发了&#x27;name&#x27;异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#退出 try 会执行</span></span><br></pre></td></tr></table></figure><p><code>else</code> 和 <code>finally</code> 不是必须的。</p><h3 id="常用的异常机制">常用的异常机制</h3><p><strong>默认处理机制</strong></p><p>如果我们没有对异常进行任何预防，那么在程序执行的过程中发生异常，就会中断程序，调用 Python 默认的异常处理器，并在终端输出异常信息。</p><p><strong>try…except</strong></p><p>发现 <code>try</code> 语句，进入 <code>try</code> 语句块执行，发生异常，回到 <code>try</code> 语句层，寻找后面是否有 <code>except</code> 语句。找到 <code>except</code> 语句后，会调用这个自定义的异常处理器。<code>except</code> 将异常处理完毕后，程序继续往下执行。</p><p><strong>try…finally</strong></p><p><code>finally</code> 语句表示，无论异常发生与否，<code>finally</code> 中的语句都要执行。但是，由于没有 <code>except</code> 处理器，<code>finally</code> 执行完毕后程序便中断。</p><p><strong>assert</strong></p><p>遇到 <code>assert</code> 后面紧跟的语句是 <strong>True</strong> 还是 <strong>False</strong> ，如果是 <strong>True</strong> 则继续执行，如果是 <strong>False</strong> 则中断程序，调用默认的异常处理器，同时输出 <code>assert</code> 语句逗号后面的提示信息。</p><p><strong>with…as</strong></p><p>处理流对象时，<code>with…as</code> 语句十分的非常方便。<code>with</code> 语句块完毕之后，会隐藏地自动关闭流。</p><p>如果 <code>with</code> 语句或语句块中发生异常，会调用默认的异常处理器处理，但流还是会正常关闭。</p><h1 id="copy_-和-deepcopy-的区别">4._copy()_ 和 <em>deepcopy()</em> 的区别</h1><p><code>copy()</code> 对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，python 会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。</p><p><code>deepcopy()</code> 的时候会将复杂对象的每一层复制一个单独的个体出来。</p><h1 id="简述-python-的作用域以及-python-搜索变量的顺序">5.简述 Python 的作用域以及 Python 搜索变量的顺序</h1><p>作用域又可以被称为命名空间，指变量起作用的范围。Python 变量作用域可以分为四种，分别为<strong>局部作用域(local)</strong>、<strong>嵌套作用域(enclosed)</strong>、<strong>全局作用域(global)</strong>、<strong>内置作用域(built-in)</strong>。</p><p>四种作用域中变量的调用顺序采取“就近原则”，即为 <strong>LEGB</strong>。</p><p>局部作用域指某个函数内部的范围。</p><p>嵌套一般是指一个函数嵌套另一个函数的情况，外层函数包含变量的作用范围称为嵌套作用域；也可以指一个类中包含多个函数时的情况。</p><p>全局作用域范围指的是在一个.py 文件内部，在模块顶部声明即可成为全局作用域。 全局作用域中的变量在函数中一般是不可更改的，例如整数，字符等，但对于列表和字典来说可以更改。如想引用并改变全局变量，可使用 global 关键字。</p><p>内置作用域是 python 事先定义的内置模块，例如 built-in 模块内的变量，程序启动之后由 python 虚拟机自动加载，在程序的任何地方都可以使用，例如<code>print</code>函数，随着解释器存在或消亡。</p><h1 id="新式类和旧式类的区别如何确保使用的是新式类">6.新式类和旧式类的区别，如何确保使用的是新式类</h1><p>python 的新式类是 2.2 版本引进来的，我们可以将之前的类叫做经典类或者旧式类。新式类的引入是为了统一类（class）和类型（type）。</p><p>新式类都从 <code>object</code> 继承，经典类不需要。新式类的 MRO(method resolution order 基类搜索顺序)算法采用 C3 算法广度优先搜索，而旧式类的 MRO 算法是采用深度优先搜索</p><p>新式类相同父类只执行一次构造函数，经典类重复执行多次。</p><p>python3.x 中取消了经典类。</p><h1 id="简述-__new__-和-__init__-的区别">7.简述 <code>__new__</code> 和 <code>__init__</code> 的区别</h1><p><code>__new__</code> 是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。 <code>__init__</code> 是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。</p><p>也就是： <code>__new__</code> 先被调用，<code>__init__</code> 后被调用，<code>__new__</code> 的返回值（实例）将传递给<code>__init__</code> 方法的第一个参数，然后 <code>__init__</code> 给这个实例设置一些参数。</p><h1 id="python-垃圾回收机制">8.Python 垃圾回收机制</h1><p><strong>引用计数器</strong></p><p>在 Python 的 C 源码中有一个名为 <code>refchain</code> 的环状双向链表，Python 程序中一旦创建对象都会把这个对象添加到 <code>refchain</code> 这个链表中。它保存着所有的对象。</p><p>在 <code>refchain</code> 中的所有对象内部都有一个 <code>ob_refcnt</code> 用来保存当前对象的引用计数器，当值被多次引用时候，不会在内存中重复创建数据，而是引用计数器 <code>+1</code> 。 当对象被销毁时候同时会让引用计数器 <code>-1</code>,如果引用计数器为 <code>0</code>，则将对象从 <code>refchain</code> 链表中摘除，同时在内存中进行销毁（暂不考虑缓存等特殊情况）。</p><p><strong>标记清楚和分代回收</strong></p><p>基于引用计数器进行垃圾回收非常方便和简单，但是存在循环引用的问题，导致无法正常的回收一些数据。</p><p>为了解决循环引用的问题，引入了标记清除技术，专门针对那些可能存在循环引用的对象进行特殊处理，可能存在循环应用的类型有：列表、元组、字典、集合、自定义类等那些能进行数据嵌套的类型。</p><p><em>标记清除</em>：创建特殊链表专门用于保存 列表、元组、字典、集合、自定义类等对象，之后再去检查这个链表中的对象是否存在循环引用，如果存在则让双方的引用计数器均 <code>- 1</code> 。</p><p><em>分代回收</em>：对标记清除中的链表进行优化，将那些可能存在循引用的对象拆分到 3 个链表，链表称为：<code>0/1/2</code> 三代，每代都可以存储对象和阈值，当达到阈值时，就会对相应的链表中的每个对象做一次扫描，除循环引用各自减 1 并且销毁引用计数器为 <code>0</code> 的对象。</p><blockquote><p>特别注意：0 代和 1、2 代的 threshold 和 count 表示的意义不同。其中源码中 0/1/2 代默认的大小分别为 700、10、10 0 代，count 表示 0 代链表中对象的数量，threshold 表示 0 代链表对象个数阈值，超过则执行一次 0 代扫描检查。 1 代，count 表示 0 代链表扫描的次数，threshold 表示 0 代链表扫描的次数阈值，超过则执行一次 1 代扫描检查。 2 代，count 表示 1 代链表扫描的次数，threshold 表示 1 代链表扫描的次数阈值，超过则执行一 2 代扫描检查。</p></blockquote><p>当 0 代大于阈值后，底层不是直接扫描 0 代，而是先判断 2、1 是否也超过了阈值。</p><ul><li>如果 2、1 代未达到阈值，则扫描 0 代，并让 1 代的 count + 1 。</li><li>如果 2 代已达到阈值，则将 2、1、0 三个链表拼接起来进行全扫描，并将 2、1、0 代的 count 重置为 0.</li><li>如果 1 代已达到阈值，则讲 1、0 两个链表拼接起来进行扫描，并将所有 1、0 代的 count 重置为 0.</li></ul><p>对拼接起来的链表在进行扫描时，主要就是剔除循环引用和销毁垃圾，详细过程为：</p><ul><li>扫描链表，把每个对象的引用计数器拷贝一份并保存到 <code>gc_refs</code> 中，保护原引用计数器。</li><li>再次扫描链表中的每个对象，并检查是否存在循环引用，如果存在则让各自的 <code>gc_refs</code> 减 1 。</li><li>再次扫描链表，将 <code>gc_refs</code> 为 <code>0</code> 的对象移动到 <code>unreachable</code> 链表中；不为 <code>0</code> 的对象直接升级到下一代链表中。</li><li>处理 unreachable 链表中的对象的 析构函数 和 弱引用，不能被销毁的对象升级到下一代链表，能销毁的保留在此链表。<ul><li>析构函数，指的就是那些定义了 <code>__del__</code> 方法的对象，需要执行之后再进行销毁处理。</li><li>弱引用，</li></ul></li><li>最后将 unreachable 中的每个对象销毁并在 refchain 链表中移除（不考虑缓存机制）。</li></ul><p>至此，垃圾回收的过程结束。</p><p><strong>缓存机制</strong></p><p>实际上反复的创建和销毁会使程序的执行效率变低。Python 中引入了“缓存机制”机制。</p><p>例如：引用计数器为 <code>0</code> 时，不会真正销毁对象，而是将他放到一个名为 <code>free_list</code> 的链表中，之后会再创建对象时不会在重新开辟内存，而是在 <code>free_list</code> 中将之前的对象来并重置内部的值来使用。</p><blockquote><p><strong>float 类型</strong>，维护的 <code>free_list</code> 链表最多可缓存 100 个 float 对象。 <strong>int 类型</strong>，不是基于 <code>free_list</code>，而是维护一个 <code>small_ints</code> 链表保存常见数据（小数据池），小数据池范围：<code>-5 &lt;= value &lt; 257</code>。即：重复使用这个范围的整数时，不会重新开辟内存。 <strong>str 类型</strong>，维护 <code>unicode_latin1[256]</code> 链表，内部将所有的 ascii 字符缓存起来，以后使用时就不再反复创建。 <strong>list 类型</strong>，维护的 <code>free_list</code> 数组最多可缓存 80 个 list 对象。 <strong>tuple 类型</strong>，维护一个 <code>free_list</code> 数组且数组容量 20，数组中元素可以是链表且每个链表最多可以容纳 2000 个元组对象。元组的 free_list 数组在存储数据时，是按照元组可以容纳的个数为索引找到 free_list 数组中对应的链表，并添加到链表中。 <strong>dict 类型</strong>，维护的 <code>free_list</code> 数组最多可缓存 80 个 dict 对象。</p></blockquote><h1 id="python-中的-_property_-有什么作用如何实现成员变量的只读属性">9.Python 中的 _<span class="citation" data-cites="property_">@property_</span> 有什么作用？如何实现成员变量的只读属性？</h1><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数。</p><p>Python 内置的 <code>@property</code> 装饰器就是负责把一个方法变成属性调用的。<code>@property</code> 本身又创建了另一个装饰器 <code>@score.setter</code>，负责把一个 <strong>setter</strong> 方法变成属性赋值。只定义 <strong>getter</strong> 方法，不定义 <strong>setter</strong> 方法就是一个只读属性。</p><h1 id="有用过-with-statement-吗它的好处是什么具体如何实现的">10.有用过 <em>with statement</em> 吗？它的好处是什么？具体如何实现的？</h1><p>with 语句的作用是通过某种方式简化异常处理，它是所谓的上下文管理器的一种，<code>with</code> 语句会在嵌套的代码执行之后，自动关闭文件。</p><h1 id="python-的数据结构有哪些">11.Python 的数据结构有哪些？</h1><p>Python 中的内置数据结构（Built-in Data Structure）:列表 list、元组 tuple、字典 dict、集合 set，涵盖的仅有部分重点。</p><p><strong>list：</strong></p><ul><li>列表中的每个元素都可变的，意味着可以对每个元素进行修改和删除；</li><li>列表是有序的，每个元素的位置是确定的，可以用索引去访问每个元素；</li><li>列表中的元素可以是 Python 中的任何对象；</li><li>可以为任意对象就意味着元素可以是字符串、整数、元组、也可以是 list 等 Python 中的对象。</li></ul><p><strong>tuple</strong></p><ul><li>用法与 List 类似，但 Tuple 一经初始化，就不能修改，只能对元素进行查询</li></ul><p><strong>dict：</strong></p><ul><li>字典中的数据必须以键值对的形式出现，即 k,v： key:必须是可哈希的值，value:任何值</li><li>键不可重复，值可重复，键若重复字典中只会记该键对应的最后一个值</li><li>字典中键(key)是不可变的，何为不可变对象，不能进行修改；而值(value)是可以修改的，可以是任何对象。</li><li>在 dict 中是根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了</li></ul><p><strong>set</strong></p><ul><li>集合更接近数学上集合的概念。集合中每个元素都是无序的、不重复的任意对象。</li><li>可以通过集合去判断数据的从属关系，也可以通过集合把数据结构中重复的元素减掉。集合可做集合运算，可添加和删除元素。</li><li>集合内数据无序，即无法使用索引和分片</li><li>集合内部数据元素具有唯一性，可以用来排除重复数据</li><li>集合内的数据:str,int,float,tuple,冰冻集合等，即内部只能放置可哈希数据</li></ul><h1 id="python-中列表和元组的区别元组是否真的不可变">12.Python 中列表和元组的区别？元组是否真的不可变？</h1><ol type="1"><li>列表是动态数组，它们不可变且可以重设长度（改变其内部元素的个数）。</li><li>元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。</li><li>元组缓存于 Python 运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存。</li></ol><p>元组不可变是指当前变量存放的元素不可变，存放的元素可以是数字、字符、列表、元组、字典；如果你定义的元组最外层变量里面包含可变类型元素，那么这个元组是可变的。</p><h1 id="什么是生成器和迭代器它们的区别是什么">13.什么是生成器和迭代器？它们的区别是什么？</h1><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：iter() 和 next()。字符串，列表或元组对象都可用于创建迭代器。把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code>。</p><hr /><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><h1 id="什么是闭包装饰器又是什么装饰器的作用">14.什么是闭包？装饰器又是什么？装饰器的作用？</h1><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p><p>函数可以作为另一个函数的参数或返回值，可以赋给一个变量。函数可 以嵌套定义，即在一个函数内部可以定义另一个函数，有了嵌套函数这种结构，便会产生闭包问题。</p><p>在函数式语言中，当内嵌函数体内引用到体外的变量时，将会把定义时涉及到的引用环境和函数体打包成一个整体（闭包）返回。</p><hr /><p>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。</p><p>装饰器这一语法体现了 Python 中函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，非常的灵活与强大。</p><h1 id="什么是类什么是继承">15.什么是类？什么是继承？</h1><p><strong>类(Class)</strong>: 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p><p><strong>继承:</strong> 所表达的是类之间的相关关系,这种关系使得子类可以继承父类特征和行为，使得复用以前的代码非常容易,能够大大缩短开发周期,降低开发费用。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How to use Pacman ?</title>
      <link href="2020/06/28/024-how-to-use-PACMAN/"/>
      <url>2020/06/28/024-how-to-use-PACMAN/</url>
      
        <content type="html"><![CDATA[<h3 id="s-命令">S 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo pacman -S git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">sudo pacman -Syy</span><br><span class="line">sudo pacman -Syyu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">sudo pacman -Ss git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除旧安装包</span></span><br><span class="line">sudo pacman -Sc</span><br></pre></td></tr></table></figure><h3 id="r-命令">R 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">sudo pacma -R git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连同依赖的卸载</span></span><br><span class="line">sudo pacman -Rs git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连同系统配置文件卸载</span></span><br><span class="line">sudo pacman -Rns git</span><br></pre></td></tr></table></figure><h3 id="q-命令">Q 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出已安装软件</span></span><br><span class="line">pacman -Q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计个数</span></span><br><span class="line">pacman -Q | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出你安装的软件</span></span><br><span class="line">pacman -Qe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示名字不带版本号等</span></span><br><span class="line">pacman -Qq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示不需要的依赖</span></span><br><span class="line">pacman -Qdt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索本地仓库</span></span><br><span class="line">pacman -Qs</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编写高质量 Python 代码的 47 个建议</title>
      <link href="2020/06/14/022-python-code-suggestions/"/>
      <url>2020/06/14/022-python-code-suggestions/</url>
      
        <content type="html"><![CDATA[<p>我在这里总结归纳了 47 个有关 Python 代码的建议，试图去帮助你编写高质量的 Pyhon 代码。希望你能从中得到一定的收获。</p><a id="more"></a><h4 id="建议-1放弃自己的代码风格">建议 1：放弃自己的代码风格</h4><p>也许规范的书写看上去千篇一律，没有自己风格的代码没有特色。但是这样做可以帮助你规范你的代码，让它更加漂亮易读。</p><h4 id="建议-2代码中添加适当的注释">建议 2：代码中添加适当的注释</h4><p>更新代码的同时别忘记更新注释。</p><h4 id="建议-3适当的添加空行">建议 3：适当的添加空行</h4><p>布局清晰、整洁、优雅的代码能够给阅读它的人带来愉悦感，而且它能帮助开发者之间进行良好的沟通。</p><h4 id="建议-4编写函数的-4-个建议">建议 4：编写函数的 4 个建议</h4><ul><li>原则 1 函数设计要尽量短小，嵌套层次不宜过深。</li><li>原则 2 函数申明应该做到合理、简单、易于使用。</li><li>原则 3 　函数参数设计应该考虑向下兼容。</li><li>原则 4 一个函数只做一件事，尽量保证函数语句粒度的一致性。</li></ul><h4 id="建议-5常量集中在一起">建议 5：常量集中在一起</h4><p>将自己定义的常量使用<strong>全大写</strong>的命名，并将它们定义在一个文件中，这样更加方便使用和有利于维护。</p><h4 id="建议-6利用-assert-语句发现问题">建议 6：利用 <code>assert</code> 语句发现问题</h4><p>断言（assert）在很多语言中都存在，它主要为调试程序服务，能够快速方便地检查程序的异常或者发现不恰当的输入等，可防止意想不到的情况出现。</p><h4 id="建议-7直接交换数据">建议 7：直接交换数据</h4><p>当我们需要交换两个变量的值时，不推荐使用中间变量，这样更简洁且效率更高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><h4 id="建议-8不推荐使用-tpye-来检查类型">建议 8：不推荐使用 <code>tpye</code> 来检查类型</h4><p><strong>基于内建类型扩展的用户自定义类型，<code>type</code> 函数并不能准确返回结果</strong>。因此更加推荐使用 <code>isintance</code>。</p><h4 id="建议-9除法时尽量转为浮点类型">建议 9：除法时尽量转为浮点类型</h4><p>标准的算术运算，包括除法，返回值总是和操作数类型相同。当你编写一个函数时，即使你希望调用者传入的是浮点类型，但如果不在函数入口进行类型检查或者转换，就无法阻止函数调用者传递整数参数，而往往这种类型的错误还不容易发觉。因此推荐的做法之一是当涉及除法运算的时候尽量先将操作数转换为浮点类型再做运算。</p><h4 id="建议-10尽量少的使用-eval">建议 10：尽量少的使用 <code>eval</code></h4><p>Python 中 eval()函数将字符串 str 当成有效的表达式来求值并返回计算结果。实际应用过程中如果使用对象不是信任源，应该尽量避免使用 eval，在需要使用 eval 的地方可用安全性更好的 ast.literal_eval 替代。</p><h4 id="建议-11使用-enumerate获取序列迭代的索引和值">建议 11：使用 enumerate()获取序列迭代的索引和值</h4><p>它代码清晰简洁，可读性好。它具有一定的惰性（lazy），每次仅在需要的时候才会产生一个(index,item)对。</p><p><code>enumerate()</code> 函数的内部实现非常简单，<code>enumerate(sequence,start=0)</code> 实际相当于如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span>(<span class="params">sequence, start=<span class="number">0</span></span>):</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此利用这个特性用户还可以实现自己的 <code>enumerate()</code> 函数。比如，<code>myenumerate()</code> 以反序的方式获取序列的索引和值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myenumerate</span>(<span class="params">sequence</span>):</span></span><br><span class="line">    n = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> <span class="built_in">reversed</span>(sequence):</span><br><span class="line">        <span class="keyword">yield</span> <span class="built_in">len</span>(sequence) + n, elem</span><br><span class="line">        n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="建议-12区分-与-is">建议 12：区分 <code>==</code> 与 <code>is</code></h4><p><code>is</code> 的作用是用来检查对象的标示符是否一致的，也就是比较两个对象在内存中是否拥有同一块内存空间，它并不适合用来判断两个字符串是否相等。而 <code>==</code> 才是用来检验两个对象的值是否相等的，它实际调用内部<code>__eq__()</code> 方法。所以 <code>==</code> 操作符是可以被重载的，而 <code>is</code> 不能被重载。</p><h4 id="建议-13考虑兼容性尽量使用-unicode">建议 13：考虑兼容性，尽量使用 <code>Unicode</code></h4><h4 id="建议-14少的使用-form-...-import">建议 14：少的使用 <code>form ... import</code></h4><ul><li><p>一般情况下尽量优先使用 <code>import a</code> 形式，如访问 <code>B</code> 时需要使用 <code>a.B</code> 的形式。</p></li><li><p>有节制地使用 <code>from a import B</code> 形式，可以直接访问 <code>B</code>。</p></li><li><p>尽量避免使用 <code>from a import *</code>，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。</p></li></ul><p>更详细的说明：<a href="https://blog.csdn.net/qq_38410494/article/details/106679049">https://blog.csdn.net/qq_38410494/article/details/106679049</a></p><h4 id="建议-15i-1-不等于-i">建议 15：<code>i += 1</code> 不等于 <code>++i</code></h4><p>我们都知道 Python 中不支持自加和自减操作，但是 <code>++i</code>，<code>--i</code> 这样的操作并不是错误的，这里的 <code>+</code> 和 <code>-</code> 代表的只是正负符号。因此你需要明白 <code>++i</code> 在 Python 中语法上是合法的，但并不是我们理解的通常意义上的自增操作。</p><h4 id="建议-16使用-with-自动关闭资源">建议 16：使用 <code>with</code> 自动关闭资源</h4><h4 id="建议-17多使用-else-子句简化循环">建议 17：多使用 <code>else</code> 子句简化循环</h4><p>看一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_prime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i)</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            print(<span class="string">&quot;&#123;i&#125; is a prime number&quot;</span>.<span class="built_in">format</span>(i))</span><br></pre></td></tr></table></figure><p>这是一个查找素数的简单实现，可以看到我们借助了一个标志量 <code>found</code> 来判断是循环结束是不是由 <code>break</code> 语句引起的。如果对 <code>else</code> 善加利用，代码可以简洁得多。来看下面的具体实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_prime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i)</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;&#123;i&#125; is a prime number&quot;</span>.<span class="built_in">format</span>(i))</span><br></pre></td></tr></table></figure><p>当循环“自然”终结（循环条件为假）时 <code>else</code> 从句会被执行一次，而当循环是由 <code>break</code> 语句中断时，<code>else</code> 子句就不被执行。与 <code>for</code> 语句相似，<code>while</code> 语句中的 <code>else</code> 子句的语意是一样的：<code>else</code> 块在循环正常结束和循环条件不成立时被执行。</p><h4 id="建议-18异常处理的基本原则">建议 18：异常处理的基本原则</h4><ul><li>注意异常的粒度，不推荐在 try 中放入过多的代码。</li><li>谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。</li><li>注意异常捕获的顺序，在合适的层次处理异常。</li><li>使用更为友好的异常信息，遵守异常参数的规范。</li><li>如果内建异常类不能满足需求，用户可以在继承内建异常的基础上针对特定的业务逻辑定义自己的异常类。</li></ul><h4 id="建议-19拼接字符串推荐-join">建议 19：拼接字符串推荐 <code>join</code></h4><p>字符串处理在大多时候会常常遇到，在 Python 中我们可以使用 <code>join</code> 和 <code>+</code> 两种常见的方式来拼接字符串，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1, str2, str3 = <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;fg&quot;</span></span><br><span class="line"></span><br><span class="line">str4 = str1 + str2 + str3</span><br><span class="line">str5 = <span class="string">&#x27;&#x27;</span>.join([str1, str2, str3])</span><br></pre></td></tr></table></figure><p>如果进行过测试，就会发现，<code>join</code> 的速度是要高于 <code>+</code> 操作的，特别当拼接的字符串越多的时候。那么为什么呢？</p><p>这就关系到两个操作在内存中具体是怎么实现的。假设现在有 <code>s1, s2, s3, ..., sn</code> 个字符串，我们现在要拼接它们。如果使用 <code>+</code> 操作时，每遇到一次 <code>+</code> 号就会申请内存并将字符串复制到新的内存中，那么我们要拼接 n 个字符串时，就需要申请 n-1 次内存，当 n 越大时，效率会越低。</p><p>而当用 <code>join()</code> 方法连接字符串的时候，会首先计算需要申请的总的内存空间，然后一次性申请所需内存并将字符序列中的每一个元素复制到内存中去。因此，字符串的连接，特别是大规模字符串的处理，应该尽量优先使用 join 而不是+。</p><h4 id="建议-20格式化字符串使用-.format">建议 20：格式化字符串使用 <code>.format</code></h4><p>Python 中内置的 <code>%</code> 操作符和 <code>.format</code> 方式都可用于格式化字符串。</p><ul><li>理由一：format 方式在使用上较%操作符更为灵活。使用 format 方式时，参数的顺序与格式化的顺序不必完全相同。</li><li>理由二：format 方式可以方便地作为参数传递。</li><li>理由三：%方法在某些特殊情况下使用时需要特别小心。</li></ul><p>如果你使用的 Python 是 3.8 以上，还可使用<code>f&#123;&#125;</code> 字符串。具体可以看这里：<a href="https://blog.csdn.net/qq_38410494/article/details/106691210">https://blog.csdn.net/qq_38410494/article/details/106691210</a></p><h4 id="建议-21记住函数传参既不是传值也不是传引用">建议 21：记住函数传参既不是传值也不是传引用</h4><p>正确的叫法应该是传对象（call by object）或者说传对象的引用（call-by-object-reference）。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，而对于不可变对象，由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现的。</p><h4 id="建议-22尽量不使用变长参数">建议 22：尽量不使用变长参数</h4><ul><li>使用过于灵活。</li><li>如果一个函数的参数列表很长，虽然可以通过使用 <code>*args</code> 和 <code>**kwargs</code> 来简化函数的定义，但通常这意味着这个函数可以有更好的实现方式，应该被重构。</li><li>可变长参数适合在下列情况下使用（不仅限于以下场景）：为函数添加一个装饰器。</li></ul><h4 id="建议-23区分-str-和-repr">建议 23：区分 <code>str()</code> 和 <code>repr()</code></h4><p>函数 <code>str()</code> 和 <code>repr()</code> 都可以将 Python 中的对象转换成字符串，但两者依旧存在区别：</p><ul><li>两者之间的目标不同：<code>str()</code> 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型；而 <code>repr()</code> 面向的是 Python 解释器，其返回值表示 Python 解释器内部的含义，常作为编程人员 debug 用途。</li><li>在解释器中直接输入 <code>a</code> 时默认调用 <code>repr()</code> 函数，而 <code>print a</code> 则调用 <code>str()</code> 函数。</li><li><code>repr()</code> 的返回值一般可以用 <code>eval()</code> 函数来还原对象。</li><li>这两个方法分别调用内建的 <code>__str__()</code> 和 <code>__repr__()</code> 方法，一般来说在类中都应该定义 <code>__repr__()</code> 方法，而 <code>__str__()</code> 方法则为可选，当可读性比准确性更为重要的时候应该考虑定义 <code>__str__()</code> 方法。如果类中没有定义 <code>__str__()</code> 方法，则默认会使用 <code>__repr__()</code> 方法的结果来返回对象的字符串表示形式。用户实现 <code>__repr__()</code> 方法的时候最好保证其返回值可以用 <code>eval()</code> 方法使对象重新还原。</li></ul><h4 id="建议-24掌握字符串的用法">建议 24：掌握字符串的用法</h4><p>有人说过，编程有两件事，一件是处理数值，另一件是处理字符串。所以掌握字符串的用法尤为重要。具体可以看看这篇博客：<a href="https://blog.csdn.net/qq_38410494/article/details/106697509">https://blog.csdn.net/qq_38410494/article/details/106697509</a></p><h4 id="建议-25了解并学会选择-sort-和-sorted">建议 25：了解并学会选择 <code>sort()</code> 和 <code>sorted()</code></h4><ul><li>两者都是排序，但 <code>sorted()</code> 的使用范围更加广。</li><li><code>sorted()</code> 在 Python2.4 中引入，返回一个排序后的列表，原列表保持不变;<code>sort()</code> 直接修改原有列表，函数返回 <code>None</code>。</li><li><code>sorted()</code> 可以作用与任何可迭代对象，而 <code>sort()</code> 一般作用与列表。</li></ul><h4 id="建议-26使用-counter-进行计数统计">建议 26：使用 Counter 进行计数统计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datas = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Counter(datas))</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="number">7</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>Counter 类是自 Python2.7 起增加的，属于字典类的子类，是一个容器对象，主要用来统计散列对象，支持集合操作 <code>+</code>、<code>-</code>、<code>&amp;</code>、<code>|</code>，其中 <code>&amp;</code> 和 <code>|</code> 操作分别返回两个 Counter 对象各元素的最小值和最大值。</p><h4 id="建议-27使用-pandas-处理大型-csv-文件">建议 27：使用 <code>pandas</code> 处理大型 CSV 文件</h4><p>Pandas 即 Python Data Analysis Library，是为了解决数据分析而创建的第三方工具，它不仅提供了丰富的数据模型，而且支持多种文件格式处理，包括 CSV、HDF5、HTML 等，能够提供高效的大型数据处理。其支持的两种数据结构—— <code>Series</code> 和 <code>DataFrame</code> ——是数据处理的基础。</p><h4 id="建议-28使用-traceback-获取栈信息">建议 28：使用 <code>traceback</code> 获取栈信息</h4><p>当程序产生异常的时候，最需要面对异常的其实是开发人员，他们需要更多的异常提示的信息，以便调试程序中潜在的错误和问题。traceback 模块可以满足这个需求，它会输出完整的栈信息。类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execpt IndexError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&quot;the index out of range&quot;</span>)</span><br><span class="line">    print(e)</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure><h4 id="建议-29使用-logging-记录日志信息">建议 29：使用 <code>logging</code> 记录日志信息</h4><p>仅仅将栈信息输出到控制台是远远不够的，更为常见的是使用日志保存程序运行过程中的相关信息，如运行时间、描述信息以及错误或者异常发生时候的特定上下文信息。</p><h4 id="建议-30推荐使用-threading-编写多线程">建议 30：推荐使用 <code>threading</code> 编写多线程</h4><h4 id="建议-31使用-queue-多线程更安全">建议 31：使用 <code>Queue</code> 多线程更安全</h4><h4 id="建议-32知道-__init__-不是构造方法">建议 32：知道 <code>__init__()</code> 不是构造方法</h4><p>实际上 <code>__init__()</code> 并不是真正意义上的构造方法，<code>__init__()</code> 方法所做的工作是在类的对象创建好之后进行变量的初始化。<code>__new__()</code> 方法才会真正创建实例，是类的构造方法。</p><h4 id="建议-33理解-self-参数">建议 33：理解 <code>self</code> 参数</h4><p>也许很多人感受 self 最奇怪的地方就是：在方法声明的时候需要定义 self 作为第一个参数，而调用方法的时候却不用传入这个参数。这里简单说说为什么需要 <code>self</code>：</p><ul><li>Python 在当初设计的时候借鉴了其他语言的一些特征。</li><li>Python 语言本身的动态性决定了使用 <code>self</code> 能够带来一定便利。</li><li>在存在同名的局部变量以及实例变量的情况下使用 self 使得实例变量更容易被区分。</li></ul><h4 id="建议-34区分-__getattr__-和-__getattribute__">建议 34：区分 <code>__getattr__()</code> 和 <code>__getattribute__()</code></h4><p><code>__getattr__()</code> 和 <code>__getattribute__()</code> 都可以用做实例属性的获取和拦截，<code>__getattr__()</code> 适用于未定义的属性，即该属性在实例中以及对应的类的基类以及祖先类中都不存在，而 <code>__getattribute__()</code> 对于所有属性的访问都会调用该方法。需要注意的是 <code>__getattribute__()</code> 仅应用于新式类。</p><p><code>__getattribute__()</code> 总会被调用，而 <code>__getattr__()</code> 只有在 <code>__getattribute__()</code> 中引发异常的情况下才会被调用。</p><h4 id="建议-35掌握-metaclass">建议 35：掌握 <code>metaclass</code></h4><p>元类用来指导类的生成，元方法可以从元类或者类中调用，不能从类的实例中调用，而类方法既可以从类中调用也可以从类的实例中调用。</p><h4 id="建议-36熟悉-python-的迭代器">建议 36：熟悉 Python 的迭代器</h4><h4 id="建议-37熟悉-python-的生成器">建议 37：熟悉 Python 的生成器</h4><h4 id="建议-38理解-gil-的局限性">建议 38：理解 GIL 的局限性</h4><p>GIL 被称为为全局解释器锁（Global Interpreter Lock），是 Python 虚拟机上用作互斥线程的一种机制，它的作用是保证任何情况下虚拟机中只会有一个线程被运行，而其他线程都处于等待 GIL 锁被释放的状态。</p><p>在单核 CPU 中，GIL 对多线程的执行并没有太大影响，因为单核上的多线程本质上就是顺序执行的。多核 CPU 已经成为一个常见的现象，GIL 的局限性限制了其在多核 CPU 上发挥优势，因此对于 GIL 的去留也曾引发过激烈的讨论。</p><p>Guido 以及 Python 的开发人员都有一个很明确的解释，那就是去掉 GIL 并不容易。Python1.5 他们曾尝试过，但结果非常糟糕。Python3.2 他们重新实现了 GIL，进行了优化。至少目前看来，GIL 依旧会保留。</p><h4 id="建议-39使用-multiprocessin-克服-gil-缺陷">建议 39：使用 <code>multiprocessin</code> 克服 GIL 缺陷</h4><p>为了能够充分利用多核优势，Python 的专家们提供了另外一个解决方案：多进程。<code>Multiprocessing</code> 由此而生，它是 Python 中的多进程管理包，主要用来帮助处理进程的创建以及它们之间的通信和相互协调。</p><h4 id="建议-40使用线程池提高效率">建议 40：使用线程池提高效率</h4><p>线程池，它通过将事先创建多个能够执行任务的线程放入池中，所需要执行的任务通常被安排在队列中。由于线程预先被创建并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次创建线程，从而节省线程创建和销毁的开销，带来更好的性能和系统稳定性。</p><h4 id="建议-41使用-pylint-检查代码风格">建议 41：使用 <code>Pylint</code> 检查代码风格</h4><p>如果你的团队遵循 PEP8 的编码风格，Pylint 是个不错的选择（当然还有其他很多选择，如 pychecker、pep8 等）。</p><h4 id="建议-42了解代码优化的基本原则">建议 42：了解代码优化的基本原则</h4><ol type="1"><li>优先保证代码是可工作的。</li><li>权衡优化的代价，优化是有代价的，想解决所有性能问题几乎是不可能的。、</li><li>定义性能指标，集中力量解决首要问题，在进行优化之前，一定要针对问题进行主次排列，并集中力量解决主要问题。</li><li>不要忽略可读性，优化不能以牺牲代码的可读性，甚至带来更多的副作用为代价。</li></ol><h4 id="建议-43让-cprofile-定位性能拖油瓶">建议 43：让 <code>cProfile</code> 定位性能拖油瓶</h4><p>程序性能影响往往符合 <code>80/20</code> 法则，即 <code>20%</code> 的代码的运行时间占用了 <code>80%</code> 的总运行时间，实际上，比例要夸张得多。所以如何定位瓶颈所在很有难度，靠经验是很难找出造成性能瓶颈的代码的。这时候，我们需要一个工具帮忙，<code>profile</code> 是 Python 的标准库。可以统计程序里每一个函数的运行时间，并且提供了多样化的报表，而 <code>cProfile</code> 则是它的 C 实现版本，剖析过程本身需要消耗的资源更少。所以在 Python 3 中，<code>cProfile</code> 代替了 <code>profile</code>，成为默认的性能剖析模块</p><h4 id="建议-44努力降低算法复杂度">建议 44：努力降低算法复杂度</h4><p>同一问题可用不同算法解决，而一个算法的优劣将直接影响程序的效率和性能。算法的评价主要从时间复杂度和空间复杂度来考虑。</p><h4 id="建议-45学会优化循环">建议 45：学会优化循环</h4><ol type="1"><li>减少循环内部的计算。能提出循环的运算不要在循环内部进行。</li><li>将显式循环改为隐式循环。比如，求 <code>1, 2, ..., n</code> 的和，可以写成 <code>n*(n+1)/2</code>。类似的情况写成计算表达式效率更高，这可能牺牲了可读性，这时注释就显得尤为重要。</li><li>在循环中尽量引用局部变量。在命名空间中局部变量优先搜索，因此局部变量的查询会比全局变量要快。</li><li>关注内层嵌套循环。在多层嵌套循环中，重点关注内层嵌套循环，尽量将内层循环的计算往上层移。</li></ol><h4 id="建议-46选择合适的数据结构">建议 46：选择合适的数据结构</h4><p>在解决性能问题的时候，往往可以从使用的数据结构入手。了解不同数据结构的实现原理，针对不同的应用场景选择合适的数据结构，也是优化性能的一种有效手段。</p><h4 id="建议-47使用-cc-模块扩展提高性能">建议 47：使用 C/C++ 模块扩展提高性能</h4><p>Python 具有良好的可扩展性，利用 Python 提供的 API，如宏、类型、函数等，可以让 Python 方便地进行 C/C++ 扩展，从而获得较优的执行性能。</p><p>但是，这种方式仍然有几个问题让 Pythonistas 非常头疼。那就是掌握 C/C++ 的学习成本巨大，而且编写过程繁琐复杂。通过开发人员的艰苦工作，<code>Cython</code> 诞生了，它可以把 Python 代码直接编译成等价的 C/C++代码，从而获得性能提升。所以在这里推荐使用 <code>Cython</code> 编写扩展模块。</p><hr /><p>到这里就是全部的 47 个有关编写高质量 Python 代码的建议，不知道你有没有收获。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python最好减少使用 from...import，这里告诉你为什么</title>
      <link href="2020/06/11/023-python-more-import/"/>
      <url>2020/06/11/023-python-more-import/</url>
      
        <content type="html"><![CDATA[<p>在 <strong>Python</strong> 中我们可以通过三种方式来引入外部的模块：</p><ul><li><code>import</code></li><li><code>from...import</code></li><li><code>__import__</code></li></ul><p>其中 <code>__import__</code> 比较少使用，而它本身和 <code>import</code> 比较相似，区别在于前者显示的将模块用字符串的形式传递到命名空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(name[, <span class="built_in">globals</span>[, <span class="built_in">locals</span>[, fromlist[, level]]]])</span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;sys&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而在使用 <code>import</code> 时要注意以下几点：</p><ul><li>一般情况下尽量优先使用 <code>import a</code> 形式，如访问 <code>B</code> 时需要使用 <code>a.B</code> 的形式。</li><li>有节制地使用 <code>from a import B</code> 形式，可以直接访问 <code>B</code>。</li><li>尽量避免使用 <code>from a import *</code>，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象。</li></ul><p>那么为什么要注意 i 这些呢？</p><p>这就不得不说说 Python 中的 <code>import</code> 机制。Python 在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在 <code>sys.modules</code> 中。导入 <code>sys</code> 模块后在 Python 解释器中输入 <code>sys.modules.items()</code> 便可显示所有预加载模块的相关信息。当加载一个模块的时候，解释器实际上要完成以下动作：</p><ol type="1"><li>在 <code>sys.modules</code> 中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。</li><li>如果在 <code>sys.modules</code> 中找不到对应模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入 <code>sys.modules</code> 中。</li><li>加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。</li><li>执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。</li></ol><figure><img src="https://img-blog.csdnimg.cn/2020061101451629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="demo" /><figcaption aria-hidden="true">demo</figcaption></figure><p>从输出结果可以看出，对于用户定义的模块，<code>import</code> 机制会创建一个新的 module 将其加入当前的局部命名空间中，与此同时，<code>sys.modules</code> 也加入了该模块的相关信息。</p><figure><img src="https://img-blog.csdnimg.cn/20200611015113603.png#pic_center" alt="demo2" /><figcaption aria-hidden="true">demo2</figcaption></figure><p>但从它们的 id 输出结果可以看出，本质上是引用同一个对象。</p><p>需要注意的是，直接使用 <code>import</code> 和使用 <code>from a import B</code> 形式这两者之间存在一定的差异，后者直接将 <code>B</code> 暴露于当前局部空间，而将 <code>a</code> 加载到 <code>sys.modules</code> 集合。</p><p>那么 <code>from ... import</code> 有什么不好的地方呢？</p><p><strong>命名空间冲突</strong></p><p>假设我们现在有两个模块 <code>a</code> 和 <code>b</code>，内容如下：</p><h2 id="section"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span>():</span></span><br><span class="line">print(<span class="string">&quot;This is a&#x27;s C.&quot;</span>)</span><br></pre></td></tr></table></figure></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span>():</span></span><br><span class="line">print(<span class="string">&quot;This is b&#x27;s C.&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们在某一个文件中要同时导入这两个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> C</span><br><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> C</span><br><span class="line"></span><br><span class="line">C()</span><br></pre></td></tr></table></figure><p>运行后会得到 <code>This is b's C.</code>, 从结果中可以看到后导入的包中的 <code>add()</code> 覆盖了先导入的。特别是在一个较大的项目中如果频繁的使用 <code>from ... import ...</code> 就会大概率的出现命名空间冲突的问题。 所以一般最好不使用该方式，若在非常明确不会导致冲突的前提在，以下情况可以考虑：</p><ol type="1"><li>只导入少数方法或属性时;</li><li>使用 <code>模块名.名称</code> 的方式过于繁琐的时候;</li><li>模块文档明确要求要使用该方法， 如： <code>from urllib import request</code>。</li></ol><p><strong>循环嵌套导入问题</strong></p><p>现在有两个文件 <code>c1</code> 和 <code>c2</code>， 内容如下：</p><h2 id="section-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c1.py</span></span><br><span class="line"><span class="keyword">from</span> c2 <span class="keyword">import</span> y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c2.py</span></span><br><span class="line"><span class="keyword">from</span> c1 <span class="keyword">import</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure><img src="https://img-blog.csdnimg.cn/20200611021819519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="demo-3" /><figcaption aria-hidden="true">demo-3</figcaption></figure><p>这时无论运行哪一个都会抛出 <code>ImportError</code> 异常。</p><p>这是因为在执行 <code>c1.py</code> 的加载过程中，需要创建新的模块对象 <code>c1</code> 然后执行 <code>c1.py</code> 所对应的字节码。在这过程中先遇到语句<code>from c2 import y</code>。</p><p>而 <code>c2</code> 在 <code>sys.modules</code> 也不存在，故此时会去创建与 <code>c2</code> 对应的模块对象并执行 <code>c2.py</code> 所对应的字节码。</p><p>而在创建 <code>c2</code> 中遇到 <code>from c1 import x</code> 时，由于 <code>c1</code> 已经存在，于是便去其对应的字典中查找 <code>y</code>，但 <code>c1</code> 模块对象虽然创建但初始化的过程并未完成，因此其对应的字典中并不存在 <code>y</code> 对象，此时便抛出 <code>ImportError: cannot import name 'y' from 'c2'</code> 异常。而解决循环嵌套导入问题的一个方法是直接使用 <code>import</code> 语句。</p><p>说到这里就差不多聊完啦。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么我老是看不到星星呢？</title>
      <link href="2020/06/09/021-why-I-can&#39;t-see-the-starts/"/>
      <url>2020/06/09/021-why-I-can&#39;t-see-the-starts/</url>
      
        <content type="html"><![CDATA[<p>幼时的记忆已经不记得多少，还有那么一点印象就是小时候，书本上的星星真的很好看。现在想来都不知道自己有没有亲眼见过漫天繁星的夜空。</p><p>这个飞速发展的世界，为我们带来了许多，也让不少流逝。至懂事以来，晚上的夜空要不没有星星，要不零散几颗。感觉城市就是不夜城，似乎没有休息的时间。最近夜晚散步的时候拍了几张夜晚的照片。</p><figure><img src="/images/IMG_1958_20200608-232023.JPG" alt="夜空" /><figcaption aria-hidden="true">夜空</figcaption></figure><p>这一张上有北斗七星哦，这还是自知道它们以来，第一次在天空中找到它们。</p><figure><img src="/images/IMG_1964_20200608-232023.JPG" alt="北斗七星" /><figcaption aria-hidden="true">北斗七星</figcaption></figure><p>现在想想是不是太快的节奏连让我停下来抬头望望夜空的空闲都没有了呢？就算星星偶尔出来的夜晚我也都被我错过了。</p>]]></content>
      
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux下virtualbox使用</title>
      <link href="2020/05/27/020-use_virtualbox_in_linux/"/>
      <url>2020/05/27/020-use_virtualbox_in_linux/</url>
      
        <content type="html"><![CDATA[<p>这里以自己使用的系统为案例 [MANJARO]</p><p><strong>VirtualBox</strong> 是一种流行的应用程序，它允许在现有操作系统（称为 Host）中安装和运行其他操作系统（称为 Guests）。</p><h1 id="安装">安装</h1><p>安装命令：</p><p>要安装 VirtualBox，您需要安装软件包 <code>virtualbox</code> 和 <code>linux*-virtualbox-host-modules</code>。后者必须与您正在运行的内核版本匹配。要列出已安装的内核，请使用 <code>mhwd</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~&gt; mhwd-kernel -li</span><br><span class="line">Currently running: 5.4.0-1-MANJARO (linux54)</span><br><span class="line">The following kernels are installed <span class="keyword">in</span> your system:</span><br><span class="line">   * linux54</span><br></pre></td></tr></table></figure><p>请在终端中输入以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu virtualbox linux54-virtualbox-host-modules</span><br></pre></td></tr></table></figure><p>安装完成后，有必要将 VirtualBox 模块添加到您的内核中。简单的方法是简单地重新启动系统。若要立即使用 VirtualBox，输入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vboxreload</span><br></pre></td></tr></table></figure><h1 id="创建虚拟机">创建虚拟机</h1><p><img src="https://img-blog.csdnimg.cn/20200527230608350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p><img src="https://img-blog.csdnimg.cn/20200527231003133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p><img src="https://img-blog.csdnimg.cn/2020052723101841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p>一路 <code>next</code></p><p><img src="https://img-blog.csdnimg.cn/20200527231406775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p><img src="https://img-blog.csdnimg.cn/20200527231751967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p>然后，点击 <code>start</code> 启动虚拟机。</p><h1 id="共享文件夹和粘贴板双向托放">共享文件夹和粘贴板，双向托放</h1><h3 id="共享粘贴板">共享粘贴板</h3><figure><img src="https://img-blog.csdnimg.cn/2020052723345798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="双向托放">双向托放</h3><p><img src="https://img-blog.csdnimg.cn/20200527233442900.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><h3 id="共享文件夹">共享文件夹</h3><p>如果你虚拟机中是 linux 系统，直接在设置中设置共享文件夹路径即可。</p><p><img src="https://img-blog.csdnimg.cn/20200527233719542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p>如果你虚拟机中是 windows，那么在设置好共享文件夹后还需要一些额外的操作。</p><p>首先你需要安装增强功能。</p><p><img src="https://img-blog.csdnimg.cn/20200527234655728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p>安装完成后会出现一个驱动，点击安装该驱动。安装完成后重启就可以看到你的共享文件夹了。</p><p><img src="https://img-blog.csdnimg.cn/20200527234751103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 遍历目录（for and while）</title>
      <link href="2020/05/25/029-shell-traverse-directory/"/>
      <url>2020/05/25/029-shell-traverse-directory/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-for-循环">使用 for 循环</h1><p>这种方法最常见，所以直接给出代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;input dir path&quot;</span> dir</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> `ls <span class="variable">$dir</span>`; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="使用-while-循环">使用 while 循环</h1><p>想使用 while ，目标就是得到一个包含目录下每一个项目的数组。</p><p>如果直接 <code>./*</code>, 这样变量拿到的其实是一个字符串，这不满足我们的要求。</p><p>所以我们可以使用小括号，想这样：<code>(./*)</code>。小括号在 shell 中有初始化数组的作用，所以可以将得到的字符串，按空格分割每一项得到一个数组。</p><p>然后，我们遍历数组输出每一项就好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;input:&quot;</span> dir</span><br><span class="line"></span><br><span class="line">files=(<span class="variable">$dir</span>/*)</span><br><span class="line">i=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$i</span> -lt <span class="variable">$&#123;#files[*]&#125;</span> ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;files[$i]&#125;</span></span><br><span class="line">    <span class="built_in">let</span> i++</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用MPD在终端中听音乐</title>
      <link href="2020/05/19/030-use-MPD-to-listen-music-in-terminal/"/>
      <url>2020/05/19/030-use-MPD-to-listen-music-in-terminal/</url>
      
        <content type="html"><![CDATA[<p>音乐播放器守护程序（MPD）是用于播放音乐的灵活而强大的服务器端应用程序。通过插件和库，它可以播放各种声音文件，并受其网络协议控制。为了与 mpd 进行交互，需要一个客户端程序。</p><figure><img src="https://img-blog.csdnimg.cn/20200519004703331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="demo-image" /><figcaption aria-hidden="true">demo-image</figcaption></figure><p><strong>最常用的客户端应用程序是</strong>：</p><blockquote><ul><li><strong>ncmpccpp</strong>：几乎完全克隆了 ncmpc，其中包含一些用 C ++编写的新函数</li><li><strong>ncmpc</strong>：mpd Ncurses 客户端</li><li><strong>mpc</strong>：mpd 服务器的命令行用户界面</li></ul></blockquote><p><strong>install</strong></p><ul><li>安装 <strong>MPD</strong> ，<code>sudo pacman -S mpd</code></li><li>安装客户端，我使用 <strong>ncmpc</strong> ，<code>sudo pacman -S ncmpc</code></li><li>配置文件您可以参考<code>/usr/share/doc/mpd/mpdconf.example</code></li><li>如果需要配置文件可以从这里获取：<a href="https://github.com/zlj-zz/dotconfig/tree/master/mpd">mpd.conf</a></li></ul><p><strong>mpc 的常用参数：</strong></p><p><code>mpc</code> 查看当前播放歌曲的信息</p><p><code>mpc add</code> 添加歌曲到播放列表</p><p><code>mpc listall</code> 可以列出所有的歌曲</p><p><code>mpc listall | mpc add</code> 可以把所有歌曲都添加到当前的播放列表</p><p><code>mpc playlist</code> 查看当前播放列表</p><p><code>mpc play</code> 播放</p><p><code>mpc pause</code> 暂停</p><p><code>mpc stop</code> 停止</p><p><code>mpc next</code> 播放下一首</p><p><code>mpc prev</code> 播放前一首</p><p><code>mpc repeat on</code> 启用重复播放</p><p><code>mpc random on</code> 启用随机播放</p><p><code>mpc play 7</code> 播放列表中第 7 首</p><p><code>mpc search filename</code> 可以按文件名查找</p><p><code>mpc search artist</code> 可以按歌手查找</p><p><code>mpc search title</code> 可以按歌曲名查找</p><p><code>mpc volume +20</code>， <code>mpc volume -20</code> 音量加减，数值可以自己给</p><p><strong>问题</strong></p><ul class="task-list"><li><p><input type="checkbox" disabled="" checked="" /><strong>如果在配置文件中修改了端口</strong>。</p><p>答：连接时需要设置端口，例如：<code>ncmpc -p 6666</code>。而且我建议使用 <code>-C</code> 禁用颜色。</p></li><li><p><input type="checkbox" disabled="" checked="" /><strong>要在登录时自动启动 MPD，请输入。</strong></p><p>答：<code>systemctl --user enable mpd</code>。</p></li><li><p><input type="checkbox" disabled="" checked="" /><strong>要在 tty 登录时自动启动 MPD。</strong></p><p>答：将以下内容添加到〜/ .profile 或其他自动启动文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MPD daemon start (if no other user instance exists)</span></span><br><span class="line">  [ ! -s ~/.config/mpd/pid ] &amp;&amp; mpd</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>arch department use teamviewer</title>
      <link href="2020/05/15/019-arch-use-teamviewer/"/>
      <url>2020/05/15/019-arch-use-teamviewer/</url>
      
        <content type="html"><![CDATA[<p><strong>Teamviewer</strong> is a simple and fast solution that can be used for remote control of application in the background of any firewall and NAT proxy, desktop sharing and file transfer.</p><p>First, we should install teamviewer.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S teamviewer</span><br></pre></td></tr></table></figure><p>Then we should enable the server of teamviewer.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">teamviewer --daemon start</span><br></pre></td></tr></table></figure><p>And you can set it to start automatically.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">teamviewer --daemon enable</span><br></pre></td></tr></table></figure><p>Next you can start using.</p><p>If you don't have <strong>ID</strong>, you may should add this to <code>/opt/teamviewer/config/global.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[int32] EulaAccepted = 1</span><br><span class="line">[int32] EulaAcceptedRevision = 6</span><br></pre></td></tr></table></figure><p>Generally speaking, this is no problem.</p><figure><img src="https://img-blog.csdnimg.cn/20200515011802279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="demo" /><figcaption aria-hidden="true">demo</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象程序设计总结</title>
      <link href="2020/05/07/018-Object-oriented-programing-c/"/>
      <url>2020/05/07/018-Object-oriented-programing-c/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1><p><strong>对象</strong>:任何一个对象都应该具备两个要素 -- <code>属性</code> <code>行为</code></p><blockquote><p>在 C++ 中每个对象都要数据(体现了<em>属性</em>)和函数(用来对数据进行操作,实现功能)两部分组成.</p></blockquote><p><strong>类</strong>: 具有共性的实体的抽象.</p><ul><li>类是对象的抽象,不占有内存.</li><li>对象是类的特例,即类的具体表现形式,占有存储空间.</li></ul><p><br><strong>面向对象的三大特性：封装、继承、多态。</strong></p><p><strong>封装</strong>：将方法和数据封装在类里面，根据访问限定符的使用保证数据的安全性，隐藏了方法的实现细节，方便使用。</p><blockquote><p>封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是通过外部接口以及特定的访问权限来使用类的成员。</p></blockquote><p><strong>继承</strong>：对已有类增加属性和功能, 或进行部分修改来建立新的类, 是实现代码的复用的重要手段，继承是类型之间的关系建模。</p><blockquote><p>继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码，在令子类继承父类的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能，继承是指一个对象直接使用另一个对象的属性和方法。</p></blockquote><p><strong>多态</strong>:在面向对象的程序里面，同一个消息被不同的对象接受后可以导致不同的行为，是接口的多种不同的实现方式，极大的提高了代码的重用。</p><blockquote><p>多态性，允许将子类类型的指针赋值给父类类型的指针，多态性在 C++中是通过虚函数实现的。虚函数就是允许被其子类重新定义的成员函数。</p></blockquote><!--而子类重新定义父类虚函数的做法，称为“覆盖”，或者称为“重写”。子类重写父类中虚函数时，即使不用virtual声明，该重载函数也是虚函数。--><p><strong>抽象</strong>：表示同一类事物的本质。</p><h1 id="对象的引用">对象的引用</h1><ol type="1"><li><p>同一类的对象可以相互赋值。</p></li><li><p>在一个类中至少有一个公用的成员函数作为对外的接口。</p></li></ol><blockquote><p>公用成员函数是用户使用类的公用接口，或者类的对外接口。外界只能通过公用成员函数来实现对类内的私有函数进行操作。</p></blockquote><ol start="3" type="1"><li><p>当类中有指针且有动态内存分配时，务随便赋值，有可能会出现问题。</p></li><li><p><code>::</code>是作用域的限定符，声明函数或者变量是属于哪个类。</p></li><li><p>内置成员函数：C++ 对一般的内置函数需要使用关键字 <code>inline</code> 声明.</p></li></ol><!--在调用函数时，并不是真正的执行调用的过程，而是把函数的代码嵌入程序的调用点，大大减少调用函数的时间开销。--><blockquote><p>对于类内定义的成员函数，可以省略关键字 <code>inline</code>，C++ 默认类内的成员函数为内置函数。但是如果成员函数在类体外定义时，需要在声明与定义的时候加上 <code>inline</code>关键字说明</p></blockquote><!--（必须将类定义和成员函数的定义放在同一个头文件中或者卸载同一个源文件中，否则编译无法进行置换）。--><ol start="6" type="1"><li>C++ 中类的每个对象所占有的存储空间只是该对象的数据成员所占有的存储空间.</li></ol><blockquote><p>不包括函数代码所占有的存储空间，与成员函数无关。而这些对象的成员函数对应的是同一个函数代码段。</p></blockquote><ol start="7" type="1"><li>不管成员函数在类内定义还是类外定义，是否用 <code>inline</code> 声明，存储方式相同，都不占用对象的存储空间。</li></ol><blockquote><p><code>inline</code> 函数只影响程序的执行效率，而与成员函数是否占有对象的存储空间无关。</p></blockquote><ol start="8" type="1"><li><p>对象成员引用的方式：</p><ol type="1"><li><p>通过对象名与成员运算符访问对象中的成员 (<strong>对象名.成员名</strong> <code>stud.num</code>)</p></li><li><p>通过指向对象的指针访问对象的成员 (<strong>指针—&gt;成员名</strong> <code>p—&gt;num</code>)</p></li><li><p>通过对象的引用来访问对象的成员。</p></li></ol></li><li><p>类的公用接口与实现分离：</p><ul><li><p>通过成员函数对数据进行操作称为类的功能实现，为了防止用户任意的修改公用成员函数</p></li><li><p>类内被操作的数据是私有的，类的功能实现细节是对用户屏蔽的。这种实现称为私有实现。</p></li><li><p>好处：</p><ol type="1"><li>如果要修改或扩充类的功能，只需修改该类中有关的数据成员与成员函数，成语中类以外的部分可以不必修改。</li><li>编译时发现勒种的数据读写有错，不必检查整个程序，只需要检查本类中访问的这些数据的少数成员函数。</li></ol></li></ul></li><li><p>把类的声明放在指定的头文件中，用户要使用该类，只需要把有关的头文件包含进来即可。不必再程序中重复书写类的声明，以减少工作量，节省篇幅，提高编程的效率。</p></li><li><p>一个 C++程序是有 3 部分组成：</p></li></ol><p>（1）类声明的头文件（<code>.h</code>）。（2）类实现文件（<code>.cpp</code>）包含类成员函数的定义。（3）类的使用文件（<code>.cpp</code>）即主函数文件。</p><h1 id="构造函数-和-析构函数">构造函数 和 析构函数</h1><p><strong>构造函数</strong>主要用于在定义对象时，完成对象的初始化.</p><blockquote><p>每一个类都应该有一个构造函数，如果用户没有定义构造函数，编译器会自动生成构造函数(参数和函数体为空的构造函数)，如果用户自定义了构造函数，那么编译器不再提供默认的构造函数。</p></blockquote><p><strong>特性</strong>：</p><ol type="1"><li><p>构造函数的名称必须要与当前类的名称相同。</p></li><li><p>构造函数仅在定义对象时由系统调用，其他时间无法调用。而且只执行一次。</p></li><li><p>构造函数可以有参数，也可以没有参数，但是不允许有返回值。</p></li><li><p>构造函数只能定义为公有成员，不能定义为其他。</p></li></ol><p><strong>调用条件</strong>：</p><p>1.定义对象时。2.为对象分配动态内存时。3.定义无名对象（稍作了解）</p><blockquote><p><strong>注意</strong>：（1）构造函数可以进行重载，以便用于不同形式的对象的定义。（2）构造函数还可以使用默认的缺省参数。如果构造函数既有重载，又有缺省参数时，注意不要产生二义性。</p></blockquote><p><strong>参数初始化表</strong>：</p><p>除了构造函数进行对成员数据进行初始化，还有参数初始化表对数据初始化，在函数首部实现。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOX::BOX(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len):height(h),width(w),length(len)&#123;&#125;</span><br><span class="line"></span><br><span class="line">类名::构造函数名（[参数表]）[：成员初始化表]</span><br><span class="line">    &#123;[构造函数体]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果数据成员是数组，则需要在构造函数的函数体内用语句对其复制，不能再参数初始化表中进行对其初始化。</p><p><strong>重载</strong>：</p><p>在一个类中定义多个构造函数名具有相同的名字，而参数的个数或者参数的类型不同。</p><p><strong>析构函数</strong>是一种特殊的成员函数，完成与构造函数相反的工作，对象退出生命周期时，完成清理的工作。如：释放内存等。</p><p><strong>特性</strong>：</p><ol type="1"><li><p>析构函数的名称与类的名称相同。为了区分，析构函数名字前面有<code>~</code></p><p>构造：<code>stu()&#123;&#125;</code>        析构：<code>~stu()&#123;&#125;</code></p></li><li><p>析构函数无参、无返回值。</p></li><li><p>析构函数<u>不可重载</u>。每一个类有且只有一个析构函数，但是可以有多个构造函数。</p></li><li><p>在对象退出生命周期时，编译器会自动调用析构函数。但是，可以人为调用析构函数，不过没意义。</p></li><li><p>一般情况下，使用系统默认的析构函数就可以。当类中有动态内存分配时，需要增加自定义的析构函数，否则有可能会导致内存泄露。</p></li></ol><p><strong>调用条件</strong>：</p><ol type="1"><li><p>对象退出生命周期时。定义的对象在调用结束后释放时自动执行析构函数。</p></li><li><p>释放动态分配的对象空间。使用<code>new</code>运算符动态的建立了一个对象，当使用<code>delete</code>运算符释放该对象时，先调用该对象的析构函数。</p></li><li><p>定义的全局的对象在程序离开其作用域的时候调用该全局对象的析构函数。</p></li><li><p>静态（static）局部对象在程序调用结束时对象并不释放，因此也不调用析构函数，只在 main 函数结束或调用 exit 函数结束程序时，才调用 static 局部对象的析构函数。</p></li></ol><p><strong>析构顺序</strong></p><p>同一作用域下，先构造的后析构。即最先被调用构造函数，其对应的析构函数最后被调用。先进后出。</p><p>调用析构函数的顺序与存储类别有关。</p><h1 id="this-指针">this 指针</h1><p>指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。<code>this</code>指针是隐式使用的，它是作为参数被传递给成员函数的。</p><h1 id="常对象">常对象</h1><p><code>类名 const 对象名[（实参表）]</code>      或者     <code>Const 类名 对象名[（实参表）]</code></p><p>在定义的时候必须初始化，如果一个对象声明为常对象，只能调用该对象的常成员函数，而不能调用其他的一般成员函数。常成员函数是常对象的唯一对外接口。</p><blockquote><p>常成员函数可以访问常对象中的数据成员，但是不允许修改对象中数据的值。但是一般的成员函数可以引用类中的非 const 数据成员也可以改变他们。</p></blockquote><p><strong>常对象成员</strong></p><p>常对象的数据成员都是常数据成员，必须通过构造函数的参数初始化表对常数据成员进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Const <span class="keyword">int</span> hour;</span><br><span class="line"></span><br><span class="line">Time::Time(<span class="keyword">int</span> h):hour(h)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>常成员函数</strong>：可以访问常对象中的数据成员，但是不允许修改对象中数据的值。</p><p><code>类型名 函数名（参数表） const；</code></p><p><strong>指向常对象的指针变量</strong></p><p><code>Const 类型名 * 指针变量名</code></p><p>如果一个变量声明为常变量，只能用指向常变量的指针向量指向它。</p><blockquote><p>指向常变量的指针变量除了可以指向常变量外，也可以指向未被声明为 const 的变量，但是不可通过该指针变量改变变量的值。</p></blockquote><p>当希望在调用函数时，对象的值不被修改，就应当把形参定义为指向常变量的指针变量，同时用对象的地址作为实参（对象可以是 const 或者非 const 型的）如果要求该对象不仅在调用函数的时候不被改变，而且要求它在程序执行的过程都不被调用，则需要把对象也定义为 const 型。</p><ul><li><p><code>Time const t;</code>             t 是一个常对象，其值在任何情况下都不能改变。</p></li><li><p><code>Void Time::fun() const;</code>    fun 是 Time 类中的常成员函数，可以引用，但是不能改变本类中的数据成员。</p></li><li><p><code>Time *const p;</code>           p 是指向 Time 类对象的常指针变量，p 的值不能改变。</p></li><li><p><code>Const Time *p;</code>           p 是指向 Time 类对象的指针变量，P 指向的类对象的值不可以通过 p 来改变。</p></li><li><p><code>Const Time &amp;t1 = t;</code>        t1 是 Time 类对象 t 的引用，二者指向同一个存储空间，t 的值不能改变。</p></li></ul><h1 id="对象的操作">对象的操作</h1><p><strong>对象的动态建立与释放</strong></p><p>在 C 语言中是利用库函数 <code>malloc</code> 和 <code>free</code> 来分配和撤销内存空间的。C++ 提供了简便而功能较强的运算符 <code>new</code> 和 <code>delete</code> 来取代 <code>malloc</code> 和 <code>free</code> 函数。</p><blockquote><p>注意： <code>new</code> 和 <code>delete</code> 是运算符，不是函数，因此执行效率高。</p></blockquote><p>用 <code>new</code> 分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则 <code>new</code> 会返回一个空指针 <code>NULL</code>（<em>0 值</em>），用户可以根据该指针的值判断分配空间是否成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box *pt;  <span class="comment">// 定义一个指向Box类对象的指针变量pt</span></span><br><span class="line">pt = <span class="keyword">new</span> Box;  <span class="comment">// 在pt中存放了新建对象的起始地址</span></span><br></pre></td></tr></table></figure><p><code>delete</code> 指针名; 如果被删除的是普通变量，则会直接释放动态分配的内存。如果被删除的是对象，则该对象的析构函数被调用。</p><blockquote><p>注意，用 <code>new</code> 动态分配的内存只能用 <code>delete</code> 释放一次，如果释放第二次会出现错误。</p></blockquote><p><strong>对象的赋值</strong>：<code>对象名2 = 对象名1；</code> 是对一个已经存在的对象赋值，必须向定义被赋值的对象，才能进行赋值。</p><!--对象的赋值：类名 对象名2（对象名1）； 或者 类名 对象名2=对象名1； //用对象1复制出对象2，是从无到有的建立一个新的对象，并使它与一个已有的对象完全相同（包括对象的结构与成员的值）--><p><strong>拷贝构造函数（复制构造函数）</strong>：也是构造函数，但是只有一个参数，这个参数是本类的对象，而且采用对象的引用的形式（一般约定加 <code>const</code> 声明，使参数值不能改变）。此复制构造函数就是将实参对象的各成员值一一赋给新的对象中的成员。</p><p>复制构造函数与普通构造函数的区别</p><ol type="1"><li><p>形式上的不同：两者虽然函数名与类名相同，也不指定函数类型。但复制构造函数只有一个参数，并且是对同类对象的引用-------复制构造函数无法重载</p><p>普通的构造函数： <code>类名（形参列表）</code></p><p>拷贝构造函数： <code>类名（类名 &amp;对象名）</code></p></li><li><p>在建立对象的时候实参类型不同，系统会根据实参类型决定调用普通的构造函数还是拷贝构造函数。</p></li></ol><p>在 C++中，下面三种对象需要调用拷贝构造函数（有时也称“复制构造函数”）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用已知对象初始化新对象。</span><br><span class="line">    stu s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果函数参数是某类的对象</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(stu s1)</span></span>&#123;&#125;</span><br><span class="line">    fun(s2);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果函数返回值为某类的对象时。</span><br><span class="line">    <span class="function">stu <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    stu s1 = fun();</span><br><span class="line"></span><br><span class="line">如果使用无名对象初始化新的对象，不会调用拷贝构造函数。</span><br><span class="line">当类中有指针且进行动态内存分配时，要使用自定义的拷贝构造函数。</span><br><span class="line">可以自定拷贝构造函数，如果自定义后，默认的拷贝构造函数失效。</span><br></pre></td></tr></table></figure><p>补充：</p><ul><li><p>浅拷贝：只复制数据，没复制内存空间。</p></li><li><p>深拷贝：既拷贝数据，也要复制内存空间。</p></li></ul><p><strong>静态数据成员：</strong></p><ol type="1"><li><p>静态数据成员。为各个对象所共有，在内存中只占有一份空间，每个对象都可以引用。这样可以节省空间，提高效率。</p></li><li><p>只要在类中定义了静态数据成员，即使不定义对象，也为静态的数据成员分配看空间，可以被引用。而且也不随着对象的撤销而释放，到程序结束后才释放空间。</p></li><li><p>可以初始化，但是只能在类体外进行初始化。 <code>数据类型 类名::静态数据成员名=初值；</code></p></li><li><p>不能使用参数初始化表对静态成员数据进行初始化。编译系统会自动赋值为 0；</p></li><li><p>可以通过对象名引用，也可以通过类名引用。（它是属于类的，不是属于某个对象的）</p></li><li><p>如果静态数据成员被定义为私有的，则不能在类外直接引用，必须经过公用的成员函数引用。</p></li><li><p>有了静态数据成员，各对象之间有了沟通的渠道，实现数据共享，可以不使用全局变量，全局变量破坏了封装的原则，不符合面向对象的程序要求。</p></li></ol><p><strong>静态成员函数：</strong></p><ol type="1"><li><p>静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</p></li><li><p>静态成员函数只能访问静态数据成员。</p></li><li><p>静态成员函数与非静态成员函数的根本区别：</p><p>非静态成员函数在调用时 <code>this</code> 指针时被当作参数传进。而静态成员函数属于类，没有 <code>this</code> 指针，所以不能访问本类中的非静态成员，但是可以引用本类中的静态数据成员，如果一定要引用本类中的非静态成员，需要加上对象名和成员运算符 <code>.</code>。</p></li><li><p>静态成员函数是类的一部分，而不是对象的一部分，在类外调用公用的静态成员函数要使用类名和域运算符 <code>::</code>。</p></li></ol><h1 id="友元">友元</h1><p><strong>友元(friend)机制</strong></p><p>允许一个类将对其非公有成员的访问权授予指定的函数或者类.</p><p>友元的声明以<code>friend</code>开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p><p><strong>友元函数</strong></p><p>是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。</p><ol type="1"><li><p>将普通的函数声明为友元函数（可以访问此类中的私有数据成员）：在类体内声明，使用关键字<code>friend</code>。在类体外定义不使用类作为限定符，它是非成员函数，不属于任何类。在访问类的私有数据成员，必须加上对象名。</p></li><li><p>友元成员函数：该类中的成员函数声明为另一个类的友元函数。需要对另一个类进行提前声明，只包含类名，不包含类体。在另一个类的类体中声明为友元函数的时候需要加上本类的类名与限定符 <code>::</code></p></li></ol><blockquote><p>Eg: <code>friend void Time:: display(Date &amp;);</code>, <code>display()</code>函数是类 Date 的普通成员函数</p></blockquote><p><strong>友元类</strong></p><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</p><p>关于友元类的注意事项：</p><ol type="1"><li><p>友元关系不能被继承。</p></li><li><p>友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，类 A 不一定是类 B 的友元，要看在类中是否有相应的声明。</p></li><li><p>友元关系不具有传递性。若类 B 是类 A 的友元，类 C 是 B 的友元，类 C 不一定是类 A 的友元，同样要看类中是否有相应的申明。</p></li></ol><p>优点：</p><ul><li><p>可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务；</p></li><li><p>便于与其他不支持类概念的语言(如 C 语言、汇编等)进行混合编程；</p></li><li><p>通过使用友元函数重载可以更自然地使用 C++语言的 IO 流库。</p></li></ul><p>缺点：</p><ul><li>一个类将对其非公有成员的访问权限授予其他函数或者类，会破坏该类的封装性和信息隐蔽，降低该类的可靠性和可维护性。</li></ul><h1 id="malloc-函数">malloc 函数</h1><p><code>malloc</code> 函数的函数原型为：<code>void* malloc（unsigned int size）</code>，它根据参数指定的尺寸来分配内存块，并且返回一个<code>void</code>型指针，指向新分配的内存块的初始位置。如果内存分配失败（内存不足），则函数返回<code>NULL</code>。</p><p>关于返回值</p><p><code>malloc</code>的返回值为<code>void</code>*。我们在使用的时候，习惯对返回值进行强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><blockquote><p>以前的 C，因为没有 <code>void*</code> 这种类型，<code>malloc</code> 函数的返回值被简单地定义为 <code>char*</code>, 所以在使用 <code>malloc</code> 函数时通常需要对其返回值进行强制类型转换。现在 C 中，<code>malloc</code> 函数的返回值为<code>void*</code>。强制类型转换操作已经不需要了。</p></blockquote><blockquote><p>然而在 C++ 中，任何类型的指针都可以赋给 <code>void*</code>，而 <code>void*</code> 却不可以赋给其他类型的指针，所以在 C++ 中使用 <code>malloc</code> 函数的时候，强制类型转换是必须的。另一方面，在 C++ 中应该使用 <code>new</code> 来分配内存。</p></blockquote><p><strong>malloc 在堆上分配内存</strong></p><p><code>malloc</code> 函数分配的内存是在堆（<code>heap</code>）上的。</p><p>操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点, 然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序.</p><p>另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 <code>delete</code> 或 <code>free</code> 语句才能正确的释放本内存空间。我们常说的内存泄露，最常见的就是堆泄露（还有资源泄露），它是指程序在运行中出现泄露，如果程序被关闭掉的话，操作系统会帮助释放泄漏的内存。</p><p><strong>malloc 的使用</strong></p><p>malloc 函数使用起来倒是挺简单的，主要的使用范例有两种：</p><ul><li><p>一是动态分配结构体，通常用于被称为“链表”的数据结构中；</p></li><li><p>二是分配可变长度的数组。</p></li></ul><p>过程中的注意点：调用 <code>malloc</code> 函数后，应该对函数返回值进行检查。前面说过，内存分配一旦失败，<code>malloc()</code> 会返回 <code>NULL</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在程序结束时，应该调用 <code>free</code> 函数对 <code>malloc</code> 函数分配的内存进行释放。</p><p>实际上，C 语言标准没有规定要这么做，而且普通的 PC 操作系统，在进程结束时，肯定会释放曾经分配给当前进程的内存空间，也就是说，在程序结束之前，没有必要调用 <code>free()</code>。</p><p>但是，对于一串连续的程序处理事件，如果先前程序分配的内存没有及时释放掉，那后面的工作就遭殃了。所以 <code>malloc</code> 与 <code>free</code> 配套出现还是相当合理的。</p><p>从操作系统一次性地取得比较大的内存，当程序调用 <code>malloc()</code> 时，<code>malloc()</code> 便将内存”零售”给应用程序，这是 <code>malloc()</code> 的大体实现。而当这块一次性取出来的内存不够用的时候，就请求操作系统对空间进行扩容。多次调用 <code>malloc()</code> （导致内存不够用了）会调用一次 <code>brk()</code>，内存区域向地址较大的一方伸长。<code>malloc()</code>分配内存，会用到 <code>brk</code> (<em>用于小内存申请&lt;=128kb</em>，在堆上) 或<code>mmap2</code> (用于大内存申请，一般是堆和栈中间)系统调用 。</p><p>K&amp;R 中记录了<code>malloc()</code>最简单的一种实现方式：通过链表来实现。<code>malloc()</code>管理的空间不一定是连续的，空闲存储空间以空闲块链表的方式组织。在这种方式下，每个块之前都加上了一个管理区域，包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针。这些快按照储存地址的升序组织。最后一块（最高地址）指向第一块。</p><p>当有申请要求时，<code>malloc()</code> 将扫描空闲块链表，直到找到一块足够大的空闲块为止，如果找不到，则向操作系统申请一个大块并加入到空闲链表中。然而在这种内存管理方式的运行环境中，一旦数组越界检查发生错误，越过了 <code>malloc()</code> 分配的内存区域写入了数据，将会破坏下一个块的管理区域，容易造成程序崩溃。</p><h1 id="运算符重载">运算符重载</h1><ol type="1"><li><p><code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 分别是流插入运算符与流提取运算符，在使用的时候需要在本文件的模块中包含头文件 stream，还用过包含 "using namespace std;"。</p></li><li><p>运算符重载是定义一个重载运算符的函数，使指定的运算符不仅能实现原有的功能，而且也实现在函数中指定的新的功能。</p></li></ol><blockquote><p>在使用被重载的运算符，系统会自动调用该函数，以实现相应的功能。运算符重载是通过定义函数实现的。实质就是函数的重载。</p></blockquote><ol start="3" type="1"><li>一般格式：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符名称 （形参表）</span><br><span class="line">&#123;对运算符的重载处理&#125;</span><br></pre></td></tr></table></figure><p>Eg： <code>Complex operator + （complex &amp;c1 , complex &amp; c2）;</code></p><ol start="4" type="1"><li><p>规则：</p><ul><li><p>除了类属关系运算符 <code>.</code>、成员指针运算符 <code>*</code>、作用域运算符 <code>::</code>、sizeof 运算符和三目运算符 <code>? :</code> 以外，C++ 中的所有运算符都可以重载。</p></li><li><p>重载运算符不能创建新的运算符。</p></li><li><p>运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。</p></li><li><p>重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。</p></li><li><p>运算符重载不能改变该运算符用于内部类型对象的含义。</p></li></ul><blockquote><p>它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。其参数至少应该有一个是类对象（或者是类对象的引用）。</p></blockquote><ul><li><p>运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。</p></li><li><p>运算符重载不能有默认的参数，否则就改变了运算符参数的个数。</p></li><li><p>用于类对象的运算符一般必须重载，但是有两个例外，<code>=</code> 与 <code>&amp;</code>。赋值运算符 <code>=</code> 可以用于每一个类对象，利用它对同类对象间相互赋值。地址运算符 <code>&amp;</code> 可以返回类对象在内存中的起始地址。</p></li></ul></li><li><p>运算符重载函数的处理方式：</p><ol type="1"><li>作为类的成员函数。</li></ol><p>如果运算符重载函数为成员函数，它可以通过 <code>this</code> 指针自由的访问本来的数据成员，因此可以少写一个函数的参数。但是必须要求运算表达式的第一个参数为一个类对象，而且与运算符函数的类型相同。</p><ol start="2" type="1"><li>不是类的成员函数（可以是一个普通函数），在类内把它声明为友元函数（友元运算符重载函数）。</li></ol><p>将双目运算符重载为友元函数，由于友元函数不是该类的成员函数，因此在函数形参列表中必须有两个参数，不能省略。数学上的交换律在此不适用，所以需要运算符左侧的操作数与第一个参数对应，右侧的操作数与第二个参数对应。</p><ol start="3" type="1"><li><p>两种重载形式的比较, 一般将运算符重载为两种之一都可。但成员函数运算符与友元函数运算符也具有各自的一些特点：</p><ol type="1"><li>一般情况下，单目运算符重载为类的成员函数；双目运算符则重载为类的友元函数。</li><li>以下一些双目运算符不能重载为类的友元函数：<code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code>。</li><li>类型转换函数只能定义为一个类的成员函数。</li><li>若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。</li><li>若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。</li><li>当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现。</li><li>当需要重载运算符具有可交换性时，选择重载为友元函数</li></ol></li></ol></li><li><p>重载流插入运算符<code>&lt;&lt;</code>与流提取运算符<code>&gt;&gt;</code></p><p>C++ 的流插入运算符 <code>&lt;&lt;</code> 和流提取运算符 <code>&gt;&gt;</code> 是 C++ 在类库中提供的，</p><p>所有 C++ 编译系统都在类库中提供输入流类 <strong>istream</strong> 和输出流类 <strong>ostream</strong>。<code>cin</code> 和 <code>cout</code> 分别是 istream 类 和 ostream 类 的对象。</p><p>在类库提供的头文件中已经对 <code>&lt;&lt;</code> 和<code>&gt;&gt;</code> 进行了重载，使之作为流插入运算符和流提取运算符，能用来输出和输入 C++ 标准类型的数据。因此，凡是用 <code>cout&lt;&lt;</code> 和<code>cin&gt;&gt;</code> 对标准类型数据进行输入输出的，都要用 <code>#include</code> 把头文件包含到本程序文件中。</p><p>用户自己定义的类型的数据，是不能直接用 <code>&lt;&lt;</code> 和<code>&gt;&gt;</code> 来输出和输入的。如果想用它们输出和输入自己声明的类型的数据，必须对它们重载。对 <code>&lt;&lt;</code> 和<code>&gt;&gt;</code> 重载的函数形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;,自定义的类&amp;);</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;,自定义的类&amp;)；</span><br></pre></td></tr></table></figure><p>重载运算符 <code>&gt;&gt;</code> 的函数的第一个参数和函数的类型都必须是 <code>istream&amp;</code> 类型，第二个参数是要进行输入操作的类。重载 <code>&lt;&lt;</code> 的函数的第一个参数和函数的类型都必须是 <code>ostream&amp;</code> 类型，第二个参数是要进行输出操作的类。因此，只能将重载 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 的函数作为友元函数或普通的函数，而不能将它们定义为成员函数。</p><p>return output 的作用是什么？回答是能连续向输出流插入信息。output 是 ostream 类的对象，它是实参 cout 的引用，也就是 cout 通过传送地址给 output，使它们二者共享同一段存储单元，或者说 output 是 cout 的别名。因此，return output 就是 return cout，将输出流 cout 的现状返回，即保留输出流的现状。</p></li><li><p>优点：</p><p>通过运算符的重载，扩大了 C++ 已有的运算符的作用范围，使之能用于类对象。</p><p>把运算符与类结合起来，可以在 C++ 程序中定义出很有实用意义的而使用方便的新的数据类型，使 C++ 具有良好的扩充性与适应性。</p><p>在 C++ 中，运算符重载是很重要的、很有实用意义的。它使类的设计更加丰富多彩，扩大了类的功能和使用范围，使程序易于理解，易于对对象进行操作，它体现了为用户着想、方便用户使用的思想。有了运算符重载，在声明了类之后，人们就可以像使用标准类型一样来使用自己声明的类。类的声明往往是一劳永逸的，有了好的类，用户在程序中就不必定义许多成员函数去完成某些运算和输入输出的功能，使主函数更加简单易读。</p></li></ol><h1 id="转换构造函数">转换构造函数</h1><p>将一个其他类型的数据转换为类的对象。只有一个形参。也是一种构造函数，遵循构造函数的一般规则，通常把有一个参数的构造函数用作类型的转换，称为转换构造函数。</p><p>类型转换运算符函数（类型转换运算符重载函数）：将一个类的对象转换为另一个类型的数据。在函数名的前面不能指定函数类型，函数没有参数。其返回值的类型由函数名中指定的类型名来确定。只能成为成员函数，因为转换的主体的本类的对象，不能作为友元函数与普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Operate 类型名（）</span><br><span class="line">&#123;实现转换的语句&#125;</span><br></pre></td></tr></table></figure><p>如果运算符重载函数是成员函数，它的第一个参数必须是本类的对象。</p><p>一般将双目运算符函数重载为友元函数，单目运算符则对重载为成员函数。</p><h1 id="继承">继承</h1><p><strong>(1)  类与类之间的关系</strong></p><p>has-A，包含关系，用以描述一个类由多个“部件类”构成，实现 has-A 关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类。</p><p>use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现。</p><p>is-A，即继承关系，关系具有传递性。</p><p><strong>(2)  继承的相关概念</strong></p><p>万事万物皆有继承这个现象，所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类。</p><p>单继承：一个派生类只从一个基类派生。</p><p>多重继承：一个派生类有两个或者多个基类</p><p>基类与派生类的关系：基类是派生类的抽象，派生类是基类的具体化。基类综合了派生类的公共特征，派生类则在基类的基础上增加了某些特征，把抽象类变成具体的、实用的类型。</p><p><strong>(3)  派生类的声明方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class 派生类名：[继承方式] 基类名</span><br><span class="line">&#123;  派生类新增加的成员 &#125;；</span><br></pre></td></tr></table></figure><p>继承方式包括：公有继承，私有继承，保护继承。默认为私有继承。</p><p><strong>(4)  构造一个派生类需要完成的工作</strong></p><ol type="1"><li>从基类接受成员。（可能会造成数据的冗余）</li><li>调整从基类接受的成员。</li><li>在声明派生类时增加成员。</li></ol><!--例如改变基类成员在派生类中的访问属性。覆盖(Override)是指派生类中存在重新定义的函数，其函数名、参数列、返回值类型必须同父类中的相对应被覆盖的函数严格一致，覆盖函数和被覆盖函数只有函数体 （花括号中的部分）不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本，这种机制就叫做覆盖。--><p><strong>(5)  继承方式及访问属性</strong></p><p>1.  公用继承(public), 用公用继承方式建立的派生类称为公用派生类。其基类称为公用基类。</p><p>公有继承的特点是基类的<u>公有成员和保护成员</u>作为派生类的成员时，它们都保持<u>原有</u>的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。</p><p>2)  私有继承(private), 用私有继承方式建立的派生类称为私有派生类。其基类称为私有基类。</p><p>私有继承的特点是基类的<u>公有成员和保护成员</u>都作为派生类的<u>私有成员</u>，并且不能被这个派生类的子类所访问。私有基类的私有成员在派生类中称为不可访问的成员，只有基类的成员函数可以引用。</p><p>3)  保护继承(protected), 用保护继承方式建立的派生类称为保护派生类。其基类称为保护基类。</p><p>保护继承的特点是基类的所有<u>公有成员和保护成员</u>都成为派生类的<u>保护成员</u>，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。</p><p><strong>基类成员在派生类中的访问属性：</strong></p><table><thead><tr class="header"><th>继承方式</th><th>基类的 public 成员</th><th>基类的 protected 成员</th><th>基类的 private 成员</th></tr></thead><tbody><tr class="odd"><td>public 继承</td><td>仍为 public 成员</td><td>仍为 protected 成员</td><td>不可访问</td></tr><tr class="even"><td>Private 继承</td><td>变为 private 成员</td><td>变为 private 成员</td><td>不可访问</td></tr><tr class="odd"><td>Protected 继承</td><td>变为 Protected 成员</td><td>变为 Protected 成员</td><td>不可访问</td></tr></tbody></table><blockquote><p>注意：父类中的 private 成员依然存在于子类中，但是却无法访问到。不论何种方式继承父类，子类都无法直接使用父类中的 private 成员。如果需要在派生类中引用基类的某些成员，则应该将基类的这些成员声明为 protected。需要被外界访问的成员设置为 public；只能在当前类中访问设置为 private；</p></blockquote><p><strong>(6)  继承的特点</strong></p><ol type="1"><li>子类拥有父类的所有属性和方法（除了构造函数和析构函数）。</li><li>子类可以拥有父类没有的属性和方法。</li><li>子类是一种特殊的父类，可以用子类来代替父类。</li><li>子类对象可以当做父类对象使用。</li></ol><p><strong>(7)  继承中的构造和析构函数</strong></p><p>1）父类的构造和析构</p><p>当创建一个对象和销毁一个对象时，对象的构造函数和析构函数会相应的被 C++ 编译器调用。当在继承中，父类的构造和析构函数是如何在子类中进行调用的呢，C++ 规定在子类对象构造时，需要调用父类的构造函数完成对对继承而来的成员进行初始化，同理，在析构子类对象时，需要调用父类的析构函数对其继承而来的成员进行析构。</p><p>在派生类中定义派生类构造函数的一般形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名(基类所需的形参，本类成员所需的形参):基类构造函数名名(基类所需参数表)</span><br><span class="line">&#123;派生类中新增成员初始化语句 &#125;</span><br></pre></td></tr></table></figure><p>在派生类体外定义派生类构造函数的一般形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">派生类::派生类构造函数名(基类所需的形参，本类成员所需的形参):基类构造函数名名(基类所需参数表)</span><br><span class="line">&#123;派生类中新增成员初始化语句 &#125;</span><br></pre></td></tr></table></figure><p>2）父类中的构造和析构执行顺序</p><p>子类对象在创建时，会先调用父类的构造函数，如果父类还有父类，则先调用父类的父类的构造函数，依次往上。父类构造函数执行结束后，执行子类的构造函数。当父类的构造函数不是 C++ 默认提供的，则需要在子类的每一个构造函数上使用初始化列表的方式调用父类的构造函数。</p><blockquote><p>析构函数的调用顺序和构造函数的顺序相反。</p></blockquote><p><strong>(8)  从成员函数的角度来讲述重载和覆盖的区别</strong></p><p>成员函数被重载的特征有：</p><ol type="1"><li>相同的范围（在同一个类中）；</li><li>函数名字相同；</li><li>参数不同；</li><li><code>virtual</code> 关键字可有可无。</li></ol><p>覆盖的特征有：</p><ol type="1"><li>不同的范围（分别位于派生类与基类）；</li><li>函数名字相同；</li><li>参数相同；</li><li>基类函数必须有 <code>virtual</code> 关键字。</li></ol><p>分别位于派生类与基类的不同的成员函数，只有在函数名和参数个数相同。类型相匹配的情况下才发生同名覆盖，如果只有函数名相同，不会发生同名覆盖，而属于函数重载。</p><p>隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p><ol type="1"><li><p>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 <code>virtual</code> 关键字，基类的函数将被隐藏（注意别与重载混淆）。</p></li><li><p>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 <code>virtual</code> 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p></li></ol><p><strong>(9)  含有子对象的派生类构造函数</strong></p><p>类的数据成员中还可以包含类对象，如可以在声明一个类时包含这样的数据成员:</p><p><code>Student s1;// Student是已声明的类名，s1是Student类的对象</code></p><p>这时，s1 就是类对象中的内嵌对象，称为子对象(subobject)，即对象中的对象</p><p>派生类构造函数的任务应该包括 3 个部分:</p><ul><li>对基类数据成员初始化；</li><li>对子对象数据成员初始化；</li><li>对派生类数据成员初始化。</li></ul><p>定义派生类构造函数的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   派生类构造函数名（总参数表列）：基类构造函数名（参数表列），子对象名(参数表列)</span><br><span class="line">&#123;派生类中新增数成员据成员初始化语句&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    派生类构造函数名（总参数表列）：基类构造函数名（参数表列），子对象名(参数表列)，</span><br><span class="line">内置类型成员初始列表&#123;&#125;</span><br></pre></td></tr></table></figure><p>执行派生类构造函数的顺序是：</p><ul><li>调用子对象构造函数，对子对象数据成员初始化；</li><li>再执行派生类构造函数本身，对派生类数据成员初始化。</li></ul><p>执行派生类析构函数的顺序是：</p><ol type="1"><li>执行派生类自己的析构函数。</li><li>对派生类新增加的成员进行清理。</li><li>调用子对象的析构函数，对子对象进行清理。</li><li>最后调用基类的析构函数，对基类进行清理。</li></ol><p><strong>(10)  注意：</strong></p><p>当基类构造函数不带参数时，派生类不一定需要定义构造函数，然而当基类的析构函数哪怕只有一个参数，也要为派生类定义构造函数，甚至所定义的派生类析构函数的函数体可能为空，仅仅起到传递参数的作用.</p><p>当基类使用缺省构造函数或不带参数的构造函数时，则在派生类中定义构造函数时，可以省略：<code>基类构造函数名（参数表）</code>，此时若派生类不需要构造函数，则可以不定义构造函数。</p><p>如果派生类的基类也是一个派生类，则每个派生类只需负责其直接基类的构造，依次上溯。</p><p>如果析构函数是不带参数的，在派生类中是否要定义析构函数与它所属的基类无关，故基类的析构函数不会因为派生类没有析构函数而得不到执行，他们各自是独立的</p><p><strong>(11)  多重继承：</strong></p><p>在多重继承中，派生类的构造函数与单继承派生类构造函数相似，它必须负责该派生类所有基类构造函数以及对象成员（如果有的话）构造函数的调用。同时，派生类的参数必须包含完成所有基类、对象成员以及派生类中新增数据成员初始化所需的参数。</p><p>派生类构造函数执行顺序如下：</p><ol type="1"><li><p>所有基类的构造函数，多个基类构造函数的执行顺序<u>取决于</u>定义派生类时所指定的顺序，与派生类构造函数中所定义的成员初始化列表的参数顺序无关；</p></li><li><p>对象成员的构造函数；</p></li><li><p>派生类本省的构造函数。</p></li></ol><p>加上虚基类后，它的初始化在语法上与一般多继承的初始化是相同的，但在调用构造函数的顺序上有点差别:</p><ol type="1"><li><p>先调用虚基类构造函数，然后调用非虚基类的构造函数。</p></li><li><p>当同一层有多个虚基类，按照他们的声明顺序调用它们的构造函数；</p></li><li><p>当虚基类是由非虚基类派生时，则先调用基类构造函数，再调用派生类构造函数。</p></li></ol><p><strong>(12)  虚基类：</strong></p><p>如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员。引入虚基类，使得在继承间接共同基类的时候只保留一份成员。</p><p>现在，将类 A 声明为虚基类，方法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>//声明基类<span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>…&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A<span class="comment">//声明类B是类A的公用派生类，A是B的虚基类</span></span><br><span class="line">&#123;…&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A<span class="comment">//声明类C是类A的公用派生类，A是C的虚基类</span></span><br><span class="line">&#123;…&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类。</p></blockquote><p>声明虚基类的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> <span class="keyword">virtual</span> 继承方式 基类名</span><br></pre></td></tr></table></figure><p>经过这样的声明后，当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次。</p><p>注意: 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。</p><!--虚基类的初始化如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在其所有派生类(包括直接派生或间接派生的派生类)中，通过构造函数的初始化表对虚基类进行初始化。规定:在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化。C++编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类(如类B和类C)对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。--><p><strong>(13)  基类与派生类的转换：</strong></p><p>基类与派生类对象之间有赋值兼容关系，由于派生类中包含从基类继承的成员，因此可以将派生类的值赋给基类对象，在用到基类对象的时候可以用其子类对象代替。</p><ol type="1"><li>派生类对象可以向基类对象赋值。</li></ol><!--可以用子类(即公用派生类)对象对其基类对象赋值。只能用子类对象对其基类对象赋值，而不能用基类对象对其子类对象赋值，因为基类对象不包含派生类的成员，无法对派生类的成员赋值。同理，同一基类的不同派生类对象之间也不能赋值。--><ol start="2" type="1"><li><p>派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化。</p></li><li><p>如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象。</p></li><li><p>派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量也可以指向派生类对象。</p></li></ol><p><strong>(14)  类的组合：</strong></p><p>在一个类中以另一个类的对象作为数据成员。</p><h1 id="多态性">多态性</h1><p><strong>概念</strong>：指相同的对象收到不同的消息或者不同的对象收到相同的消息时产生的不同的实现动作。</p><p>C++支持两种多态：<em>编译时多态（静态）</em>、<em>运行时多态（动态）</em>。</p><p><strong>静态多态</strong>是通过函数的重载来实现的（运算符重载实际上也属于函数的重载）。要求在程序编译的时候就知道调用函数的全部信息。静态多态性的函数调用速度快、效率高、但是缺乏灵活性，在程序运行前就决定了执行的函数与方法。</p><p><strong>动态多态性</strong>是程序运行过程中才动态地确定操作所针对的对象，运行时多态性是通过虚函数来实现的。由虚函数实现的动态多态性就是：同一类族中不同类的对象，对同一函数调用作出不同的响应。</p><h1 id="虚函数">虚函数</h1><p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</p><p><strong>虚函数的使用方法是：</strong></p><ol type="1"><li><p>在基类用<code>virtual</code>声明成员函数为虚函数。</p></li><li><p>在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。在类外定义虚函数时，不必再加<code>virtual</code>。</p></li><li><p>在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。</p></li><li><p>C++ 规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。</p></li></ol><!--因此在派生类重新声明该虚函数时，可以加virtual，也可以不加，但习惯上一般在每一层声明该函数时都加virtual，使程序更加清晰。如果在派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数。--><ol start="5" type="1"><li><p>定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。</p></li><li><p>通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。</p></li></ol><!--通过虚函数与指向基类对象的指针变量的配合使用，就能方便地调用同一类族中不同类的同名函数，只要先用基类指针指向即可。如果指针不断地指向同一类族中不同类的对象，就能不断地调用这些对象中的同名函数。这就如同前面说的，不断地告诉出租车司机要去的目的地，然后司机把你送到你要去的地方。--><p>确认具体对象的过程叫关联(binding)，在这里指把一个函数与类对象捆绑在一起，建立关联。</p><p><strong>静态关联</strong>：函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联，由于是在运行前关联的，所以又叫早期关联。</p><p><strong>动态关联</strong>：在运行时，基类指针变量指向了某个类对象，然后通过这个基类指针去调用虚函数。由于是在运行时把虚函数与对象“绑定”在一起， 因此，此过程称为动态关联。由于动态关联是在编译后运行阶段进行的，所以又称为滞后关联。</p><p><strong>使用虚函数时的注意点：</strong></p><ol type="1"><li><p>只能用 <code>virtual</code> 声明类的成员函数，使他成为虚函数，而不能将类外的普通函数声明为虚函数。</p></li><li><p>一个成员函数在被声明为虚函数后，在同一类族中的类就不能定义一个非 <code>virtual</code> 的但是与该虚函数具有相同参数和返回值类型的函数。</p></li></ol><p><strong>怎么判断是否把一个成员函数声明为虚函数？</strong></p><ol type="1"><li><p>首先看成员函数所在的类是否会成为基类。然后看成员函数在类的继承后有无可能被改进功能，如果希望改变其功能的，一般把它声明为虚函数。</p></li><li><p>如果成员函数在类被继承后不被修改，或派生类用不到该函数，则不要把它声明为虚函数。</p></li><li><p>应该考虑对成员函数的调用是通过对象名还是通过基类指针或引用来访问，如果通过基类指针或引用来访问的，应该考虑用虚函数。</p></li><li><p>有时，在定义虚函数时，不定义其函数体，即函数体是空的。</p></li></ol><p>使用虚函数，系统有一定的开销，但一个类有虚函数时，编译系统会为该类创建一个虚函数表，它是一个指针数组，存放每个虚函数的入口地址。</p><p>当派生类的对象从内存中撤销时一般先调用派生类的析构函数，然后再调用基类的析构函数。</p><p>但是，如果用 new 运算符建立了临时对象，若基类中有析构函数，并且定义了一个指向该基类的指针变量。</p><p>在程序用带指针参数的 delete 运算符撤销对象时，会发生一个情况:系统会只执行基类的析构函数，而不执行派生类的析构函数。</p><p>当基类的析构函数为虚函数时，无论指针指的是同一类族中的哪一个类对象，系统会采用动态关联，调用相应的析构函数，对该对象进行清理工作。</p><p>如果将基类的析构函数声明为虚函数时，由该基类所派生的所有派生类的析构函数也都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。</p><p>最好把基类的析构函数声明为虚函数。这将使所有派生类的析构函数自动成为虚函数。</p><p>这样，如果程序中显式地用了 delete 运算符准备删除一个对象，而 delete 运算符的操作对象用了指向派生类对象的基类指针，则系统会调用相应类的析构函数。</p><p>虚析构函数的概念和用法很简单，但它在面向对象程序设计中却是很重要的技巧。</p><h1 id="纯虚函数声明">纯虚函数声明  </h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名 （参数表列） = <span class="number">0</span>；</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>纯虚函数没有函数体；</li><li>最后面的“=0”并不表示函数返回值为 0，它只起形式上的作用，告诉编译系统“这是虚函数”；</li><li>这是一个声明语句，最后有分号。</li></ul><blockquote><p>纯虚函数只有函数的名字而不具备函数的功能，不能被调用。 纯虚函数的作用是在基类中为其派生类保留一个函数的名字，以便派生类根据需要对他进行定义。如果在基类中没有保留函数名字，则无法实现多态性。 如果在一个类中声明了纯虚函数，在其派生类中没有对其函数进行定义，则该虚函数在派生类中仍然为纯虚函数。</p></blockquote><h1 id="抽象类">抽象类</h1><p>不用定义对象而只作为一种基本类型用作继承的类叫做抽象类（也叫接口类），凡是包含纯虚函数的类都是抽象类，抽象类的作用是作为一个类族的共同基类，为一个类族提供公共接口，抽象类不能实例化出对象。</p><p>纯虚函数在派生类中重新定义以后，派生类才能实例化出对象。</p><ul><li><p>一个基类如果包含一个或一个以上纯虚函数，就是抽象基类。抽象基类不能也没必要定义对象。</p></li><li><p>在类的层次结构中，顶层或最上面几层可以是抽象基类。抽象基类体现了本类族中各类的共性，把各类中共有的成员函数集中在抽象基类中声明。</p></li><li><p>抽象基类是本类族的共公共接口，即就是从同一基类中派生出的多个类有同一接口。</p></li></ul><p>总结：</p><ol type="1"><li><p>派生类重写基类的虚函数实现多态，要求函数名、参数列表、返回值完全相同。(协变除外)</p></li><li><p>基类中定义了虚函数，在派生类中该函数始终保持虚函数的特性。</p></li><li><p>只有类的非静态成员函数才能定义为虚函数，静态成员函数不能定义为虚函数。</p></li><li><p>如果在类外定义虚函数，只能在声明函数时加 virtual 关键字，定义时不用加。</p></li><li><p>构造函数不能定义为虚函数，虽然可以将 operator=定义为虚函数，但最好不要这么做，使用时容易混淆。</p></li><li><p>不要在构造函数和析构函数中调用虚函数，在构造函数和析构函数中，对象是不完整的，可能会出现未定义的行为。</p></li><li><p>虚表是所有类对象实例共用的虚表剖析。</p></li></ol><h1 id="输入流与输出流">输入流与输出流</h1><p>C++的输入与输出包括以下 3 方面的内容：</p><ol type="1"><li><p>对系统指定的标准设备的输入和输出。简称标准 I/O。(设备)</p></li><li><p>以外存磁盘(或光盘)文件为对象进行输入和输出。简称文件 I/0。(文件)</p></li><li><p>对内存中指定的空间进行输入和输出。简称串 I/O。(内存)</p></li></ol><p>缓冲区中的数据就是流，输入输出流被定义为类。C++的 I/0 库中的类称为流类(streamclass)。用流类定义的对象称为流对象。C++编译系统提供了用于输人输出的 iostream 类库。</p><p>由抽象基类 ios 直接派生出 4 个派生类，即 istream，ostream，fstreambase 和 strstreambase。</p><ul><li><p>fstreambase 是文件流类基类，由它再派生出 ifstream，ofstream 和 fstream。</p></li><li><p>strstreambase 是字符串流类基类，由它再派生出 lstrstream，ostrsCeam 和 swsWeam 类。</p></li></ul><p><strong>ostream 类定义了 3 个输出流对象，即 cout，cerr，clog。分述如下。</strong></p><h3 id="cout-流对象">cout 流对象</h3><blockquote><p>cout 是 console output 的缩写，意为在控制台(终端显示器)的输出。</p></blockquote><ol type="1"><li><p>cout 不是 C++预定义的关键字，它是 ostream 流类的对象，在 iostream 中定义。cout 流是流向显示器的数据。cout 流是容纳数据的载体。</p></li><li><p>用<code>cout&lt;&lt;</code>输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重载函数。</p></li><li><p>cout 流在内存中对应开辟了一个缓冲区，用来存放流中的数据。当向 cout 流插人一个 endl 时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符，并刷新流(清空缓冲区)。</p></li><li><p>在 iostream 中只对<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符对其进行输入输出，应该按照第 5 章介绍的方法，对<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符另作重载。</p></li></ol><h3 id="cerr-流对象">cerr 流对象</h3><blockquote><p>cerr 是 console error 的缩写，意为“在控制台(显示器)显示出错信息”。</p></blockquote><p>cerr 流对象是标准出错流。cerr 流已被指定为与显示器关联。cerr 的作用是向标准出错设备(standard error device)输出有关出错信息。</p><p>cerr 与标准输出流 cout 的作用和用法差不多。但有一点不同：cout 流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而 cerr 流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时应该用 cerr。cerr 流中的信息是用户根据需要指定的。</p><h3 id="clog-流对象">clog 流对象</h3><blockquote><p>clog 流对象也是标准出错流，它是 console log 的缩写。</p></blockquote><p>它的作用和 cerr 相同，都是在终端显示器上显示出错信息。它们之间只有一个微小的区别：ccrr 是不经过缓冲区，直接向显示器上输出有关信息，而 clog 中的信息存放在缓冲区中，缓冲区满后或遇 endl 时向显示器输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;</span><br><span class="line">out.open(<span class="string">&quot;file.txt&quot;</span>,ios::app)<span class="comment">//就是以追加内容的方式打开文件</span></span><br></pre></td></tr></table></figure><h3 id="标准输入流-cin-重点掌握的函数">标准输入流 cin 重点掌握的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.get()                 <span class="comment">//读入一个字符并返回它的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(一个参数)  <span class="comment">//读入一个字符并把它存储在ch</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(两个参数)  <span class="comment">//可以读取字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(三个参数)  <span class="comment">//可以读字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.getline()</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore()           <span class="comment">//读取字符并忽略指定字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.peek()            <span class="comment">//检查下一个输入的字符，不会把字符从流中移除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.putback()       <span class="comment">//返回一个字符给一个流</span></span><br></pre></td></tr></table></figure><h3 id="c和-c-的文件打开模式">C++和 C 的文件打开模式</h3><p><code>ios_base::ate</code>和<code>ios_base::app</code>都将文件指针指向打开的文件尾，二者的区别在于，<code>ios_base::app</code>模式只允许将数据添加到文件尾，而<code>ios_base::ate</code>模式将指针放到文件尾</p><table border="0" cellspacing="0"><tbody><tr><td><p align="center">C++模式</p></td><td><p align="center">C模式</p></td><td><p align="center">含义</p></td></tr><tr><td><p align="center">ios_base::in</p></td><td><p align="center">"r"</p></td><td><p align="center">打开以读取</p></td></tr><tr><td><p align="center">ios_base::out</p></td><td><p align="center">"w"</p></td><td><p align="center">等价于ios_base::out | ios_base::trunc</p></td></tr><tr><td><p align="center">ios_base::out | ios_base::trunc</p></td><td><p align="center">"w"</p></td><td><p align="center">打开以写入，如果已存在，则截短文件</p></td></tr><tr><td><p align="center">ios_base::out | ios_base::app</p></td><td><p align="center">"a"</p></td><td><p align="center">打开以写入，只追加</p></td></tr><tr><td><p align="center">ios_base::out | ios_base::in</p></td><td><p align="center">"r+"</p></td><td><p align="center">打开以读写，在文件允许的位置写入</p></td></tr><tr><td><p align="center">ios_base::out | ios_base::in | ios_base::trunc</p></td><td><p align="center">"w+"</p></td><td><p align="center">打开以读写，如果已存在，则截短文件</p></td></tr><tr><td><p align="center">c++mode | ios_base::binary</p></td><td><p align="center">"cmodeb"</p></td><td><p align="center">以C++mode（或相应的cmode）和二进制模式打开；例如，ios_base::in|ios_base::binary成为"rb"</p></td></tr><tr><td><p align="center">c++mode | ios_base::ate</p></td><td><p align="center">"cmode"</p></td><td><p align="center">以指定的模式打开，并移至文件末尾。C使用一个独立的函数调用，而不是模式编码。例如，ios_base::in|ios_base::ate被转换为"r"模式和C函数调用feek(file, 0, SEEK_END)</p></td></tr></tbody></table><h3 id="要获取一行输入">要获取一行输入</h3><p>有两种选择：成员函数 get()、getline()。</p><p>两个函数都是有三个参数：指向存储结果缓冲区的指针、缓冲区大小（不能超过其限度）和知道什么时候停止输入的终止符。终止符有一个经常用到的缺省值‘’。两个函数遇到输入终止符时，都把零存储在结果缓冲区里。</p><p>它们的区别如下：</p><ol type="1"><li><p>get()遇到输入流的分隔符就停止，而不从输入流中提取分隔符。如果用相同的分隔符再调用一次 get()函数，它会立即返回而不带任何输入。</p></li><li><p>getline()与其相反，它从输入流中提取分隔符，但仍没有把存储在结果缓冲区里。</p></li></ol><blockquote><p>总之，当我们在处理文本文件时，无论什么时候需要读出一行，都会想到 getline()函数。</p></blockquote><h3 id="命名空间">命名空间</h3><p>命名空间是 ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。</p><p>在  C 语言中定义了 3 个层次的作用域，即文件(编译单元)、函数和复合语句。C++又引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。</p><p>命名空间，实际上就是一个由程序设计者命名的内存区域。程序设计者可以根据需要制定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AA</span><br><span class="line">&#123;<span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;&#125;</span><br></pre></td></tr></table></figure><p><code>namespace</code>是定义命名空间锁必须写的关键字，<code>AA</code>是自己制定的命名空间的名字。如果在程序中要使用<code>a</code>和<code>b</code>，必须加上命名空间名和作用域分辨符<code>::</code>，如<code>AA::a</code>，<code>AA::b</code>，这种用法称为命名空间限定。</p><p>命名空间的作用是建立一些互相分隔的作用域，把一些全局实体分隔开来，以免产生名字冲突。</p><p>在引用命名空间成员时，要用命名空间名和作用域分辨符对命名空间成员进行限定，以区别不同的命名空间中的同名标识符。即： <code>命名空间名::命名空间成员名</code></p><p>标准 C++库中的所有标识符都是在一个名为 std 的命名空间中定义的，或者说标准头文件中的函数、类、对象和模板实在命名空间 std 中定义的。一般用 using namespace 语句对命名空间 std 进行声明，这样可以不必对每个命名空间成员一一进行处理，在文件的开头加入如下语句： <code>using namespace std;</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Interesting plugin in linux</title>
      <link href="2020/05/03/017-linux-plugin/"/>
      <url>2020/05/03/017-linux-plugin/</url>
      
        <content type="html"><![CDATA[<p>If you are a programer, then you must know the Linux system. Even it's your main working environment. So can we have some <strong>interesting</strong>?</p><p>Next, I will introduce a few software that is interesting under <strong>Linux</strong>. Different Linux distributions may have different installation methods, the following installations use <code>Arch</code> as an example.</p><h1 id="figlet">FIGLET</h1><p>FIGLET --display large characters made up of ordinary screen characters.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S figlet</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">figlet hello world</span><br><span class="line"></span><br><span class="line">watch -n1 &quot;date &#x27;+%D%n%T&#x27;|figlet -k&quot;   # terminal clok</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/figlet.png" alt="figlet" /><figcaption aria-hidden="true">figlet</figcaption></figure><h1 id="toilet">TOILET</h1><p>TOIlet --display large colourful characters.</p><p>TOIlet prints text using large characters made of smaller characters. It is similar in many ways to FIGlet with additional features such as Unicode handling, colour fonts, filters and various export formats.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S toilet</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toilet -f mono12 &quot;Takio&quot;</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/toilet.png" alt="toilet" /><figcaption aria-hidden="true">toilet</figcaption></figure><h1 id="neofetch">NEOFETCH</h1><p>Neofetch --A fast, highly customizable system info script</p><p>Neofetch is a CLI system information tool written in BASH. Neofetch displays information about your system next to an image, your OS logo, or any ASCII file of your choice.</p><p><em>NOTE: Every launch flag has a config option.</em></p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S neofetch</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neofetch</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/neofetch.png" alt="neofetch" /><figcaption aria-hidden="true">neofetch</figcaption></figure><h1 id="sl">SL</h1><p>sl - cure your bad habit of mistyping</p><p>sl is a highly advanced animation program for curing your bad habit of mistyping.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sl</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sl</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/sl.png" alt="sl" /><figcaption aria-hidden="true">sl</figcaption></figure><h1 id="asciiquarium">ASCIIQUARIUM</h1><p>asciiquarium --Show a beautiful dynamic aquarium in terminal.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S asciiquarium</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asciiquarium</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/quarium.png" alt="asciiquarium" /><figcaption aria-hidden="true">asciiquarium</figcaption></figure><h1 id="cowsay">COWSAY</h1><p>cowsay/cowthink --configurable speaking/thinking cow (and a bit more)</p><p>Cowsay generates an ASCII picture of a cow saying something provided by the user. If run with no arguments, it accepts standard input, word-wraps the message given at about 40 columns, and prints the cow saying the given message on standard output.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S cowsay</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cowsay &quot;hello world&quot;</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/cowsay.png" alt="cowsay" /><figcaption aria-hidden="true">cowsay</figcaption></figure><h1 id="cmatrixs">CMATRIXS</h1><p>CMatrix --Shows a scrolling 'Matrix' like screen in Linux</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S cmatrixs</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmatrixs</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/cmatrixs.png" alt="cmatrixs" /><figcaption aria-hidden="true">cmatrixs</figcaption></figure><h1 id="lolcat">LOLCAT</h1><p>lolcat --rainbow coloring effect for text console display</p><p>This manual page documents briefly the lolcat command.</p><p>lolcat is a program that concatenates files, or standard input, to standard output (like the generic cat), and adds rainbow coloring to it.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S lolcat</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neofetch | lolcat</span><br><span class="line"></span><br><span class="line">cowsay -dragon &quot;hello world&quot; | lolcat</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/lolcat-1.png" alt="lolcat-demo-1" /><figcaption aria-hidden="true">lolcat-demo-1</figcaption></figure><figure><img src="/images/linux-plugin/lolcat-2.png" alt="lolcat-demo-2" /><figcaption aria-hidden="true">lolcat-demo-2</figcaption></figure><h1 id="oneko">ONEKO</h1><p>oneko --The program oneko creates a cute cat chasing around your mouse cursor.</p><p>oneko changes your mouse cursor into mouse and creates a little cute cat and the cat start chasing around your mouse cursor. If the cat catchup the <em>mouse</em>, start sleeping.</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S oneko</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneko -speed 15</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/oneko.png" alt="oneko" /><figcaption aria-hidden="true">oneko</figcaption></figure><h1 id="fortune">FORTUNE</h1><p>fortune --print a random, hopefully interesting, adage</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fortune</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fortune</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/fortune.png" alt="fortune" /><figcaption aria-hidden="true">fortune</figcaption></figure><h1 id="rev">REV</h1><p>rev --reverse lines characterwise</p><p><strong>Install</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S rev-plugins</span><br></pre></td></tr></table></figure><p><strong>Display</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rev</span><br></pre></td></tr></table></figure><figure><img src="/images/linux-plugin/rev.png" alt="rev" /><figcaption aria-hidden="true">rev</figcaption></figure><hr /><blockquote><p>To be continued ...</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fish shell, young people&#39;s shell</title>
      <link href="2020/05/02/016-Fish-shell-use/"/>
      <url>2020/05/02/016-Fish-shell-use/</url>
      
        <content type="html"><![CDATA[<h1 id="whats-fish">what's fish?</h1><p>fish is a smart and user-friendly command line shell for macOS, Linux, and the rest of the family. fish includes features like syntax highlighting, autosuggest-as-you-type, and fancy tab completions that just work, with no configuration required.</p><figure><img src="/images/fish-shell-use/fish-shell.png" alt="fish shell" /><figcaption aria-hidden="true">fish shell</figcaption></figure><h1 id="how-to-install">how to install?</h1><p>Installing <code>fish</code> is really easy. If you are <strong>Linux</strong> or <strong>MaxOS</strong>, your system has its own package manager, you can use it. But different system may be different package managers.</p><p>Like me, type in the command line:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fish</span><br></pre></td></tr></table></figure><p>On Windows 10, fish can be installed under the WSL Windows Subsystem for Linux with <code>sudo apt install fish</code> or from source with the instructions below. Fish can also be installed on all versions of Windows using <a href="https://cygwin.com/">Cygwin</a>(from the Shells category).</p><p>If there is a problem during the installation, you can check the <a href="https://github.com/fish-shell/fish-shell">github of fish</a>. After you install it, enter <code>fish</code> on the command line to start using it, and it is already easy to use.</p><p><strong>Make it the default shell</strong></p><p>When you use it for a while, and you like it very much. You want to set it as the default shell, how to do it?</p><p>It's very easy, just do that:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/local/bin/fish</span><br></pre></td></tr></table></figure><p><code>chsh</code> will prompt you for your password and change your default shell. (Substitute <code>/usr/local/bin/fish</code> with whatever path fish was installed to, if it differs.) Log out, then log in again for the changes to take effect.</p><h1 id="customize-your-fish">Customize your fish</h1><p>Now you fall in love with <code>fish</code>, you want to make it a little different.</p><p>If you have a graphical interface, enter <code>fish_config</code> on the command line to setting you <code>fish</code>. Like this:</p><figure><img src="/images/fish-shell-use/fish_config.png" alt="fish_config" /><figcaption aria-hidden="true">fish_config</figcaption></figure><p>You think this is not enough, you want to make your <code>fish</code> more special. Then you can use <code>oh-my-fish</code>.</p><p><code>oh-my-fish</code> provides core infrastructure to allow you to install packages which extend or modify the look of your shell. It's fast, extensible and easy to use. You can enter its github from <a href="https://github.com/oh-my-fish/oh-my-fish">here</a>.</p><p>I install <code>oh-my-fish</code> use git, like this:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/oh-my-fish/oh-my-fish</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> oh-my-fish</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/install --offline</span></span><br></pre></td></tr></table></figure><p>Use <code>omf</code> to use it. <code>oh-my-fish</code> offers interesting plugins and a lot of themes.</p><p><strong>Theme</strong></p><p>You can use <code>omf theme</code> to view installed and all themes. <code>omf install &lt;theme name&gt;</code> to install theme. <code>omf theme &lt;theme name&gt;</code> to use the theme of you choice.</p><p>Look at the preview at the beginning of this article, that is the theme I used. You can preview more themes <a href="https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md">here</a>.</p><p><strong>Plugin</strong></p><p>Here we recommend a plugin to check the weather in the terminal.</p><p>Install through <code>omf install wttr</code>, use through <code>wttr</code>. <img src="/images/fish-shell-use/wttr.png" alt="wttr" /></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to make Hexo support mathematical formulas</title>
      <link href="2020/04/30/015-How-to-math/"/>
      <url>2020/04/30/015-How-to-math/</url>
      
        <content type="html"><![CDATA[<p>Mathematical formulas are often used when we blog. But we will find bugs in Hexo's support for mathematical formulas.</p><p>By default, Hexo uses the <code>hexo-render-marked</code> engine to render web pages. This engine will convert some special <code>markdown</code> symbols into corresponding <code>html</code> tags.</p><p>When we write mathematical formulas in Latex-like format, some meaningful symbols will conflict with the engine. We can solve this problems by replacing the engine.</p><p>Download <code>pandoc</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S Pandoc</span><br></pre></td></tr></table></figure><p>Install <code>hexo-renderer-pandoc</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>Redeploy blog</p><p><span class="math display">\[\left(x^{2}+y^{2}-1\right)^{3}=x^{2}y^{3}\]</span></p><p><span class="math display">\[x_1, x_2, ..., x_n\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to build your blog use hexo + github</title>
      <link href="2020/04/29/014-How-to-build-your-blog/"/>
      <url>2020/04/29/014-How-to-build-your-blog/</url>
      
        <content type="html"><![CDATA[<p>Building a personal blog is simpler than it seems</p><a id="more"></a><h2 id="introduction">Introduction</h2><p>Today, we can't live without th Internet, and we can do a lot of things on it. For example, write something.</p><p>Ok, next I will tell you how to build a personal blog that belongs to you, and now it's actually very simple. We will use <code>hexo</code> and <code>github</code>. So I should introduce them to you.</p><p>First, let's talk about <code>github</code>. <strong>Github</strong> is where people build sofware, and more than 40 million people use github ti discover, fork, and contribute to over 100 million projects. Here we will use github to do our blog server.</p><p>Next, let's talk about <code>hexo</code>. <strong>Hexo</strong> is a static blog framework based on <code>Node.js</code>. It has few dependencies and is easy to install and use. It can easily generate static web pages and be hosted on Github and Heroku.</p><h2 id="just-do-it">Just do it</h2><h4 id="create-warehouse">Create warehouse</h4><p>Log in to github first, if you don't have an account then go and register one. Next, create a new warehouse, the name of the warehouse must be like: <code>&lt;github username&gt;.github.io</code>.</p><p>Since you need to push files to github, don’t forget to install git. If you are using a <strong>Linux</strong> or <strong>macos</strong> system, you may easily install it in the terminal, <em>like</em>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p><em>or like</em>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S git</span><br></pre></td></tr></table></figure><p>If these do not work, you can find the corresponding command for you system distribution on the Internet.</p><p>If you are using windows, then you may need to go to git’s official website to download it.</p><h4 id="configure-hexo">Configure Hexo</h4><p><strong>Hexo</strong> based on <code>Node.js</code>, so we need to install Node.js. As before, <strong>Linux</strong> and <strong>macos</strong> can be easily installed by command, like:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nodejs</span><br></pre></td></tr></table></figure><p>Please go to the official website to <a href="https://nodejs.org/en/download/">download</a>, if you are <strong>windows</strong>.</p><p>Don't forget to check after installation.The command aret <code>node -v</code> and <code>npm -v</code></p><blockquote><p>NPM is a package management tool installed with <code>Node.js</code>, which can solve many problems in <code>Node.js</code> code deployment.Common usage scenarios are as follows:</p><ul><li>allow users to download third-party packages written by others from the NPM server for local use.</li><li>allow users to download and install command line programs written by others from the NPM server for local use.</li><li>allow users to upload their own packages or command line programs to the NPM server for others to use. The new version of <code>Node.js</code> has integrated npm.</li></ul></blockquote><p>After doing this, we can finally start to install <code>hexo</code>, we just use this command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>This installation takes a long time to wait patiently. When the installation is complete, initialize our blog,this command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>Then you will find that there is a <code>blog</code> folder in the current directory, let's go in. It's almost the same here, but we want to deploy to <code>github</code>, so we need to do some configuration. Edit <code>blog/_config.yml</code>, modify like these:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:zlj-zz/zlj-zz.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>After modifying the configuration file, we install the git deployment plugin to deploy.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>before start:</p><p>You need to add sshkey to your github account.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure><p>check it at <code>~/.ssh/id_rsa.pub</code></p><p>start deploy:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>If there is no error in executing the command, then the website is deployed. Let's open the browser to visit it, <a href="#">https://&lt;github username&gt;.github.io</a></p><p><strong>Let's look at some common command of <code>hexo</code>.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g # install hexo</span><br><span class="line">npm update hexo -g # update hexo</span><br><span class="line">hexo init # initialize</span><br><span class="line"></span><br><span class="line">hexo n &quot;your blog&quot; == hexo new &quot;your blog&quot; # new article</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><h2 id="choose-theme">Choose theme</h2><p>We can change the theme of the blog, you can find many themes <a href="https://hexo.io/themes/">here</a> and choose to use. The theme I use is <a href="https://github.com/gaoryrt/hexo-theme-pln">hexo-theme-pln</a>.</p><p><strong>Download theme like this:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gaoryrt/hexo-theme-pln.git themes/pln</span><br></pre></td></tr></table></figure><p>Edit <code>blog/_config.yml</code>, modify like these to use theme:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">pln</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概论总结笔记</title>
      <link href="2020/04/15/013-Introduction-to-Database-Principle-note/"/>
      <url>2020/04/15/013-Introduction-to-Database-Principle-note/</url>
      
        <content type="html"><![CDATA[<p>I have recently studied the database again, so take a note</p><a id="more"></a><h1 id="第一章-绪论">第一章 绪论</h1><h4 id="数据管理技术的发展阶段">1. <strong>数据管理技术的发展阶段</strong> :</h4><ul><li>人工管理阶段</li><li>文件系统阶段</li><li>数据库阶段</li></ul><p><em>其中文件阶段到数据库阶段是质的飞跃.</em></p><h4 id="名词概念">2. <strong>名词概念</strong></h4><ul><li>数据 描述事务的符号被称为数据.</li><li>DB DataBase 数据库,是长期存储在计算机内,有组织,可共享的大量数据集合.</li><li>DBMS 数据库管理系统.</li><li>DBS 数据库系统,由 DB+DBMS+应用程序+数据库管理员(DBA)</li></ul><table><thead><tr class="header"><th></th><th><strong>人工管理阶段</strong></th><th><strong>文件系统阶段</strong></th><th><strong>数据库系统阶段</strong></th></tr></thead><tbody><tr class="odd"><td><em>背景</em></td><td></td><td></td><td></td></tr><tr class="even"><td><strong>应用背景</strong></td><td>科学计算</td><td>科学计算,数据管理</td><td>大规模数据管理</td></tr><tr class="odd"><td><strong>硬件背景</strong></td><td>无直接存储设备</td><td>硬盘,磁鼓</td><td>大容量磁盘,磁盘阵列</td></tr><tr class="even"><td><strong>软件背景</strong></td><td>没有操作系统</td><td>有文件系统</td><td>有数据库管理系统</td></tr><tr class="odd"><td><strong>处理方式</strong></td><td>批处理</td><td>联机实时处理,批处理</td><td>联机实时处理,批处理,分布处理</td></tr><tr class="even"><td><em>特点</em></td><td></td><td></td><td></td></tr><tr class="odd"><td><strong>数据管理者</strong></td><td>用户(程序员)</td><td>文件系统</td><td>数据库管理系统</td></tr><tr class="even"><td><strong>数据面向的对象</strong></td><td>应用程序</td><td>应用</td><td>现实世界(如:一个企业)</td></tr><tr class="odd"><td><strong>数据的共享程度</strong></td><td>无共享,冗余度最大</td><td>共享性差,冗余度大</td><td>共享性高,冗余度小</td></tr><tr class="even"><td><strong>数据的独立性</strong></td><td>不独立,完全依赖程序</td><td>独立性差</td><td>高度物理独立性和一定逻辑独立性</td></tr><tr class="odd"><td><strong>数据的结构化</strong></td><td>无结构</td><td>记录内有结构,整体无结构</td><td>整体结构化,模型描述</td></tr><tr class="even"><td><strong>数据控制能力</strong></td><td>程序控制</td><td>程序控制</td><td>数据管理系统</td></tr></tbody></table><p><strong>数据模型</strong> :对现实数据特征的抽象 (现实世界-&gt;信息时间诶-&gt;机器世界)</p><h4 id="数据模型的基本概念关系模型">3. 数据模型的基本概念(关系模型)</h4><table><thead><tr class="header"><th>名次</th><th>英文名</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>实体</td><td>enity</td><td>客观存在并可相互区别的事物</td></tr><tr class="even"><td>属性</td><td>attribute</td><td>实体所具有的某一特性</td></tr><tr class="odd"><td>码</td><td>key</td><td>唯一标识实体的属性称为码</td></tr><tr class="even"><td>实体型</td><td>entitty</td><td>用实体名及其属性名集合来抽象和刻画同类实体</td></tr><tr class="odd"><td>实体集</td><td>enityset</td><td>同一类实体的集合</td></tr><tr class="even"><td>联系</td><td>relationship</td><td>实体内部联系常指组成实体的各属性之间的联系,实体之间的联系指不同实体集之间的联系</td></tr><tr class="odd"><td>联系的种类</td><td></td><td>一对一,一对多,多对多</td></tr><tr class="even"><td>关系</td><td>relation</td><td>一对关系对应一张表</td></tr><tr class="odd"><td>元组</td><td>tuple</td><td>表中一行为一个元组</td></tr><tr class="even"><td>属性</td><td>attitude</td><td>表中一列为一个属性</td></tr><tr class="odd"><td>码</td><td>key</td><td>又称码键,表中的某一个属性可以唯一确认一个元组</td></tr><tr class="even"><td>域</td><td>domain</td><td>具有相同数据类型的值的集合</td></tr><tr class="odd"><td>分量</td><td></td><td>元组中的一个属性值</td></tr><tr class="even"><td>关系模式</td><td></td><td>对关系的表述,一般表示为:关系名(attitude1, attitude2 ...)</td></tr></tbody></table><h4 id="数据模型分类.">4. 数据模型分类.</h4><p><strong>根据应用不同,第一类是概念模型,第二类是逻辑模型和物理模型</strong>.</p><ul><li><strong>概念模型</strong> :也称为信息模型,是按用户的观点来对数据和信息建模,主要用于数据库设计.其中一种表示方法: <em>实体-联系方法</em>又称 <code>E-R</code> 方法, 使用 <code>E-R</code> 图实现.</li><li><strong>逻辑模型</strong> :主要包括 层次模型 网状模型 关系模型,另外还有 面象对象数据模型 对象关系模型 半结构化模型 等,是按计算机系统的观点对数据建模,主要用于数据库管理系统的实现.</li><li><strong>物理模型</strong> :是对数据最底层的抽象,它描述数据在系统内部的表示方式和存储方法,或在磁盘或磁带上的存储方式和存取方法,是面向计算机的.</li></ul><p><strong>层次模型</strong></p><pre><code>定义:    1. 有且只有一个节点没有双亲节点    2. 根以外其他节点有且只有一个双亲节点优点:    1. 数据结构较清晰    2. 查询效率高    3. 提供了良好的完整性支持缺点:    1. 现实世界大多不是层次关系    2. 查询子女节点必须通过双亲节点    3. 结构过于严密,层次命令趋于程序化</code></pre><p><strong>网状模型</strong></p><pre><code>定义:    1. 允许一个以上的节点无双亲节点    2. 一个节点可有多于一个的双亲节点优点:    1. 更直接的描述世界    2. 具有良好的性能,存取效率高缺点:    1. 结构较复杂    2. 需要嵌入高级语言,用户不易掌握,不易使用    3. 记录之间的联系通过存取路径实现,因此用户必须了解系统结构的细节</code></pre><p><strong>关系模型</strong></p><pre><code>定义:    要求关系必须是规范化的,即每一个分量不可再分优点:    1. 建立在严格的数学概念上    2. 概念单一,数据结构简单,清晰    3. 存取路径对用户透明,数据的独立性,安全保密性更好缺点:    查询效率低,需要优化</code></pre><h4 id="数据模型">5. 数据模型</h4><p><strong>组成要素: <code>数据结构</code>+<code>数据操作</code>+<code>数据完整行约束条件</code></strong></p><ul><li>数据结构: 描述数据库的组成对象及对象之间的联系.</li><li>数据操作: 指对数据库中各种对象的实例(值)允许执行的操作的集合,包括操作及有关的操作规则.</li><li>完整性约束条件: 是一组完整性规则.</li></ul><h4 id="三级结构模式">6. 三级结构模式</h4><p><strong>数据库的体系结构分为三级: <code>内部级</code>, <code>概念级</code>和<code>外部级</code>.</strong></p><ul><li>模式(概念级): 是数据库中全体数据的逻辑结构和特征的描述,是所有用户的公共数据视图.</li><li>外模式(外部级): 能够看见和使用的局部数据的逻辑结构和特征的描述,是数据库用户的数据视图.</li><li>内模式(内部级): 也称为存储模式,一个数据库只有一个内模式,最接近物理存储,涉及到实际数据存储的结构,是数据在数据库内部的组织方式.</li></ul><h4 id="两层映像">7. 两层映像</h4><p>(<strong>保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性</strong>)</p><ul><li><p>模式/内模式映像: 用于定义概念模式和内模式之间的对应性.一般在内模式中描述.</p></li><li><p>外模式/模式映像: 用于定义外模式和概念模式之间的对应性.一般在外模式中描述.</p></li></ul><h4 id="两级数据独立性">8. 两级数据独立性</h4><ul><li>物理数据独立性:修改内模式时尽量不影响概念模式及外模式,则达到物理数据独立性.</li><li>逻辑数据独立性: 修改概念模式时尽量不影响外模式和应用程序.</li></ul><h4 id="硬件平台及数据库">9. 硬件平台及数据库</h4><ul><li>要足够大的内存</li><li>足够大的磁盘或磁盘阵列等设备存放数据库,作数据备份</li><li>系统有较高的通道能力,以提高数据传送效率</li></ul><h4 id="软件">10. 软件</h4><ul><li>DBMS</li><li>支持 DBMS 的 OS</li><li>相应的高级语言操作数据库</li><li>以 DBMS 为核心的开发工具</li></ul><h4 id="人员">12. 人员</h4><ul><li>DMA:<ol type="1"><li>决定数据库的信息内容和结构.</li><li>决定数据库的存储结构和存取策略.</li><li>定义数据的安全性要求和完整约束条件.</li><li>监控数据库的运行和使用.</li><li>数据库的改进和重构.</li></ol></li><li>系统分析员和数据库设计人员</li><li>应用程序人员</li></ul><h1 id="第二章-关系数据库">第二章 关系数据库</h1><h2 id="一.关系模型">一.关系模型</h2><blockquote><p>可形式化表示为 <code>R(U, D, DOM, F)</code><br> <code>R</code> 为关系名，<code>U</code> 为属性名集合，<code>D</code> 为 <code>U</code> 中属性所来自的域<br> <code>DOM</code> 为属性向域的映像集合，<code>F</code> 为属性间数据的依赖关系集合<br> 关系模型只包含单一的数据结构——关系（是笛卡尔积的有限子集）<br> 用户看来其中的数据逻辑结构是一张扁平的二维表<br></p></blockquote><h4 id="码">1. 码</h4><p><strong>由一个或几个属性组成</strong></p><ul><li>候选码: 可以唯一标识每一组的属性组</li><li>主码: 用户选做元组标识的一个候选键位主键</li><li>外码: 某个关系的主码相应的属性在另一关系中出现,此时主键就是另一个关系的外码</li></ul><h4 id="三种关系类型">2. 三种关系类型</h4><ol type="1"><li>基本关系(或基表,是实际存在的表,实际存储数据的逻辑表示),</li><li>查询表(是查询结果对应的表),</li><li>视图表(是由基本表或其他试图表导出,是虚表).</li></ol><h4 id="基本关系的六条性质">3. 基本关系的六条性质</h4><ol type="1"><li>列是同质的</li><li>不同列可出自同一域</li><li>列的顺序无所谓</li><li>行的顺序无所谓</li><li>任意两个元组的候选码不能同值</li><li>分量必须是原子值,即每一个分量都是比不可分的</li></ol><h2 id="二.关系完整性">二.关系完整性</h2><blockquote><p>关系模型有三类: <code>实体完整性</code>, <code>参照完整性</code>, <code>用户定义完整性</code>.前两个必须满足,称为关系的两个不变性.</p></blockquote><ul><li>实体完整性规则: 要求关系中组成主码的属性不能有空值</li><li>参照完整性规则: 要求不引用不存在的实体,但可以空值</li><li>用户自定义完整性规则: 有具体应用环境决定,系统提供定义和检验这类完整性的机制</li></ul><h2 id="三.关系代数">三.关系代数</h2><blockquote><p>一种抽象的查询语言,是对关系运算来表达查询</p></blockquote><table><thead><tr class="header"><th>符号</th><th>∪</th><th>∩</th><th>-</th><th>×</th><th>σ</th><th>Π</th><th>⋈</th><th>÷</th></tr></thead><tbody><tr class="odd"><td>含义</td><td>并</td><td>交</td><td>差</td><td>迪卡尔积</td><td>选择</td><td>投影</td><td>连接</td><td>除</td></tr></tbody></table><p><em>注:前四个<code>集合运算</code>, 后四个<code>关系运算</code></em></p><p>设关系 <span class="math inline">\(R\)</span> 关系 <span class="math inline">\(S\)</span> 具有相同的目 <span class="math inline">\(n\)</span> (即两个关系都有 <span class="math inline">\(n\)</span> 个属性)，且相应的属性取自同一个域， <span class="math inline">\(t\)</span> 是元组变量， <span class="math inline">\(t\in R\)</span> 表示 <span class="math inline">\(t\)</span> 是 <span class="math inline">\(R\)</span> 的一个元组。</p><ul><li><p>关系 <span class="math inline">\(R\)</span> 与关系 <span class="math inline">\(S\)</span> 的<strong>并(union)</strong>记作：<span class="math inline">\(R \bigcup S=\{ t| t \in R \bigvee t \in S \}\)</span>，其结果仍为 <span class="math inline">\(n\)</span> 目关系，由属于 <span class="math inline">\(R\)</span> 或属于 <span class="math inline">\(S\)</span> 的元组组成。</p></li><li><p>关系 <span class="math inline">\(R\)</span> 与关系 <span class="math inline">\(S\)</span> 的<strong>差(except)</strong>记作：<span class="math inline">\(R-S=\{ t| t \in R \bigwedge t \notin S \}\)</span>，其结果仍未 <span class="math inline">\(n\)</span> 目关系，由属于 <span class="math inline">\(R\)</span> 而不属于 <span class="math inline">\(S\)</span> 的所有元组组成。</p></li><li><p>关系 <span class="math inline">\(R\)</span> 与关系 <span class="math inline">\(S\)</span> 的<strong>交(intersection)</strong>记作：<span class="math inline">\(R \bigcap S=\{ t|t \in R \bigwedge t \in S \}\)</span>，其结果仍未 <span class="math inline">\(n\)</span> 目关系，由既属于 <span class="math inline">\(R\)</span> 又属于 <span class="math inline">\(S\)</span> 元组组成。用差表示为：<span class="math inline">\(R \bigcap S=R-(R-S)\)</span></p></li><li><p><strong>迪卡尔积(cartesian product)</strong>，这里严格来讲应该是广义迪卡尔积，因为这里迪卡尔积的元素是元组。<span class="math inline">\(R \times S=\{ \hat{t_rt_s}|t_r \in R \bigwedge t_s \in S \}\)</span></p></li></ul><p><br></p><ul><li><p><strong>选择(selection)</strong>又称之为限制(restriction)，记做：<span class="math inline">\(\sigma_F(R)=\{ t| t \in R \bigwedge F(t)=&#39;真&#39; \}\)</span>，其中 <span class="math inline">\(F\)</span> 表示选择条件，它是一个逻辑表达式。</p></li><li><p><strong>投影(projection)</strong>关系 <span class="math inline">\(R\)</span> 上的投影是从 <span class="math inline">\(R\)</span> 中选择出若干属性列组成新的关系。记做：<span class="math inline">\(\Pi_A(R)=\{ t[A]| t \in R \}\)</span>，其中 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(R\)</span> 的属性列。</p></li><li><p><strong>连接(join)</strong>也称为 <span class="math inline">\(\theta\)</span> 连接。从两个关系的迪卡尔积中选取属性间满足一定条件的元组。记做：<span class="math inline">\(R {\infty \atop A \theta B} S=\{ \hat{t_rt_s}|t_r \in R \bigwedge t_s \in S \bigwedge t_r[A] \theta t_s[B] \}\)</span></p></li><li><p><strong>除(division)</strong> ，记做：<span class="math inline">\(R\div S=\{ t_r[X]|t_r \in R \bigwedge \Pi_Y(S) \subseteq Y_x \}\)</span>，其中 <span class="math inline">\(Y_x\)</span> 为 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(R\)</span> 中的象集，<span class="math inline">\(x=t_r[X]\)</span>。</p></li></ul><h2 id="四.关系数据库标准语言-sql">四.关系数据库标准语言 SQL</h2><h3 id="sql-特点">1. SQL 特点</h3><ul><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>以同一中语法结构提供多种使用方式</li><li>语言简单,易学易用</li></ul><h3 id="数据定义-模型定义表定义视图索引">2. 数据定义: <code>模型定义</code>,<code>表定义</code>,<code>视图</code>,<code>索引</code></h3><ul><li><p>创建模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>表定义<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>视图定义<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>授权定义<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li><li><p>删除模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE <span class="operator">|</span> RESTRICT<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]</span><br><span class="line">    [, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级完整性约束条件]]</span><br><span class="line">    ...</span><br><span class="line">    [, <span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE <span class="operator">|</span> RESTRICT<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束]]</span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT] ]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span> [RESTRICT <span class="operator">|</span> CASCADE] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]  [, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>]] ... );</span><br></pre></td></tr></table></figure></li><li><p>修改索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX <span class="operator">&lt;</span>旧索引名<span class="operator">&gt;</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>新索引名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="数据查询">3. 数据查询</h3></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span> [, <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] ...</span><br><span class="line">    <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span> [, <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span> ...] <span class="operator">|</span> (<span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span>) [<span class="keyword">AS</span>] <span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">    [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th><strong>查询条件</strong></th><th><strong>谓词</strong></th></tr></thead><tbody><tr class="odd"><td>比较</td><td><code>=</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>!=</code> <code>&lt;&gt;</code> <code>!&gt;</code> <code>!&lt;</code></td></tr><tr class="even"><td>确定范围</td><td><code>BETWEEN AND</code> <code>NOT BETWEEN AND</code></td></tr><tr class="odd"><td>确定集合</td><td><code>IN</code> <code>NOT IN</code></td></tr><tr class="even"><td>字符匹配</td><td><code>LIKE</code> <code>NOT LIKE</code></td></tr><tr class="odd"><td>空值</td><td><code>IS NULL</code> <code>IS NOT NULL</code></td></tr><tr class="even"><td>逻辑运算</td><td><code>AND</code> <code>OR</code> <code>NOT</code></td></tr></tbody></table><p><strong>聚集函数</strong></p><table><thead><tr class="header"><th><strong>函数名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr class="odd"><td><code>COUNT(*)</code></td><td>统计元组个数</td></tr><tr class="even"><td><code>COUNT( [DISTINCT/ALL] &lt;列名&gt; )</code></td><td>统计一列中值的个数</td></tr><tr class="odd"><td><code>SUM( [DISTINCT/ALL] &lt;列名&gt; )</code></td><td>计算一列值的总和</td></tr><tr class="even"><td><code>AVG( [DISTINCT/ALL] &lt;列名&gt; )</code></td><td>计算一列值的平均值</td></tr><tr class="odd"><td><code>MAX( [DISTINCT/ALL] &lt;列名&gt; )</code></td><td>求一列的最大值</td></tr><tr class="even"><td><code>MIN( [DISTINCT/ALL] &lt;列名&gt; )</code></td><td>求一列的最小值</td></tr></tbody></table><p><strong>GROUP BY 子句</strong></p><p>将查询结果按某一列或多列的值分组,值相等的为一组</p><blockquote><p>(分组后聚集函数将作用于每一个组,即每一个组都有一个函数值)</p></blockquote><h3 id="数据更新">4. 数据更新</h3><ul><li><p>插入元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>] ...)]</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>] ...);</span><br></pre></td></tr></table></figure></li><li><p>插入子查询结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [, <span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>] ...)]</span><br><span class="line">子查询;</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>] ...</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><h3 id="视图">5. 视图</h3></li><li><p>创建视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] ...)]</span><br><span class="line"><span class="keyword">AS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure></li><li><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE];</span><br></pre></td></tr></table></figure></li><li><p>更新视图: 对视图的查询和基本表相同,但是更新操作受到以下三条规则限制</p><ul><li>如果视图从多个基本表使用联合操作导出,则不允许更新</li><li>如果导出的视图使用了分组和聚合操作,也不允许更新</li><li>如果视图从单个基本表使用选择和投影导出,并包括了主码或某个候选码,则可以操作</li></ul></li></ul><h3 id="数据安全性">6. 数据安全性</h3><p>数据安全性是指保护数据库以防止不合法使用所造成的数据泄漏,更改或破坏</p><h4 id="i.-数据的不安全因素">I. 数据的不安全因素</h4><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄漏</li><li>安全环境的脆弱性</li></ul><h4 id="ii.-实现数据库系统安全的技术和方法">II. 实现数据库系统安全的技术和方法</h4><p>有多种,最重要的是 <code>存取控制技术</code> 和 <code>审计技术</code>,目前许多大型 DBMS 达到的 <strong>C2</strong> 级,其安全版本达到 <strong>B1</strong>.</p><p><strong>C2</strong> 级的 DBMS 必须具有自主存取控制功能和审计功能,<strong>B1</strong> 级的必须具有强制存取控制功能和增强的审计功能.</p><p>自主存取控制功能一般是通过 <strong>SQL</strong> 的 <code>GRANT</code> 语句和 <code>REVOKE</code> 语句来实现.</p><h4 id="iii.-常用存取控制方法">III. 常用存取控制方法</h4><ul><li><p>自主存取控制 (Discretionary Access Control,DAC)</p><p>同一用户对于不同的数据对象有不同的存取权限,不同用户对同一对象也不同权限,用户还可以将其拥有的存取权限转授其他用户</p></li><li><p>强制存取控制 (Mandatory Access Control,MAC)</p><p>每一个数据对象被标记一定的密级,每一个用户也被授予某一个级别的许可证,对于任意一个对象,只有具有合法许可证的用户才可以存取</p></li></ul><h3 id="数据完整性">7. 数据完整性</h3><h4 id="i.-维护数据库的完整性dbms-必须实现">I. 维护数据库的完整性,DBMS 必须实现:</h4><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><h4 id="ii.-实体完整性检查和违约处理">II. 实体完整性检查和违约处理:</h4><blockquote><p>在列级,表级定义主码后,每更新一次,DBMS 将自动检查(有全表扫描,B+树索引)</p></blockquote><ul><li>检查主码值是否唯一,如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空值,只有一个空值就拒绝插入或修改</li></ul><h4 id="iii.-参照完整性">III. 参照完整性</h4><blockquote><p>用 <code>FOREIGN KEY</code> 短语定义哪些列为外码<br> 用 <code>reference</code> 指明这些外码参照哪些表的主码,参照完整性检查和违约处理</p></blockquote><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝/联级删除/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝/联级操作/设置为空值</td></tr></tbody></table><p><em>备注:拒绝(NO ACTION),联级(CASCADE)</em></p><h4 id="iv.-用户定义完整性">IV. 用户定义完整性</h4><ul><li><p>属性上约束条件的定义: 包括列值非空(<code>NOT NULL</code>),列值唯一(<code>UNIQUE</code>),检查列值是否满足一个条件表达式(<code>CKECK sentence</code>)</p><p>属性上约束条件的检查和违约处理: 当往表中插入元组或修改属性的值时,DBMS 将检查属性上的约束条件是否被满足,不满足拒绝执行.</p></li><li><p>元组上约束条件的定义: 与属性上类似,用 CHECK 定义元组上的约束条件,即元组级限制(可设置不同属性之间的相互约束条件)</p><p>元组上约束条件的检查和违约处理: 当往表中插入元组或修改属性的值时,DBMS 将检查元组的约束条件是否被满足,不满足拒绝执行.</p></li></ul><h4 id="v.-完整性约束命名句子">V. 完整性约束命名句子</h4><ul><li>完整性约束命名句子</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>完整性约束条件命名<span class="operator">&gt;</span> <span class="operator">&lt;</span>完整约束条件<span class="operator">&gt;</span></span><br><span class="line">   # 完整性约束条件包括: <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">UNIQUE</span>, <span class="keyword">PRIMARY</span> KEY, FOREEIGN KEY, CHAECK 短语等</span><br></pre></td></tr></table></figure><ul><li>修改完整性约束条件: 使用 <code>ALTER TABLE sentence</code></li></ul><h4 id="vi.-断言">VI. 断言</h4><p>通过声明性断言(declarative assertions)来制定更具有一般性的约束,可以定义设计多个表或聚集操作的比较复杂的完整性思想,断言创建后任何涉及关系的操作都会触发 DBMS 对断言的检查.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建断言</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">删除断言</span><br><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="vii.-触发器">VII. 触发器</h4><p>触发器又叫做<u>事件-条件-动作</u>(event-condition-action)规则, 是用户定义在关系表上的一类由事件驱动的特殊过程, 当特定的系统事件(如表的增删改查操作,事物的结束)发生时,对规则的条件进行检查,若成立则执行</p><ul><li><p>定义触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span>  #每当触发事件发生时,该触发器被激活</span><br><span class="line">    &#123;BEFORE|AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt; #指明触发器激活时是在触发器事件前或后</span><br><span class="line">    <span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="operator">|</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>  #<span class="keyword">REFERENCING</span> 指出引用的变量</span><br><span class="line">    FOR EACH &#123;ROW|STATEMENT&#125;  #定义触发器的类型,指明动作体的频率</span><br><span class="line">    [<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发器条件<span class="operator">&gt;</span>] <span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span>  #仅当触发条件为真时才执行触发动作体</span><br></pre></td></tr></table></figure></li><li><p>激活触发器: 发器的执行是由触发事件激活并由数据库服务器自动执行, 激活应遵循如下执行顺序</p><ol type="1"><li>执行该表上的 BEFORE 触发器</li><li>激活触发器的 SQL 语句</li><li>执行该表上的 AFTER 触发器</li></ol></li><li><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h1 id="第六章-关系数据理论">第六章 关系数据理论</h1></li></ul><blockquote><p>(一个好的关系模式应当不会发生 <code>插入异常</code>, <code>删除异常</code> 和 <code>更新异常</code>,数据冗余应尽可能少.)</p></blockquote><ul><li><p>数据依赖是一个关系内部属性与属性之间的约束关系,这种关系是通过属性之间的相等与否体现出来的数据相关联系;其中最重要的是 <code>函数依赖</code> 和 <code>多值依赖</code></p></li><li><p>规范化: 一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模型的集合,这个过程就是规范化.</p><ul><li><p>1NF: 第一范式.每一个分量必须不可再分的数据项.</p><p><em>缺点: 数据冗余,插入异常,删除异常,更新异常</em></p></li><li><p>2NF: 第二范式.首先属于 <code>1NF</code>,且每一个非主属性完全函数依赖与任何一个候选码.</p><p><em>缺点: 插入异常,删除异常,修改复杂</em></p></li><li><p>3NF: 第三范式.首先属于 <code>2NF</code>,且不存在依赖传递.</p><p><em>并不能完全消除各种异常情况和数据冗余</em></p></li><li><p>BCNF: 修正第三范式.基本消除了任何属性对码的依赖传递和部分依赖.性质:</p><ol type="1"><li>所有非主属性对每一个码都是完全依赖关系</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ol></li><li><p>4NF: 第四范式.不允许有非平凡且非函数依赖的多值依赖,允许的非平凡多值依赖的函数依赖</p></li></ul></li></ul><figure><img src="http://dl.iteye.com/upload/attachment/318920/fa4fcfba-7888-310d-bd10-a736ef1ac97d.gif" alt="fanshi" /><figcaption aria-hidden="true">fanshi</figcaption></figure><h2 id="数据依赖的公理系统">数据依赖的公理系统</h2><h4 id="armstrong-公理系统">1. Armstrong 公理系统</h4><p>Armstrong 是一个有效且完备的公理系统, 公理系统是模式分解算法的理论基础</p><p>设 <span class="math inline">\(U\)</span> 为属性集总体: <span class="math inline">\(F\)</span> 是 <span class="math inline">\(U\)</span> 上的一组函数依赖,于是有关系模型 <span class="math inline">\(R&lt;U,F&gt;\)</span> .对于 <span class="math inline">\(R&lt;U,F&gt;\)</span> 来说有以下推理规则:</p><ul><li>自反律(reflexivity rule): 若 <span class="math inline">\(Y⊆X⊆U\)</span>,则 <span class="math inline">\(X\rightarrow Y\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含</li><li>增广律(augmentation rule): 若 <span class="math inline">\(X \rightarrow Y\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含,且 <span class="math inline">\(Z⊆U\)</span>, 则 <span class="math inline">\(XZ \rightarrow YZ\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含</li><li>传递律(transitivity rule): 若 <span class="math inline">\(X\rightarrow Y\)</span> 及 <span class="math inline">\(Y\rightarrow Z\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含,则 <span class="math inline">\(X\rightarrow Z\)</span> 为 <span class="math inline">\(F\)</span> 所蕴含</li></ul><p>推导:</p><ul><li>合并规则(union rule):由 <span class="math inline">\(X\rightarrow Y\)</span>, <span class="math inline">\(X\rightarrow Z\)</span>,有 <span class="math inline">\(X\rightarrow YZ\)</span></li><li>伪传递规则(pseudo transivity rule):由 <span class="math inline">\(X\rightarrow Y\)</span>, <span class="math inline">\(WY\rightarrow Z\)</span>,有 <span class="math inline">\(XW\rightarrow Z\)</span></li><li>分解规则(decomposition rule):由 <span class="math inline">\(X\rightarrow Y\)</span> 及 <span class="math inline">\(Z⊆Y\)</span>,有 <span class="math inline">\(X\rightarrow Z\)</span></li></ul><h4 id="闭包-f">2. 闭包 F+</h4><p>在关系模式 <span class="math inline">\(R&lt;U,F&gt;\)</span> 中为 <span class="math inline">\(F\)</span> 所逻辑蕴含的函数依赖的全体叫作 <span class="math inline">\(F\)</span> 的闭包,即为 <span class="math inline">\(F+\)</span>.</p><h4 id="x-关于函数依赖集-f-的闭包-xf">3. X 关于函数依赖集 F 的闭包 XF+</h4><p>定义:设 <span class="math inline">\(F\)</span> 为属性集 <span class="math inline">\(U\)</span> 上的一组函数依赖, <span class="math inline">\(X⊆U\)</span>, <span class="math inline">\(X_{F^+}=\{A|X\rightarrow A能由F根据Armstrong公理导出\}\)</span>,<span class="math inline">\(X_{F^+}\)</span> 称为属性集 <span class="math inline">\(X\)</span> 关于函数依赖集 <span class="math inline">\(F\)</span> 的闭包</p><h4 id="最小依赖集">4. 最小依赖集</h4><p>又称最小覆盖,满足以下条件:</p><ul><li><span class="math inline">\(F\)</span> 中任一函数依赖的右部只含有一个属性</li><li><span class="math inline">\(F\)</span> 中不存在这样的函数依赖 <span class="math inline">\(X\rightarrow A\)</span>,使得 <span class="math inline">\(F\)</span> 与 <span class="math inline">\(F-{X\rightarrow A}\)</span> 等价</li><li><span class="math inline">\(F\)</span> 中不存在这样的函数依赖 <span class="math inline">\(X\rightarrow A\)</span>, <span class="math inline">\(X\)</span> 有真子集 <span class="math inline">\(Z\)</span> 使得 <span class="math inline">\(F-{X\rightarrow A}∪{Z\rightarrow A}\)</span> 与 <span class="math inline">\(F\)</span> 等价</li></ul><h2 id="模式分解定义">模式分解定义</h2><p><strong>三种不同的定义:</strong></p><ul><li><strong>无损连接性</strong></li><li><strong>保持函数依赖</strong></li><li><strong>既要保持函数依赖又要具有无损连接性</strong></li></ul><h4 id="关于模式分解的重要事实">1. 关于模式分解的重要事实:</h4><ul><li>若要求分解保持函数依赖,那一定可以达到 3NF,不一定达到 BCNF</li><li>若要求分解保持函数依赖,又具有无损连接性,可以达到 3NF,不一定达到 BCNF</li><li>若要求分解具有无损连接性,那一定可以达到 4NF</li></ul><h4 id="损连接性分解">2. 损连接性分解</h4><p><strong>分解后的关系自然连接,完全等于分解前的关系,则这个分解相对于 F 是无损连接分解.</strong></p><p>判断分解无损连接性的算法:</p><ul><li>表格法</li><li>设 <span class="math inline">\(R\)</span> 的分解为 <span class="math inline">\(ρ=\{R1,R2\}\)</span>, <span class="math inline">\(F\)</span> 为 <span class="math inline">\(R\)</span> 所满足的函数依赖集，则分解 <span class="math inline">\(ρ\)</span> 具有无损联接性的充分必要条件是：<span class="math inline">\(R_1∩R_2→(R_1-R_2)\)</span> 或者 <span class="math inline">\(R_1∩R_2→(R_2-R_1)\)</span></li></ul><h4 id="保持函数依赖的分解">3. 保持函数依赖的分解</h4><p><code>Let F' = F1U … FiU .. UFn</code> , 若 <code>F</code> 与 <code>F'</code> 等价，即 <code>F'+ = F+</code> ，则保持函数依赖。</p><p>判断方法：<code>F</code> 所有原函数依赖可以由 <code>F'</code> 的函数依赖逻辑导出</p><h1 id="第七章-数据库设计概述">第七章 数据库设计概述</h1><h4 id="数据库应用系统">1. 数据库应用系统</h4><p>数据库应用系统其开发也是一项软件工程,称为数据库工程.</p><p>数据库应用系统也有生存期的概念,通常包括六个阶段:</p><ol type="1"><li>需求分析阶段: 需求收集,分析,处理-&gt;DD(数据字典)和 DFD(数据流图)</li><li>概念设计阶段: 设计概念结构-&gt;E-R 图</li><li>逻辑设计阶段: 设计逻辑结构和数据模型</li><li>物理设计阶段: 关系模式存取方法(B+树,hash 索引,聚簇存取),设计物理文件存储结构</li><li>实现阶段: 物理实现,实验性运行</li><li>运行维护阶段: 使用,维护数据库</li></ol><h4 id="概念设计的主要步骤">2. 概念设计的主要步骤</h4><ol type="1"><li>进行数据抽象,设计局部概念模式</li><li>将局部概念模式综合成全局概念模式</li><li>评审</li></ol><h4 id="e-r-法进行数据库概念设计">3. E-R 法进行数据库概念设计</h4><ol type="1"><li>首先设计局部 E-R 模式</li><li>然后把各局部 E-R 模式综合成全局 E-R 模式</li><li>最后对全局 E-R 模式进行优化</li></ol><h4 id="逻辑结构设计">4. 逻辑结构设计</h4><p>把 E-R 图转换为与选用 DBMS 支持的数据模型相符合的逻辑结构</p><h4 id="数据模型优化">5. 数据模型优化</h4><p>数据模型优化其结果不唯一,方法为:</p><ol type="1"><li>确定数据依赖</li><li>消除冗余关系</li><li>确定关系模式处于第几范式</li><li>根据需求分析确定哪种模式适合应用环境(并非范式化越高越优)</li></ol><h4 id="e-r-图向关系转化的原则">6. E-R 图向关系转化的原则</h4><ul><li>一个<u>实体型</u>转换为一个<u>关系模式</u>.(属性, 码)</li><li><code>1:1</code> 联系可转为独立关系模式,也可与其一合并.(若合并,联系的属性也一同合并)</li><li><code>1:n</code> 联系可转为独立关系模式,也可与 n 端合并.(若合并,联系的属性也一同合并)</li><li>三个或三个以上实体间的多元联系应转为一个关系模式.</li><li>具有相同码的关系可合并.</li></ul><h1 id="第八章-sql-编程">第八章 SQL 编程</h1><p>主语言为 C,其格式为 <code>EXEC SQL &lt;SQL语句&gt;</code></p><p>主语言为 Java,其格式为 <code># SQL &#123;&lt;SQL语句&gt;&#125;</code></p><p>建立嵌入式 SQL 的连接语法: <code>EXEC SQL CONNECT TO target [AS connect-name][USERT user-name]</code> (备注:target 是要连接的数据库服务器)</p><h4 id="存储过程">1. 存储过程</h4><ol type="1"><li>创建存储过程:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SQL</span> REPLACE <span class="keyword">PROCEDURE</span> 过程名 ([参数<span class="number">1</span>,参数<span class="number">2</span>,...])</span><br><span class="line">    <span class="keyword">AS</span> <span class="operator">&lt;</span>过程化<span class="keyword">SQL</span>块<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>执行存储过程:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span><span class="operator">/</span>PERFORM <span class="keyword">PROCEDURE</span> 过程名 ([参数<span class="number">1</span>,参数<span class="number">2</span>,...]);</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>修改存储过程:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> 过程名<span class="number">1</span> RENAME <span class="keyword">TO</span> 过程名<span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除存储过程:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 过程名;</span><br></pre></td></tr></table></figure><h4 id="odbc">2. ODBC</h4><p>由用户 <em>应用程序</em> + <em>ODBC 驱动程序管理器</em> + <em>数据库驱动程序</em> + <em>数据源构成</em>.</p><p>其工作流程:</p><ul><li>配置数据源</li><li>初始化环境</li><li>建立连接</li><li>分配语句句柄</li><li>执行 SQL 语句</li><li>结果处理集</li><li>终止处理</li></ul><h1 id="第九章-查询优化">第九章 查询优化</h1><p>步骤为:</p><ol type="1"><li>查询分析:语法,词法</li><li>查询检查:语义,权限,安全性检查</li><li>查询优化:代数优化,物理优化</li><li>查询执行:代码生成</li></ol><p>查询优化的目的就是为了系统在执行时既省时间又能提高效率，在关系代数运算中，通常是先进行笛卡尔积或联接运算，再进行选择和投影，恰当地安排选择、投影和联接的顺序，就可实现查询优化。优化的策略主要有以下几点：</p><ul><li>在关系代数表达式中尽可能早地执行选择操作(早做选择).</li><li>把笛卡尔积和随后的选择操作合并成连接运算 (尽可能做自然连接或等值连接，不做笛卡尔积).</li><li>同时计算一连串的选择和投影操作，使操作对象尽可能变小。</li><li>连接多个对象时，先做连接结果小的连接。</li><li>计算表达式之前先估计一下怎么计算合算</li></ul><h1 id="第十章-数据库恢复技术">第十章 数据库恢复技术</h1><h5 id="事务">1. 事务</h5><p>事务是数据库的逻辑工作单位，其特点:原子性、一致性、隔离性和持续性</p><p>定义事务的语句一般有三条:<code>BEGIN TRANSATION</code>; <code>COMMIT</code>; <code>ROLLBACK</code>;</p><ol type="1"><li>事务开始通常由 <code>BEGIN TRANSACTION</code>, <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束,</li><li><code>commit</code> 提交事务的所有操作,</li><li><code>rollback</code> 表示回滚,即事务运行中发生了故障,系统将事务中对数据库的所有已完成的操作全部撤销,回滚到事务开始的状态</li></ol><h4 id="故障类型">2. 故障类型</h4><p>事物故障, 系统故障和介质故障</p><h4 id="恢复中最常用的技术">3. 恢复中最常用的技术</h4><p>数据库转储, 登记日志文件</p><h4 id="恢复的基本原理">4. 恢复的基本原理</h4><p>利用存储的备份副本, 日志文件 或 数据库镜像中冗余的数据 来重建数据库</p><h4 id="常用恢复技术">5. 常用恢复技术</h4><ul><li>事物故障的回复:UNDO</li><li>系统故障的恢复:未提交的事物做 UNDO,以提交的做 REDO</li><li>介质事物的恢复:重装备份并恢复到一致性状态 + REDO</li></ul><h4 id="提高恢复效率的技术">6. 提高恢复效率的技术</h4><p>检查点技术</p><ul><li>可以提高系统故障的恢复效率</li><li>可以在一定程度上提高利用动态转储备份进行介质故障恢复的效率</li></ul><p>镜像技术</p><ul><li>镜像技术可以改善介质故障的恢复效率</li></ul><h1 id="第十一章-并发控制">第十一章 并发控制</h1><h4 id="并发控制机制">1. 并发控制机制</h4><p>数据库的并发控制以事务为单位,每一时刻只有一个事务在运行(在单处理机系统中,事务的并行执行实际上是并行操作轮流交叉运行)</p><p>数据库的并发控制通常使用封锁机制(也有时间戳,乐观控制法,多本并发控制等其他方法), 其基本类型有两种排他锁(又称写锁, X 锁)和共享锁(又称读锁, S 锁)</p><table><thead><tr class="header"><th>横向为事务 T1,纵向为事务 T2</th><th>X</th><th>S</th><th>-</th></tr></thead><tbody><tr class="odd"><td>X</td><td>N</td><td>N</td><td>Y</td></tr><tr class="even"><td>S</td><td>N</td><td>Y</td><td>Y</td></tr><tr class="odd"><td></td><td>Y</td><td>Y</td><td>Y</td></tr><tr class="even"><td>备注:Y 相容请求,N 不相容请求</td><td></td><td></td><td></td></tr></tbody></table><h4 id="常用的封锁协议">2. 常用的封锁协议</h4><p>不同级别的封锁协议提供不同的数据一致性保证,提供不同的数据共享度.</p><table><thead><tr class="header"><th>名称</th><th>定义</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>一级</td><td>事务 T 在修改数据 R 前必须先加 X 锁,直到事务结束才释放</td><td>可以防止丢失修改并保证事务可恢复</td><td>不保证可重复读和不读脏数据</td></tr><tr class="even"><td>二级</td><td>在一级基础上,增加事务 T 在读取数据 R 前必须加 S 锁,读完后立即释放</td><td>可防止丢失修改和读脏数据</td><td>不保证可重复读</td></tr><tr class="odd"><td>三级</td><td>在一级基础上,增加事务 T 读取数据 R 前必须加 S 锁,直到事务结束才释放</td><td>可防止丢失修改和读脏数据</td><td></td></tr></tbody></table><h4 id="正确的判别准则">3. 正确的判别准则</h4><p>并发控制机制调度并发事务操作是否正确的判别准则是可串行性</p><ul><li><p>并发操作的正确准则性通常由两段锁协议保证(2PL)</p><ul><li>获得封锁,在对任何数据读写之前要申请并获取对该数据的封锁</li><li>释放封锁,释放封锁之后,事务不再申请和获得任何其他锁</li></ul></li><li><p>两段锁协议是可串行化调度的充分条件,但不是并要条件</p></li></ul><h4 id="对象数据施加封锁带来的问题">4. 对象数据施加封锁带来的问题</h4><ul><li>活锁:解决额方法,先来先服务</li><li>死锁:预防方法,一次封锁法,顺序封锁法</li></ul><h4 id="死锁的诊断与解除">5. 死锁的诊断与解除</h4><p>超时法和等待图法</p><h4 id="封锁粒度">6. 封锁粒度:</h4><p>封锁的粒度越大-&gt;数据库能封锁的数据单元越少,并发度越小,系统开销越小;粒度越小,则相反.</p><p>多粒度封锁分为:</p><ul><li>显式封锁:直接加到数据对象上的封锁</li><li>隐式封锁:由于其上级结点加锁而使该数据对象加锁</li></ul><h4 id="意向锁intention-lock">7. 意向锁(intention lock)</h4><ul><li>目的:提高对某个数据对象加锁时系统的检查效率</li><li>IS, IX, SIX 锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hive 使用命令总结</title>
      <link href="2020/03/12/012-Use-hive/"/>
      <url>2020/03/12/012-Use-hive/</url>
      
        <content type="html"><![CDATA[<p>最近用到 hive，这里做个笔记. hive 的 hql 的使用总结也算的上七七八八了. 以后在补充吧.</p><a id="more"></a><h1 id="hive-导入数据">hive 导入数据</h1><p>hive 不支持 <code>insert</code> 语句，数据只能通过 <code>load</code> 导入 <strong>1.本地导入</strong> <code>hive&gt; load data local inpath 'file-path' into table table-name;</code> <strong>2.HDFS 导入</strong> <code>hive&gt; load data inpath 'hdfs-path' into table table-name;</code></p><blockquote><p>本地导入的过程就是先加载到 HDFS 中，再导入 hive 表中</p></blockquote><p><strong>3.查询导入</strong> <code>hive&gt; insert into table table-name 查询语句</code> <strong>4.创建表时查询导入</strong> (建表的方式之一) <code>hive&gt; create table table-name as 查询语句</code></p><h1 id="hive-建表">hive 建表</h1><p>首先看官网介绍 (进行一定标注) <code>[ ]</code>表示可选，<code>|</code> 表示二选一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name</span><br><span class="line"><span class="comment">-- (<span class="doctag">Note:</span> TEMPORARY 0.14.0版本及以后存在)</span></span><br><span class="line">  [(col_name data_type [COMMENT col_comment], ... [constraint_specification])]</span><br><span class="line">  <span class="comment">--(列名 data_type comment 列注释内容)</span></span><br><span class="line">  [COMMENT table_comment]</span><br><span class="line">  <span class="comment">--(comment 表注释内容)</span></span><br><span class="line">  [PARTITIONED <span class="keyword">BY</span> (col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">  [CLUSTERED <span class="keyword">BY</span> (col_name, col_name, ...) [SORTED <span class="keyword">BY</span> (col_name [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...)] <span class="keyword">INTO</span> num_buckets BUCKETS]</span><br><span class="line">  [SKEWED <span class="keyword">BY</span> (col_name, col_name, ...)                  <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.10.0 and later)]</span></span><br><span class="line">     <span class="keyword">ON</span> ((col_value, col_value, ...), (col_value, col_value, ...), ...)</span><br><span class="line">     [STORED <span class="keyword">AS</span> DIRECTORIES]</span><br><span class="line">  [</span><br><span class="line">   [<span class="type">ROW</span> FORMAT row_format] <span class="comment">--(行格式)</span></span><br><span class="line">   [STORED <span class="keyword">AS</span> file_format]</span><br><span class="line">     <span class="operator">|</span> STORED <span class="keyword">BY</span> <span class="string">&#x27;storage.handler.class.name&#x27;</span> [<span class="keyword">WITH</span> SERDEPROPERTIES (...)]  <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.6.0 and later)</span></span><br><span class="line">  ]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [TBLPROPERTIES (property_name<span class="operator">=</span>property_value, ...)]   <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.6.0 and later)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="keyword">AS</span> select_statement];   <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.5.0 and later; not supported for external tables)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name</span><br><span class="line">  <span class="keyword">LIKE</span> existing_table_or_view_name</span><br><span class="line">  [LOCATION hdfs_path];</span><br><span class="line"></span><br><span class="line">data_type <span class="comment">--(支持数据类型)</span></span><br><span class="line">  : primitive_type <span class="comment">--(原始类型)</span></span><br><span class="line">  <span class="operator">|</span> array_type <span class="comment">--(存储同类型的list，如:array&lt;data_type&gt;)</span></span><br><span class="line">  <span class="operator">|</span> map_type <span class="comment">--(key-value形式，如：map&lt;primitive_type, data_type&gt;)</span></span><br><span class="line">  <span class="operator">|</span> struct_type <span class="comment">--(存储不同类型)</span></span><br><span class="line">  ：STRUCT <span class="operator">&lt;</span> col_name : data_type [COMMENT col_comment], ...<span class="operator">&gt;</span></span><br><span class="line">  <span class="operator">|</span> union_type  <span class="comment">-- (有限取值范围内取值，<span class="doctag">Note:</span>0.7.0版本及之后存在)</span></span><br><span class="line">  : UNIONTYPE <span class="operator">&lt;</span> data_type, data_type, ... <span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">primitive_type <span class="comment">--(支持原始类型)</span></span><br><span class="line">  : TINYINT <span class="comment">--(1bit整数，如：45Y)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">SMALLINT</span> <span class="comment">--(2bit整数，如：45S)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">INT</span> <span class="comment">--(4bit整数，如：45)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">BIGINT</span> <span class="comment">--(8bit整数，如：45L)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">BOOLEAN</span> <span class="comment">--(布尔类型，true / false)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">FLOAT</span> <span class="comment">--(4字节单精度浮点数)</span></span><br><span class="line">  <span class="operator">|</span> <span class="keyword">DOUBLE</span> <span class="comment">--(8字节单精度浮点数)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">DOUBLE PRECISION</span> <span class="comment">-- (<span class="doctag">Note:</span> 2.2.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> STRING <span class="comment">--(字符串，不定长)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">BINARY</span> <span class="comment">-- (变长二进制，<span class="doctag">Note:</span>0.8.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">TIMESTAMP</span> <span class="comment">-- (时间戳，纳秒精度，<span class="doctag">Note:</span>0.8.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">DECIMAL</span> <span class="comment">-- (任意精度带符号小数，如：DECIMAL(4, 2)范围：-99.99到99.99，<span class="doctag">Note:</span> 0.11.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">DECIMAL</span>(<span class="keyword">precision</span>, scale)  <span class="comment">-- (<span class="doctag">Note:</span> 0.13.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">DATE</span>        <span class="comment">-- (日期，如：&#x27;2020-3-10&#x27;，<span class="doctag">Note:</span> 0.12.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">VARCHAR</span>     <span class="comment">-- (变长字符串，长度有上限，<span class="doctag">Note:</span> 0.12.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> <span class="type">CHAR</span>        <span class="comment">-- (定长字符串，<span class="doctag">Note:</span> 0.13.0版本及之后存在)</span></span><br><span class="line"></span><br><span class="line">row_format <span class="comment">--(行样式格式)</span></span><br><span class="line">  : DELIMITED [FIELDS TERMINATED <span class="keyword">BY</span> <span class="type">char</span> [ESCAPED <span class="keyword">BY</span> <span class="type">char</span>]] [COLLECTION ITEMS TERMINATED <span class="keyword">BY</span> <span class="type">char</span>]</span><br><span class="line">        [MAP KEYS TERMINATED <span class="keyword">BY</span> <span class="type">char</span>] [LINES TERMINATED <span class="keyword">BY</span> <span class="type">char</span>]</span><br><span class="line">        [<span class="keyword">NULL</span> DEFINED <span class="keyword">AS</span> <span class="type">char</span>]   <span class="comment">-- (<span class="doctag">Note:</span> 0.13.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> SERDE serde_name [<span class="keyword">WITH</span> SERDEPROPERTIES (property_name<span class="operator">=</span>property_value, property_name<span class="operator">=</span>property_value, ...)]</span><br><span class="line"></span><br><span class="line">file_format: <span class="comment">--(文件存储格式)</span></span><br><span class="line">  : SEQUENCEFILE</span><br><span class="line">  <span class="operator">|</span> TEXTFILE    <span class="comment">-- (Default, 文本格式, 常用)</span></span><br><span class="line">  <span class="operator">|</span> RCFILE      <span class="comment">-- (<span class="doctag">Note:</span> 0.6.0版本及之后存在)</span></span><br><span class="line">  <span class="comment">--(基于HDFS架构，表格占用多个HDFS块。每个HDFS块中，RCFile以行组为基本单位来组织记录。)</span></span><br><span class="line">  <span class="operator">|</span> ORC         <span class="comment">-- (<span class="doctag">Note:</span> 0.11.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> PARQUET     <span class="comment">-- (<span class="doctag">Note:</span> 0.13.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> AVRO        <span class="comment">-- (<span class="doctag">Note:</span> 0.14.0版本及之后存在)</span></span><br><span class="line">  <span class="operator">|</span> INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</span><br><span class="line"></span><br><span class="line">constraint_specification: <span class="comment">--(约束规范)</span></span><br><span class="line">  : [, <span class="keyword">PRIMARY</span> KEY (col_name, ...) DISABLE NOVALIDATE ] <span class="comment">--(主键)</span></span><br><span class="line">  <span class="comment">--(外键约束)</span></span><br><span class="line">    [, <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">FOREIGN</span> KEY (col_name, ...) <span class="keyword">REFERENCES</span> table_name(col_name, ...) DISABLE NOVALIDATE</span><br></pre></td></tr></table></figure><p>样例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> cpo_1 (url string, title string, reply_number <span class="type">int</span>, last_time string, content <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>)</span><br><span class="line">    <span class="operator">&gt;</span> <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;-&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="like-建表">like 建表</h3><p>会创建结构完全相同的表，但是没有数据。 常用语中间表 <code>CREATE TABLE empty_key_value_store LIKE key_value_store;</code></p><h3 id="外部表">外部表</h3><p>未被 <code>external</code> 修饰的是内部表(managed table)，被 <code>external</code> 修饰的为外部表(external table)；</p><blockquote><p>内部表数据由 Hive 自身管理，外部表数据由 HDFS 管理； 内部表数据存储的位置是 hive.metastore.warehouse.dir（默认：/user/hive/warehouse），外部表数据的存储位置由自己制定； 删除内部表会直接删除元数据（metadata）及存储数据；删除外部表仅仅会删除元数据，HDFS 上的文件并不会被删除； 对内部表的修改会将修改直接同步给元数据，而对外部表的表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE table_name;）</p></blockquote><p>样例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> cpo_1 (url string, title string, reply_number <span class="type">int</span>, last_time string, content <span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>, <span class="keyword">add</span> map<span class="operator">&lt;</span>String,string<span class="operator">&gt;</span>)</span><br><span class="line">    <span class="operator">&gt;</span> <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">    <span class="operator">&gt;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="operator">&gt;</span> map keys terminated <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span></span><br><span class="line"><span class="operator">&gt;</span> location <span class="string">&#x27;/user/t2&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="hive-查询">hive 查询</h1><ol type="1"><li><p>显示表结构：<code>desc tablename</code> or <code>desc formatted tablename</code></p></li><li><p>全表查询：<code>select * from emp;</code></p></li><li><p>选择特定列查询：<code>select empno, ename from emp;</code></p></li><li><p>列别名查询：<code>select ename AS name, deptno dn from emp;</code></p></li><li><p>算术运算符：<code>select sal + 1 from emp;</code></p></li><li><p>常用函数 ① 求总行数（<strong>count</strong>）：<code>hive&gt; select count(*) cnt from emp;</code> ② 求工资的最大值（<strong>max</strong>）：<code>hive&gt; select max(sal) max_sal from emp;</code> ③ 求工资的最小值（<strong>min</strong>）：<code>hive&gt; select min(sal) min_sal from emp;</code> ④ 求工资的总和（<strong>sum</strong>）：<code>hive&gt; select sum(sal) sum_sal from emp;</code> ⑤ <strong>Limit</strong> 语句：<code>hive&gt; select * from emp limit 5;</code></p></li><li><p>where 语句 <code>hive&gt; select * from emp where sal &gt;1000;</code></p></li></ol><h3 id="运算符">运算符</h3><blockquote><p>下面表中描述了谓词操作符，这些操作符同样可以用于 JOIN…ON 和 HAVING 语句中。</p></blockquote><p><strong>比较运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">| 操作符                  | 支持的数据类型 | 描述                                                                                                                                                                                                                                                      |</span><br><span class="line">|-------------------------|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|</span><br><span class="line">| A&#x3D;B                     | 基本数据类型   | 如果A等于B则返回TRUE，反之返回FALSE                                                                                                                                                                                                                       |</span><br><span class="line">| A&lt;&#x3D;&gt;B                   | 基本数据类型   | 如果A和B都为NULL，则返回TRUE，其他的和等号（&#x3D;）操作符的结果一致，如果任一为NULL则结果为NULL                                                                                                                                                               |</span><br><span class="line">| A&lt;&gt;B, A!&#x3D;B              | 基本数据类型   | A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE                                                                                                                                                                                           |</span><br><span class="line">| A&lt;B                     | 基本数据类型   | A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE                                                                                                                                                                                           |</span><br><span class="line">| A&lt;&#x3D;B                    | 基本数据类型   | A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE                                                                                                                                                                                       |</span><br><span class="line">| A&gt;B                     | 基本数据类型   | A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE                                                                                                                                                                                           |</span><br><span class="line">| A&gt;&#x3D;B                    | 基本数据类型   | A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE                                                                                                                                                                                       |</span><br><span class="line">| A [NOT] BETWEEN B AND C | 基本数据类型   | 如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。                                                                                                                |</span><br><span class="line">| A IS NULL               | 所有数据类型   | 如果A等于NULL，则返回TRUE，反之返回FALSE                                                                                                                                                                                                                  |</span><br><span class="line">| A IS NOT NULL           | 所有数据类型   | 如果A不等于NULL，则返回TRUE，反之返回FALSE                                                                                                                                                                                                                |</span><br><span class="line">| IN(数值1, 数值2)        | 所有数据类型   | 使用 IN运算显示列表中的值                                                                                                                                                                                                                                 |</span><br><span class="line">| A [NOT] LIKE B          | STRING 类型    | B是一个SQL下的简单正则表达式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。 |</span><br><span class="line">| A RLIKE B, A REGEXP B   | STRING 类型    | B是一个正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。                                                       |</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><table><thead><tr class="header"><th>操作符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>AND</td><td>逻辑并</td></tr><tr class="even"><td>OR</td><td>逻辑或</td></tr><tr class="odd"><td>NOT</td><td>逻辑否</td></tr></tbody></table><h3 id="like-和-rlike">Like 和 RLike</h3><ol type="1"><li>使用 <code>like</code> 运算选择类似的值</li><li>选择条件可以包含字符或数字:<code>%</code> 代表零个或多个字符(任意个字符)。<code>_</code> 代表一个字符。</li><li><code>RLIKE</code> 子句是 Hive 中这个功能的一个扩展，其可以通过 Java 的正则表达式这个更强大的语言来指定匹配条件。</li></ol><p><code>查找薪水中含有2的员工信息：hive (default)&gt; select * from emp where sal RLIKE '[2]’;</code></p><h3 id="分组">分组</h3><p><strong>Group By 语句</strong></p><blockquote><p>GROUP BY 语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p></blockquote><p>计算 emp 表每个部门的平均工资:<code>hive&gt; select t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno;</code></p><p><strong>Having 语句</strong> having 与 where 不同点 :</p><ol type="1"><li>where 针对表中的列发挥作用,查询数据；having 针对查询结果中的列发挥作用，筛选数据。</li><li>where 后面不能写分组函数，而 having 后面可以使用分组函数。</li><li>having 只用于 group by 分组统计语句。</li></ol><p>求每个部门的平均薪水大于 2000 的部门:<code>hive&gt; select deptno, avg(sal) avg_sal from emp group by deptno having avg_sal &gt; 2000;</code></p><h3 id="join">join</h3><p><strong>等值 Join</strong></p><blockquote><p>Hive 支持通常的 SQL JOIN 语句，但是只支持等值连接，不支持非等值连接。</p></blockquote><p>案例实操:根据员工表和部门表中的部门编号相等，查询员工编号、员工名称和部门编号:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno, d.dname <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno <span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure><p><strong>内连接</strong></p><blockquote><p>只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span>d.deptno;</span><br></pre></td></tr></table></figure><p><strong>左外连接</strong></p><blockquote><p>JOIN 操作符左边表中符合 WHERE 子句的所有记录将会被返回。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span>d.deptno;</span><br></pre></td></tr></table></figure><p><strong>右外连接</strong></p><blockquote><p>JOIN 操作符右边表中符合 WHERE 子句的所有记录将会被返回。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure><p><strong>满外连接</strong></p><blockquote><p>将会返回所有表中符合 WHERE 语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用 NULL 值替代。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empno, e.ename, d.deptno <span class="keyword">from</span> emp e <span class="keyword">full</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno<span class="operator">=</span> d.deptno;</span><br></pre></td></tr></table></figure><p><strong>多表连接</strong></p><blockquote><p>连接 n 个表，至少需要 n-1 个连接条件。例如：连接三个表，至少需要两个连接条件。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename, d.deptno, l. loc_name <span class="keyword">FROM</span>  emp e <span class="keyword">JOIN</span>  dept d <span class="keyword">ON</span> d.deptno <span class="operator">=</span> e.deptno <span class="keyword">JOIN</span>   location l <span class="keyword">ON</span>  d.loc <span class="operator">=</span> l.loc;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：大多数情况下，Hive 会对每对 JOIN 连接对象启动一个 MapReduce 任务。本例中会首先启动一个 MapReduce job 对表 e 和表 d 进行连接操作，然后会再启动一个 MapReduce job 将第一个 MapReduce job 的输出和表 l 进行连接操作。 <strong>注意</strong>：为什么不是表 d 和表 l 先进行连接操作呢？这是因为 Hive 总是按照从左到右的顺序执行的。</p></blockquote><h3 id="排序">排序</h3><p><strong>全局排序</strong>（<code>Order By</code>）</p><blockquote><p><code>ASC</code>（ascend）: 升序（默认）</p></blockquote><pre><code>`DESC`（descend）: 降序</code></pre><p>ORDER BY 子句在 SELECT 语句的结尾: <code>hive (default)&gt; select * from emp order by col_name;</code></p><blockquote><p>也可以用别名，和使用多个字段</p></blockquote><p><strong>每个 MapReduce 内部排序</strong>（<code>Sort By</code>）</p><blockquote><p>Sort By：每个 MapReduce 内部进行排序，对全局结果集来说不是排序。</p></blockquote><p>（1）设置 reduce 个数:<code>hive&gt; set mapreduce.job.reduces=3;</code> （2）查看设置 reduce 个数:<code>hive&gt; set mapreduce.job.reduces;</code> （3）根据部门编号降序查看员工信息:<code>hive&gt; select * from emp sort by empno desc;</code> （4）将查询结果导入到文件中（按照部门编号降序排序）:<code>hive&gt; insert overwrite local directory '/opt/module/datas/sortby-result' select * from emp sort by deptno desc;</code></p><p><strong>分区排序</strong>（<code>Distribute By</code>）</p><blockquote><p>Distribute By：类似 MR 中 partition，进行分区，结合 sort by 使用。 注意，Hive 要求 DISTRIBUTE BY 语句要写在 SORT BY 语句之前。对于 distribute by 进行测试，一定要分配多 reduce 进行处理，否则无法看到 distribute by 的效果。</p></blockquote><p>案例实操：</p><ul><li>先按照部门编号分区，再按照员工编号降序排序。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">set</span> mapreduce.job.reduces<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">insert</span> overwrite <span class="keyword">local</span> directory <span class="string">&#x27;/opt/module/datas/distribute-result&#x27;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp distribute <span class="keyword">by</span> deptno sort <span class="keyword">by</span> empno <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>Cluster By</strong></p><blockquote><p>当 distribute by 和 sorts by 字段相同时，可以使用 cluster by 方式。 cluster by 除了具有 distribute by 的功能外还兼具 sort by 的功能。但是排序只能是倒序排序，不能指定排序规则为 ASC 或者 DESC。</p></blockquote><p>以下两种写法等价</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp cluster <span class="keyword">by</span> deptno;</span><br><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp distribute <span class="keyword">by</span> deptno sort <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure><blockquote><p>注意：按照部门编号分区，不一定就是固定死的数值，可以是 20 号和 30 号部门分到一个分区里面去。</p></blockquote><h3 id="分桶及抽样查询">分桶及抽样查询</h3>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署 hive</title>
      <link href="2020/03/11/011-Build-hive/"/>
      <url>2020/03/11/011-Build-hive/</url>
      
        <content type="html"><![CDATA[<p>如何一步步的搭建 Hive, 选择 MySQL 作为元仓库, 并解决一些搭建过程中遇到的问题. Hive 版本为: 2.3.6</p><a id="more"></a><p>Hive 是一个数据仓库基础工具在 Hadoop 中用来处理结构化数据。它架构在 Hadoop 之上，总归为大数据，并使得查询和分析方便。并提供简单的 sql 查询功能，可以将 sql 语句转换为 MapReduce 任务进行运行。</p><p>MapReduce 程序对于 Java 程序员来说比较容易写，但是对于其他语言使用者来说不太方便。Hive 让对 Hadoop 使用 SQL 查询（实际上 SQL 后台转化为了 MapReduce）成为可能，那些非 Java 程序员也可以更方便地使用。</p><h3 id="下载-hive">下载 hive</h3><p>hive 是基于 hadoop，所以要先安装 hadoop， <a href="https://blog.csdn.net/qq_38410494/article/details/104801399">hadoop 安装部署</a> 下载 hive 前要查看支持的版本 下载地址，北京理工大学开源软件镜：<a href="http://mirror.bit.edu.cn/apache/hive/">http://mirror.bit.edu.cn/apache/hive/</a> 解压 hive：<code>tar -xzvf apache-hive-2.3.6-bin.jar</code></p><h3 id="hive-配置">hive 配置</h3><ol type="1"><li><strong>配置 hive 环境变量</strong> 打开 <code>/etc/profile</code> <code>bash export HIVE_HOME=/opt/module/hive-2.3.6-bin PATH=$PATH:$HIVE_HOME/bin</code> 重新编译 <code>profile'</code>， <code>source /etc/profile</code></li><li><strong>hive 配置文件</strong> hive 的配置文件在 hive 目录下的 <code>conf</code> 中 <strong>a</strong>. <code>cp hive-env.sh.template hive-env.sh</code> <strong>b</strong>. <code>cp hive-log4j2.properties.template hive-log4j2.propertie</code> <strong>c</strong>. <code>cp hive-default.xml.template hive-site.xml</code> 修改 <code>hive-site.xml</code> ，这里以 2.3.6 为例： 544 行，连接数据库设置，默认 derby <code>xml &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:derby:;databaseName=metastore_db;create=true&lt;/value&gt; 修改 &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://127.0.0.1:3306/hive?allowPublicKeyPublicKeyRetrieval=true&amp;amp;userSSL=false&lt;/value&gt;</code> 1019 行，连接驱动设置 <code>xml &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/value&gt; 修改 &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;!-- 这里使用mysql8.0, 低版本为 com.mysql.jdbc.Driver--&gt; &lt;value&gt;com.mysql.cj.jdbc.Driver&lt;/value&gt;</code> 1044 行，设置用户名 <code>xml &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt;</code> 529 行，设置密码 <code>xml &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;mysql&lt;/value&gt;</code> 配置缓存目录，共三个，分别在 74、80、3975 行，将 <code>$&#123;system:java.io.tmpdir&#125;</code> 换成具体目录 <code>bash &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;system:user.name&#125;&lt;/value&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;name&gt;hive.server2.logging.operation.log.location&lt;/name&gt; &lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;system:user.name&#125;/operation_logs&lt;/value&gt;</code></li><li><strong>添加驱动</strong> 驱动下载地址：<a href="http://mvnrepository.com/artifact/mysql/mysql-connector-java">http://mvnrepository.com/artifact/mysql/mysql-connector-java</a> 下载文件：mysql-connector-java-8.0.17.jar，将驱动添加到：hive 目录下的 <code>/lib</code> 中</li></ol><h3 id="启动">启动</h3><ol type="1"><li><p>初始化 <code>schematool -dbType mysql -initSchema</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;opt&#x2F;module&#x2F;hive-2.3.6-bin&#x2F;lib&#x2F;log4j-slf4j-impl-2.6.2.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:&#x2F;opt&#x2F;module&#x2F;hadoop-2.8.5&#x2F;share&#x2F;hadoop&#x2F;common&#x2F;lib&#x2F;slf4j-log4j12-1.7.10.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br><span class="line">Metastore connection URL:        jdbc:mysql:&#x2F;&#x2F;192.168.228.128:3306&#x2F;onhive?</span><br><span class="line">Metastore Connection Driver :    com.mysql.cj.jdbc.Driver</span><br><span class="line">Metastore connection User:       hive</span><br><span class="line">Starting metastore schema initialization to 2.3.0</span><br><span class="line">Initialization script hive-schema-2.3.0.mysql.sql</span><br><span class="line">Initialization script completed</span><br><span class="line">schemaTool completed</span><br></pre></td></tr></table></figure><p>初始化成功</p></li><li><p>启动 ，命令行输入 <code>hive</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logging initialized using configuration in file:&#x2F;home&#x2F;zachary&#x2F;hive-2.3.6&#x2F;conf&#x2F;hive-log4j2.properties Async: true</span><br><span class="line">Hive-on-MR is deprecated in Hive 2 and may not be available in the future versions. Consider using a different execution engine (i.e. spark, tez) or using Hive 1.X releases.</span><br><span class="line">hive&gt;</span><br></pre></td></tr></table></figure><p>成功启动</p></li><li><p>推出 <code>quit;</code> or <code>exit;</code></p></li></ol><h3 id="解决问题">解决问题</h3><ul class="task-list"><li><input type="checkbox" disabled="" />遇到问题 1 hive 中使用 <code>show tables;</code> ，出现报错：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed with exception java.io.IOException:java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: $&#123;system:user.name%7D</span><br></pre></td></tr></table></figure><p>解决，修改配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.local.scratchdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/lch/software/Hive/apache-hive-2.1.1-bin/tmp/$&#123;ｓｙstem:user.name&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修改后 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.local.scratchdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/lch/software/Hive/apache-hive-2.1.1-bin/tmp/$&#123;user.name&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 Hadoop 平台</title>
      <link href="2020/03/11/010-Build-hadoop/"/>
      <url>2020/03/11/010-Build-hadoop/</url>
      
        <content type="html"><![CDATA[<p>如何一步步的搭建 Hadoop 平台, 并解决一些搭建过程中遇到的问题. Hadoop 版本为: 2.10</p><a id="more"></a><h3 id="下载-hadoop">下载 hadoop</h3><p>我这里是下载的 hadoop-2.10,从北京理工大学开源软件镜像，官网下载你懂得.... 地址: <a href="http://mirror.bit.edu.cn/apache/hadoop/">http://mirror.bit.edu.cn/apache/hadoop/</a></p><p>下载完成后解压， <code>tar -xzvf hadoop-2.10.0.tar.gz</code>，这里我将 hadoop 直接放在加目录下。</p><table><td>伪分布配置</td></table><h3 id="配置-hadoop">配置 hadoop</h3><p><strong>配置文件路径在</strong> <code>hadoop目录/etc/hadoop</code> <strong>中</strong> <em>hadooop-env.sh</em> 中 25 行左右，配置 <code>JAVA_HOME</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The java implementation to use.</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-openjdk</span><br></pre></td></tr></table></figure><p><em>core-site.xml</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定HDFS的nameservice --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://zachary-pc:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缓冲区大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定临时文件目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zachary/hadoop-2.10.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>hdfs-site.xml</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- configuration for NameNode:--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zachary/hadoop-2.10.0/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 块大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.blocksize<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>268435456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.handler.count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- configuration for DateNode:--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/zachary/hadoop-2.10.0/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定HDFS副本的数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>mapred-site.xml</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- configuration for ResourceManger: --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>zahcary-pc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- configuration of NodeManager: reducer获取数据方式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置外网只需要替换外网ip为真实ip，否则默认为 localhost:8088 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property&gt;</span></span><br><span class="line"><span class="comment">          &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span></span><br><span class="line"><span class="comment">          &lt;value&gt;外网ip:8088&lt;/value&gt;</span></span><br><span class="line"><span class="comment">  &lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>格式化 namenode，在 <code>hadoop目录/bin</code>，命令：<code>hdfs namenode -format</code> 。 启动命令在 <code>hadoop目录/sbin</code> 下， 启动 hadoop：<code>start-all.sh</code> 关闭 hadoop：<code>stop-all.sh</code></p><blockquote><p>启动 HDFS start-dfs.sh 启动 YARN start-yarn.sh 启动 NameNode hadoop-daemon.sh start namenode 启动 DataNode hadoop-daemon.sh start datanode 启动 ResourceManager yarn-daemon.sh start resourcemanager 启动 NodeManager yarn-daemon.sh start nodemanager</p></blockquote><ul class="task-list"><li><input type="checkbox" disabled="" />遇到问题 1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by org.apache.ibatis.reflection.Reflector (file:&#x2F;E:&#x2F;my_java_jar&#x2F;maven_repository&#x2F;org&#x2F;mybatis&#x2F;mybatis&#x2F;3.4.5&#x2F;mybatis-3.4.5.jar) to method java.lang.Class.checkPackageAccess(java.lang.SecurityManager,java.lang.ClassLoader,boolean)</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of org.apache.ibatis.reflection.Reflector</span><br><span class="line">WARNING: Use --illegal-access&#x3D;warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br></pre></td></tr></table></figure><p><code>警告非法反射访问错误</code>，我这里将<code>jdk-13</code>换成<code>jdk-8</code>解决了问题</p><h3 id="验证启动">验证启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;hadoop-2.10.0 ❯❯❯ jps</span><br><span class="line">5153 Jps</span><br><span class="line">4564 NodeManager</span><br><span class="line">4280 SecondaryNameNode</span><br><span class="line">3993 NameNode</span><br><span class="line">4090 DataNode</span><br><span class="line">4462 ResourceManager</span><br></pre></td></tr></table></figure><p>命令行输入<code>jps</code>，有以下 6 个进程就是成功启动了 通过浏览器输入：<code>http://ip:50070/</code> ，登入 HDFS 管理界面 <code>http://ip:8088/</code>，节点管理</p><h3 id="配置-ssh-免密登录">配置 ssh 免密登录</h3><p>命令行输入：<code>ssh-keygen -t rsa</code> 生成公钥密钥对，一直按回车直到生成结束。 执行结束后两个文件 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 其中前者为私钥，后者为公钥，文件位置在当前用户家目录的 <code>.ssh</code> 隐藏文件夹下。 然后命令行输入：<code>cat id_rsa.pub &gt;&gt; authorized_keys</code></p><ul class="task-list"><li><input type="checkbox" disabled="" />遇到问题 2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host zachary-pc port 22: Connection refused</span><br></pre></td></tr></table></figure><p>我这里是因为没有开启<code>sshd服务</code>，启动命令 <code>service sshd restart</code> 或者 <code>systemctl start sshd.service</code></p><h3 id="全局启动-hadoop">全局启动 hadoop</h3><p>在上面中，启动 hadoop 要在 hadoop 所在目录。 我们可以同过配置环境变量，使 hadoop 可以全局启动。 <code>/etc/profile</code> 中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/zachary/hadoop-2.10.0  <span class="comment"># hadoop所在目录</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure><p>重新编译 <code>profile</code> ，命令 ：<code>source /etc/profile</code></p><ul class="task-list"><li><input type="checkbox" disabled="" />遇到问题 3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permission denied: user&#x3D;dr.who, access&#x3D;READ_EXECUTE, inode&#x3D;&quot;&#x2F;tmp&quot;:root:super</span><br></pre></td></tr></table></figure><p>缺失权限; 解决办法：执行 <code>hdfs dfs -chmod -R 755 /tmp</code></p><table><td>分布配置</td></table><h3 id="主机名配置">主机名配置</h3><p>在 <code>/etc/hosts</code> 配置主机名，每一台服务器一样，类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.1    master</span><br><span class="line">192.168.10.2   slave_1</span><br><span class="line">192.168.10.3   slave_2</span><br></pre></td></tr></table></figure><h3 id="ssh-配置">ssh 配置</h3><p>将上面配置的公钥复制到从属服务器，命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub master</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave_1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave_2</span><br></pre></td></tr></table></figure><h3 id="hadoop-配置">hadoop 配置</h3><p>修改 <em>core-site.xml</em> :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="验证启动-1">验证启动</h3><p>启动命令同上，只需在主服务器启动即可。 <code>jps</code>命令查看，从属服务器有一下进程即启动成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ jps</span><br><span class="line">4545 NodeManager</span><br><span class="line">4371 DataNode</span><br><span class="line">4678 Jps</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何 shell 编程?</title>
      <link href="2020/03/04/009-Shell-edit/"/>
      <url>2020/03/04/009-Shell-edit/</url>
      
        <content type="html"><![CDATA[<p>基础的 shell 编程知识, 还有一些对应的小例子.</p><a id="more"></a><h1 id="shell-简介">shell 简介</h1><p><strong>shelle</strong>十一个命令行解释器，为用户提供了向<code>linux内核</code>发送请求以便运行程序的界面系统程序，用户可以用<code>shell</code>来启动、挂起、停止甚至编写程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[外层应用程序] --&gt; B[bash命令解释器]</span><br><span class="line">B --&gt; C[linux内核]</span><br><span class="line">C --&gt; D[硬件]</span><br></pre></td></tr></table></figure><h4 id="格式要求">格式要求</h4><p>以<code>#!/bin/bash</code>开头，指定 bash 解释器; 这里指定了<code>bash</code></p><h4 id="权限要求">权限要求</h4><p>执行 shell 脚本，一般给脚本添加<code>执行权限</code>,两种增加权限方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x xxx.sh</span><br><span class="line">sudo chmod 777 xxx.sh</span><br></pre></td></tr></table></figure><h4 id="执行方式">执行方式</h4><p>两种执行方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./xxx.sh</span><br><span class="line">sh xxx.sh  <span class="comment"># 没有执行权限也可执行</span></span><br></pre></td></tr></table></figure><h4 id="注释方法">注释方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line">：&lt;&lt;!</span><br><span class="line">多行注释</span><br><span class="line">注释内容</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h1 id="shell-变量">shell 变量</h1><h3 id="系统变量">系统变量</h3><p>系统预先定义的，可以直接使用，如：<code>$HOME</code>, <code>$PWD</code>, <code>$bash</code>, <code>$USER</code> 等 使用 <code>set</code> 命令可以查看当前 bash 中所有变量</p><h3 id="自定义变量">自定义变量</h3><p>通过 <code>变量名=值</code> 定义变量， 使用 <code>unset</code> 可以撤销变量; <code>readonly</code> 声明静态变量，该类型不可 <code>unset</code>。例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readonly</span> GREET=<span class="string">&quot;hello word&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;Zachary&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$GREET</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;NAME&#125;</span></span><br><span class="line"><span class="built_in">unset</span> NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>变量名可由字母、数字、下划线组成，不能以<code>数字开头</code></li><li><code>=</code> 两侧不能有空格</li><li>变量一般使用<code>大写</code>方式</li><li>调用变量时，需要使用 <code>$</code>符号或者<code>$&#123;&#125;</code></li></ul></blockquote><p>可以将<code>执行指令的结果</code>赋值给变量，例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">RESULT1=`ls -l /home`</span><br><span class="line">RESULT2=$(ls -l /home)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$RESULT1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$RESULT2</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>两种方式，推荐使用第二种 <code>RESULT=$(ls -l /home)</code></li></ul></blockquote><h3 id="位置参数变量">位置参数变量</h3><p>我们可以获取命令行输入的参数， <code>Sn</code> : <code>n</code>是数字，<code>$0</code>表示命令本身，从<code>$1～$9</code>, 表述命令行输入的第一到第九个参数，第十个及以上要使用<code>&#123;&#125;</code>, 如 <code>$&#123;10&#125;</code> <code>S*</code> : 所有参数，但看作一个整体 <code>S@</code> : 所有参数，但区分个体 <code>S#</code> : 所有参数个数</p><h4 id="预定义变量">预定义变量</h4><p>bash 设计者已经定义好的，可以直接使用， <code>$$</code>: 当前进程号（PID） <code>$!</code>: 后台运行的最后一个进程号（PID） <code>$?</code>: 最后一次执行命令的返回状态， <code>0</code> 表示正确执行，否则错误执行</p><h1 id="shell-运算">shell 运算</h1><p><strong>操作</strong>：加、减、乘、除、模; <strong>运算符号</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> <strong>形式</strong>：<code>$((运算式))</code>、<code>$[运算式]</code>、<code>expr a - b</code>, 例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">RESULT1=$(((<span class="number">1</span>+<span class="number">2</span>)*<span class="number">3</span>))</span><br><span class="line">RESULT2=$[(1+2)*3]</span><br><span class="line">TEMP=`expr 1 + 2`</span><br><span class="line">RESULT3=`expr <span class="variable">$TEMP</span> \* 3`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$RESULT1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$RESULT2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$RESULT3</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>expr</code> 方式中运算符两侧要有空格，整个元算式需要<code>反引号</code>包裹</li><li>推荐使用 <code>$[运算式]</code> 方式</li></ul></blockquote><h1 id="读取控制台输入">读取控制台输入</h1><p>基本语法：<code>read 选项 参数</code> <code>-p</code> 指定读取时的提示符 <code>-t</code> 指定读取等待时间，时间内未输入则不再等待输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -t 10 -p <span class="string">&quot;请输入:&quot;</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$A</span></span><br></pre></td></tr></table></figure><h1 id="shell-数组">shell 数组</h1><p>一对括号表示是数组，数组元素用<code>空格</code>符号分割开。如：<code>a=(1 2 3 4 5)</code></p><p><strong>获取</strong>:用<code>$\&#123;\#数组名\[@或\*\]\&#125;</code>可以得到数组长度, 用<code>$&#123;数组名[下标]&#125;</code>可以得到指定下标的值，下标是从 0 开始; 用<code>$&#123;数组名[@或*]&#125;</code> 可以得到整个数组内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 获取 ######</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#a[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#a[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[2]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[*]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>赋值</strong>：直接通过 <code>数组名[下标]=值</code>就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 赋值 ######</span></span><br><span class="line">a[1]=100</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：<code>unset 数组[下标]</code>可以清除相应的元素，不带下标，清除整个数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 删除 ######</span></span><br><span class="line"><span class="built_in">unset</span> a[1]</span><br><span class="line"><span class="comment"># unset 数组[下标] 不带下标，清除整个数据。</span></span><br><span class="line"><span class="built_in">unset</span> a</span><br></pre></td></tr></table></figure><p><strong>截取</strong>：截取数组 <code>$&#123;数组名[@或*]:起始位置:长度&#125;</code>返回字符串，中间用“空格”分开; 如果加上”()”，将得到切片数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 截取 ######</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]:0:3&#125;</span></span><br><span class="line"><span class="comment"># 如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</span></span><br><span class="line">c=(<span class="variable">$&#123;a[@]:1:4&#125;</span>)</span><br></pre></td></tr></table></figure><p><strong>替换</strong>：<code>$&#123;数组名[@或*]/查找字符/替换字符&#125;</code> 该操作不会改变原先数组内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 替换 ######</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]/3/100&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br><span class="line"><span class="comment"># 如果需要需求，重新赋值给变量a</span></span><br><span class="line">a=(<span class="variable">$&#123;a[@]/3/100&#125;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a[@]&#125;</span></span><br></pre></td></tr></table></figure><h1 id="条件判断">条件判断</h1><p><strong>形式</strong> <code>[ condition ]</code></p><blockquote><p>条件语句与<code>[]</code>之间要有空格，<code>[]</code>内是空返回<code>false</code></p></blockquote><p><strong>常用判断条件</strong></p><table><tr><td colspan="2">字符串类型</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>！=</td><td>不等于</td></tr><tr><td>-z 字符串</td><td>字符串的长度为零则为真</td></tr><tr><td>-n 字符串</td><td>字符串的长度不为零则为真</td></tr></table><table><tr><td colspan="2">整数类型</td></tr><tr><td>-lt</td><td>小于</td></tr><tr><td>-le</td><td>小于等于</td></tr><tr><td>-gt</td><td>大于</td></tr><tr><td>-ge</td><td>大于等于</td></tr><tr><td>-eq</td><td>等于</td></tr><tr><td>-ne</td><td>不等于</td></tr></table><table><tr><td colspan="2">文件权限</td></tr><tr><td>-r</td><td>有可读权限</td></tr><tr><td>-w</td><td>有可写权限</td></tr><tr><td>-x</td><td>有可执行权限</td></tr></table><table><tr><td colspan="2">文件类型</td></tr><tr><td>-e</td><td>是否文件存在</td></tr><tr><td>-f</td><td>是否是普通文件</td></tr><tr><td>-d</td><td>是否是目录</td></tr></table><h1 id="流程控制">流程控制</h1><h3 id="if-判断">if 判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ];<span class="keyword">then</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">elif</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐使用第二种</p></blockquote><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入年份后判断该年是否为闰年</span></span><br><span class="line"><span class="comment"># 能被4整除并且并不能被100整除的年份是闰年</span></span><br><span class="line"><span class="comment"># 能被400整除的年份也是闰年</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个年份:&quot;</span> YEAR</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$YEAR</span>&quot;</span> = <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;没有输入年份&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#使用正则测试变量 year 中是否包含大小写字母</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$YEAR</span>&quot;</span> =~ [a‐Z] ]];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你输入的不是数字&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 判断是否为闰年</span></span><br><span class="line"><span class="keyword">if</span> [ $[YEAR % 4] -eq 0 ] &amp;&amp; [ $[YEAR % 100] -ne 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$YEAR</span>年是闰年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ $[YEAR % 400] -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$YEAR</span>年是闰年&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$YEAR</span>年不是闰年&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="case-语句">case 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$variable_name</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;value&quot;</span>)  <span class="comment"># 传入值与value相等执行content的语句</span></span><br><span class="line">content</span><br><span class="line">;;</span><br><span class="line"><span class="string">&quot;value&quot;</span>)</span><br><span class="line">content</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断用户输入的数据类型(字母、数字或其他)</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个字符:&quot;</span> KEY</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$KEY</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">[a‐z]|[A‐Z])</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;字母&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">[0‐9])</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;数字&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;空格、功能键或其他控制字符&quot;</span></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="for-循环">for 循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> value1 value2 value3 ...</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((初始值;循环控制条件;变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印国际象棋棋盘</span></span><br><span class="line"><span class="comment"># 设置两个变量,i 和 j,一个代表行,一个代表列,国际象棋为 8*8 棋盘</span></span><br><span class="line"><span class="comment"># i=1 是代表准备打印第一行棋盘,第 1 行棋盘有灰色和蓝色间隔输出,总共为 8 列</span></span><br><span class="line"><span class="comment"># i=1,j=1 代表第 1 行的第 1 列;i=2,j=3 代表第 2 行的第 3 列</span></span><br><span class="line"><span class="comment"># 棋盘的规律是 i+j 如果是偶数,就打印蓝色色块,如果是奇数就打印灰色色块</span></span><br><span class="line"><span class="comment"># 使用 echo ‐ne 打印色块,并且打印完成色块后不自动换行,在同一行继续输出其他色块</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..8&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> &#123;1..8&#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  sum=$[i+j]</span><br><span class="line"><span class="keyword">if</span> [  $[sum%2] -eq 0 ];<span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> -ne <span class="string">&quot;\033[46m  \033[0m&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;\033[47m  \033[0m&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 100 以内的所有正整数相加求和(1+2+3+4...+100)</span></span><br><span class="line">SUM=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 100`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  SUM=$[SUM+i]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;总和是:<span class="variable">$SUM</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="while-循环">while 循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">content</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取用户输入的账户名称,将账户名写入到数组保存</span></span><br><span class="line"><span class="comment"># 定义数组名称为 name,数组的下标为 i,小标从 0 开始,每输入一个账户名,下标加 1,继续存下一个账户</span></span><br><span class="line"><span class="comment"># 最后,输入 over,脚本输出总结性信息后脚本退出</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入账户名,输入 over 结束:&quot;</span> KEY</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$KEY</span> == <span class="string">&quot;over&quot;</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">NAME[<span class="variable">$i</span>]=<span class="variable">$KEY</span></span><br><span class="line"><span class="built_in">let</span> i++</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;总账户名数量:<span class="variable">$&#123;#NAME[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;NAME[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="函数">函数</h1><h3 id="系统函数">系统函数</h3><p><code>basename</code></p><h3 id="自定义函数">自定义函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func_name</span></span>()&#123;</span><br><span class="line">content</span><br><span class="line"><span class="built_in">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line">func_name param1 param2 ...</span><br></pre></td></tr></table></figure><blockquote><p><code>function</code> 关键字可以不写，但推荐写; 可以没有<code>return</code></p></blockquote><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本生成一个 100 以内的随机数,提示用户猜数字,根据用户的输入,提示用户猜对了,</span></span><br><span class="line"><span class="comment"># 猜小了或猜大了,直至用户猜对脚本结束。</span></span><br><span class="line"><span class="comment"># RANDOM 为系统自带的系统变量,值为 0‐32767的随机数</span></span><br><span class="line"><span class="comment"># 使用取余算法将随机数变为 1‐100 的随机数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">guess</span></span>()&#123;</span><br><span class="line">        num=$[RANDOM%100+1]</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$num</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>  :</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">read</span> -p <span class="string">&quot;计算机生成了一个 1‐100 的随机数,你猜: &quot;</span> cai</span><br><span class="line">            <span class="keyword">if</span> [ <span class="variable">$cai</span> -eq <span class="variable">$num</span> ]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;恭喜,猜对了&quot;</span></span><br><span class="line">                <span class="built_in">exit</span></span><br><span class="line">                <span class="keyword">elif</span> [ <span class="variable">$cai</span> -gt <span class="variable">$num</span> ]</span><br><span class="line">                <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">&quot;猜大了&quot;</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">&quot;猜小了&quot;</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">guess</span><br></pre></td></tr></table></figure><p>暂时这么多笔记</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯及python实现案例</title>
      <link href="2020/03/02/008-Bayes-python/"/>
      <url>2020/03/02/008-Bayes-python/</url>
      
        <content type="html"><![CDATA[<h1 id="贝叶斯方法">贝叶斯方法</h1><p><strong>贝叶斯方法</strong>是以<code>贝叶斯定理</code>为基础，使用概率统计的知识对样本数据集进行分类。由于其有着坚实的数学基础，贝叶斯分类算法的误判率是很低的。贝叶斯分类算法在数据集较大的情况下表现出较高的准确率，同时算法本身也比较简单。</p><blockquote><p><strong>概率</strong>，亦称“或然率”，它是反映随机事件出现的<code>可能性（likelihood)</code>大小。某事件 A 出现的概率，常用<span class="math inline">\(P(A)\)</span>表示。</p></blockquote><h3 id="贝叶斯定理">贝叶斯定理</h3><p><strong>贝叶斯定理</strong>源于英国数学贝叶斯（Thomas Bayes）生前为了解决<code>逆向概率</code>问题的一篇文章。</p><blockquote><ul><li><strong>正向概率</strong>: 假设袋子里面有 n 个白球，m 个黑球，随意拿一个出来，摸出黑球的概率是多少？这样的就是正向概率问题。</li><li><strong>逆向概率</strong>: 还是有一个袋子，假设我们不知道袋子里黑白球的比例，当我们进行一定的随意的摸取后，根据摸出球的颜色，推测袋子里黑白球的比例。这样的就是逆向概率问题。</li></ul></blockquote><h5 id="贝叶斯解决的问题">贝叶斯解决的问题</h5><p>由于实际上的问题是不确定的，而自身的观察能力是有限的。所以有时我们需要通过观察的结果进行推测。贝叶斯方法基于假设的<code>先验概率</code>、给定假设下观察到不同数据的概率以及观察到的数据本身而得出的。其方法为，将关于未知参数的先验信息与样本信息综合，再根据<code>贝叶斯公式</code>，得出后验信息，然后根据后验信息去推断未知参数的方法。</p><blockquote><p><strong>先验概率</strong>: 是指根据以往经验和分析得到的概率。<strong>事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。</strong></p></blockquote><h3 id="贝叶斯公式">贝叶斯公式</h3><p>假设一个学校共有<span class="math inline">\(N\)</span>个学生，有 60%男生和 40%女生。女生穿裤子的人数和穿裙子的人数相等，所有男生穿裤子。<strong>我们想求解一个穿长裤的学生是女生的概率。记为：<span class="math inline">\(P(girl|pants)\)</span></strong></p><p><span class="math display">\[P(girl|pants)=\frac{穿长裤女生人数}{穿长裤总人数}\]</span> <span class="math display">\[穿长裤总人数=总人数\cdot 穿长裤的概率=N\cdot P(pants)\]</span></p><p>那么穿长裤女生人数为<strong>总人数乘以女生的概率再乘以女生中穿长裤的概率</strong>：<span class="math inline">\(N\cdot P(girl)\cdot P(pants|girl)\)</span>，所以： <span class="math display">\[P(girl|pants)=\frac{N\cdot P(girl)\cdot P(pants|girl)}{N\cdot P(pants)}\]</span></p><p>可以看出与总人数<span class="math inline">\(N\)</span>无关，于是： <span class="math display">\[P(girl|pants)=\frac{P(girl)\cdot P(pants|girl)}{P(pants)}\]</span></p><p>我们可以计算出<code>后验概率</code><span class="math inline">\(P(girl|pants)=\frac{0.4\cdot 0.5}{0.5×0.4 + 1×0.6}=0.25\)</span></p><blockquote><p><strong>后验概率</strong>:指在得到“结果”的信息后重新修正的概率。<strong>事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。</strong></p></blockquote><p>这样我们也得到了<code>贝叶斯公式</code>，即<span class="math inline">\(B\)</span>条件下<span class="math inline">\(A\)</span>的概率(记作<span class="math inline">\(P(A|B)\)</span>)和<span class="math inline">\(A\)</span>条件下<span class="math inline">\(B\)</span>的概率(记作<span class="math inline">\(P(B|A)\)</span>)的关系： <span class="math display">\[P(A|B)=\frac{P(B|A)P(A)}{P(B)}\]</span></p><p>穿长裤的概率=是女生概率 x 女生穿长裤概率+是男生概率 x 男生穿长裤概率，于是: <span class="math display">\[P(pants)=P(girl)\cdot P(pants|girl)+P(boy)\cdot P(pants|boy)\]</span></p><p>根据全概率公式: <span class="math display">\[P(B)=\displaystyle\sum_{i=1}^nP(B|A_i)P(A_i)\]</span></p><p>这样，必然事件被分为 n 个不相交的子事件，事件<span class="math inline">\(B\)</span>的条件概率为给定每一个子事件<span class="math inline">\(A_i(i=1,2,...,n)\)</span>下事件 B 的条件概率之和。那么，给定事件<span class="math inline">\(B(P(B)&gt;0)\)</span>，事件的条件概率可以写为： <span class="math display">\[P(A_k|B)=\frac{P(B|A_k)P(A_k)}{P(B)}=\frac{P(B|A_k)P(A_k)}{\sum_{i=1}^nP(B|A_i)P(A_i)}\quad(k=1,2,...,n)\]</span></p><p>这就是<code>贝叶斯定理</code>。</p><h1 id="朴素贝叶斯">朴素贝叶斯</h1><p>朴素贝叶斯使用的就是贝叶斯方法，使用概率统计的知识对样本数据集进行分类，但是在条件上做了一定的限制。</p><blockquote><p><strong>分类方式</strong>：在给定的条件下，计算是各个类别的概率，根据<strong>最大似然估计</strong>，是哪个类别的概率最高，就分类为该类别</p></blockquote><p>朴素贝叶斯<strong>假设特征之间（朴素）独立，即特征值相互之间是没有影响的</strong>。这是一个非常强的假设，现实中往往很难成立，但简化了问题的复杂度，使求解变得简单。</p><h3 id="概率模型">概率模型</h3><p>输入特征向量为<span class="math inline">\(x\)</span>，<span class="math inline">\(x\in X\)</span>，其中<span class="math inline">\(X\)</span>为<span class="math inline">\(n\)</span>维向量集合;</p><p>输出类类别为<span class="math inline">\(y\)</span>，<span class="math inline">\(y\in Y\)</span>，其中<span class="math inline">\(Y=\{c_1,c_2,...,c_j\}\)</span>;</p><p>得到训练数据集：<span class="math inline">\(T=\{(x_1,y_1),(x_2,y_2),...,(x_m,y_m)\}\)</span></p><p>朴素贝叶斯算法通过训练集学习联合概率分布<span class="math inline">\(P(X,Y)\)</span>,<span class="math inline">\(联合概率=先验概率x条件概率\)</span>,</p><p>其中<strong>先验概率</strong>为：<span class="math inline">\(P(Y=c_k)\quad k=1,2,...,j\)</span></p><p><strong>条件概率</strong>为<span class="math display">\[P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},X^{(2)}=x^{(2)},...,X^{(n)}x^{(n)}|Y=c_k)=\displaystyle\prod_{l=1}^nP(X^{(l)}=x^{(l)}|Y=c_k)\]</span></p><p>分类时,对给定输入<span class="math inline">\(x\)</span>,通过学习到的模型计算后验概率分布<span class="math inline">\(P(Y=c_k|X=x)\)</span>,将后验概率最大的类作为输入<span class="math inline">\(x\)</span>的类输出.后验概率根据贝叶斯定理计算:</p><p><span class="math display">\[P(Y=c_k|X=x)=\frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_{i=1}^kP(X=x|Y=c_i)P(Y=c_i)}=\frac{P(Y=c_k)\prod_{l=1}^nP(X^{(l)}=x^{(l)}|Y=c_k)}{\sum_{i=1}^nP(Y=c_k)\prod_{l=1}^nP(X^{(l)}=x^{(l)}|Y=c_k)}\]</span></p><p>上面的公式是后验概率分布中的一项,对于相同输入<span class="math inline">\(x\)</span>下不同类别的<code>后验概率</code>的分母相同,所以我们可以简化为只比较分子的大小就可以确定最终的结果,最终类输出为概率最大对应的类别:</p><p><span class="math display">\[y=argmax_{c_k}P(Y=c_k)\displaystyle\prod_{l=1}^nP(X^{(l)}=x^{(l)}|Y=c_k)\]</span></p><p>可以通过<code>右式取对数</code>的方式，将连乘化为求和，简化运算得：</p><p><span class="math display">\[y=argmax_{c_k}\log P(Y=c_k)+\displaystyle\sum_{l=1}^n\log P(X^{(l)}=x^{(l)}|Y=c_k)\]</span></p><p>这就是,<code>朴素贝叶斯概率模型</code>。</p><h3 id="拉普拉斯平滑">拉普拉斯平滑</h3><p><strong>拉普拉斯平滑系数</strong>作用是解决<code>零概率</code>问题。就是在计算实例的概率时，如果某个量 <span class="math inline">\(x\)</span>，在观察样本库（训练集）中没有出现过，会导致整个实例的概率结果是 0，不能因为一个事件没有观察到就武断的认为该事件的概率是 0。</p><p>所以假定训练样本很大时，每个分量 <span class="math inline">\(x\)</span> 的计数加 <code>1</code> 造成的估计概率变化可以忽略不计，但可以方便有效的避免零概率问题。</p><p><span class="math inline">\(P(X_i│Y)=（N_i+α)/(N+αm)\)</span></p><p><span class="math inline">\(\alpha\)</span> 为指定的系数一般为 <code>1</code>，<span class="math inline">\(m\)</span> 为训练集中统计的特征值个数。</p><h3 id="拼写检查案例">拼写检查案例</h3><p>导入使用模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br></pre></td></tr></table></figure><p>处理训练数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">words</span>(<span class="params">text</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将训练集转成小写，提取出所有单词</span></span><br><span class="line"><span class="string">params: text 训练集文本</span></span><br><span class="line"><span class="string">return: list 单词列表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> re.findall(<span class="string">&#x27;[a-z]+&#x27;</span>, text.lower())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">features</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">单词频率统计</span></span><br><span class="line"><span class="string">params: list 单词列表</span></span><br><span class="line"><span class="string">return: dict 词频字典</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    model = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> features:</span><br><span class="line">        model[f] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">WORDS = train(words(<span class="built_in">open</span>(<span class="string">&#x27;words.txt&#x27;</span>).read()))</span><br></pre></td></tr></table></figure><p>计算编辑距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alphabet = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_distance_1</span>(<span class="params">word</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;返回编辑距离为1的set&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>([word[<span class="number">0</span>:i]+word[i+<span class="number">1</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] +                     <span class="comment"># 删除一个字母</span></span><br><span class="line">               [word[<span class="number">0</span>:i]+word[i+<span class="number">1</span>]+word[i]+word[i+<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>)] + <span class="comment"># 交换两个字母位置</span></span><br><span class="line">               [word[<span class="number">0</span>:i]+c+word[i+<span class="number">1</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">for</span> c <span class="keyword">in</span> alphabet] + <span class="comment"># 改变一个字母</span></span><br><span class="line">               [word[<span class="number">0</span>:i]+c+word[i:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>) <span class="keyword">for</span> c <span class="keyword">in</span> alphabet])  <span class="comment"># 插入一个字母</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_distance_2</span>(<span class="params">word</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;返回编辑距离为2的set&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(e2 <span class="keyword">for</span> e1 <span class="keyword">in</span> edit_distance_1(word) <span class="keyword">for</span> e2 <span class="keyword">in</span> edit_distance_1(e1))</span><br></pre></td></tr></table></figure><p>拼写检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">known</span>(<span class="params">words</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">返回正确单词的set，默认WORDS中存在的为正确</span></span><br><span class="line"><span class="string">params： 单词集合</span></span><br><span class="line"><span class="string">return： 正确单词集合</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> w <span class="keyword">in</span> WORDS)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">correct</span>(<span class="params">word</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;拼写纠正&quot;&quot;&quot;</span></span><br><span class="line">    candidates = known([word]) <span class="keyword">or</span> known(edit_distance_1(word)) <span class="keyword">or</span> know(edit_distance_2(word)) <span class="keyword">or</span> [word]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(candidates, key=<span class="keyword">lambda</span> w: WORDS[w])</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">correct(<span class="string">&#x27;liko&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>'like'</code></p></blockquote><h3 id="文本分类案例">文本分类案例</h3><p>导入使用模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br></pre></td></tr></table></figure><p>加载数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的是sklearn自带的数据 (18000篇新闻文章，一共涉及到20种话题)</span></span><br><span class="line">news = fetch_20newsgroups(subset=<span class="string">&quot;all&quot;</span>)</span><br><span class="line">pprint(<span class="built_in">list</span>(news.target_names))</span><br></pre></td></tr></table></figure><blockquote><p><code>['alt.atheism',</code> <code>'comp.graphics',</code> <code>'comp.os.ms-windows.misc',</code> <code>'comp.sys.mac.hardware',</code> <code>'comp.windows.x',</code> <code>'misc.forsale',</code> <code>'rec.autos',</code> <code>'rec.motorcycles',</code> <code>'rec.sport.baseball',</code> <code>'rec.sport.hockey',</code> <code>'sci.crypt',</code> <code>'sci.electronics',</code> <code>'sci.med',</code> <code>'sci.space',</code> <code>'soc.religion.christian',</code> <code>'talk.politics.guns',</code> <code>'talk.politics.mideast',</code> <code>'talk.politics.misc',</code> <code>'talk.religion.misc']</code></p></blockquote><p>数据处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行数据分割，分成训练集和测试集</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(news.data, news.target, test_size=<span class="number">0.25</span>)</span><br><span class="line"><span class="comment"># 对数据集进行特征抽取</span></span><br><span class="line">tf = TfidfVectorizer()</span><br><span class="line"><span class="comment"># 以训练集的列表进行重要行统计</span></span><br><span class="line">x_train = tf.fit_transform(x_train)</span><br><span class="line">print(x_train.shape)</span><br></pre></td></tr></table></figure><blockquote><p><code>(14134, 145231)</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x_test = tf.transform(x_test)</span><br><span class="line"><span class="comment"># 进行朴素贝叶斯算法预测</span></span><br><span class="line">mlt = MultinomialNB(alpha=<span class="number">1.0</span>)</span><br><span class="line">print(x_train)</span><br><span class="line">mlt.fit(x_train, y_train)</span><br><span class="line">y_predict = mlt.predict(x_test)</span><br><span class="line"><span class="comment"># 得出准确率</span></span><br><span class="line">print(<span class="string">&quot;预测的文章类别为：&quot;</span>, y_predict)</span><br><span class="line"><span class="comment"># 得出准确率</span></span><br><span class="line">print(<span class="string">&quot;准确率为：&quot;</span>, mlt.score(x_test, y_test))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;每个类别的精确率和召回率：\n&quot;</span>, classification_report(y_test, y_predict, target_names=news.target_names))</span><br></pre></td></tr></table></figure><blockquote><p><code>预测的文章类别为： [ 2 10 3 ... 15 17 8]</code> <code>准确率为： 0.8571731748726655</code></p></blockquote><pre><code>    每个类别的精确率和召回率：                               precision    recall  f1-score   support             alt.atheism       0.84      0.84      0.84       173           comp.graphics       0.91      0.76      0.83       268 comp.os.ms-windows.misc       0.85      0.82      0.83       250comp.sys.ibm.pc.hardware       0.70      0.85      0.77       232   comp.sys.mac.hardware       0.96      0.82      0.88       258          comp.windows.x       0.92      0.87      0.89       235            misc.forsale       0.91      0.69      0.78       229               rec.autos       0.93      0.91      0.92       266         rec.motorcycles       0.97      0.94      0.95       266      rec.sport.baseball       0.96      0.94      0.95       262        rec.sport.hockey       0.92      0.97      0.94       257               sci.crypt       0.77      0.99      0.86       245         sci.electronics       0.85      0.83      0.84       231                 sci.med       0.96      0.88      0.92       247               sci.space       0.87      0.96      0.91       237  soc.religion.christian       0.60      0.99      0.75       255      talk.politics.guns       0.77      0.96      0.85       233   talk.politics.mideast       0.95      0.98      0.96       233      talk.politics.misc       0.99      0.66      0.79       171      talk.religion.misc       0.97      0.19      0.32       164            accuracy                           0.86      4712           macro avg       0.88      0.84      0.84      4712        weighted avg       0.88      0.86      0.85      4712</code></pre><h1 id="总结">总结</h1><h5 id="优点">优点：</h5><ul><li>朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。</li><li>对缺失数据不太敏感，算法也比较简单，常用于文本分类。</li><li>分类准确度高，速度快。</li></ul><h5 id="缺点">缺点：</h5><ul><li>需要知道先验概率<span class="math inline">\(P(F1,F2,…|C)\)</span>，因此在某些时候会由于假设的先验模型的原因导致预测效果不佳。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归及python代码实现</title>
      <link href="2020/02/28/007-Logic-regression-python/"/>
      <url>2020/02/28/007-Logic-regression-python/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归">逻辑回归</h1><p>一种广义的线性回归分析模型，逻辑回归虽然带有回归字样，但是逻辑回归属于<strong>分类算法</strong>。逻辑回归可以进行多分类操作，但由逻辑回归算法本身性质决定其更常用于二分类。</p><p><strong>逻辑回归</strong>：线性回归可以预测连续值，但是不能解决分类问题，我们需要根据预测的结果判定其属于正类还是负类。所以逻辑回归就是将线性回归的结果，通过 <code>sigmoid</code> 函数映射到 <span class="math inline">\((0,1)\)</span> 之间。</p><p><strong>分类的本质</strong>：在空间中找到一个决策边界来完成分类的决策。==逻辑回归的决策边界：可以是非线性的==</p><h1 id="sigmoid-函数">Sigmoid 函数</h1><p><span class="math display">\[g(z)=\frac{1}{1+e^{-z}}\]</span></p><figure><img src="https://img-blog.csdnimg.cn/20200227224036511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="sigmoid" /><figcaption aria-hidden="true">sigmoid</figcaption></figure><p><strong>为什么使用 sigmoid 函数</strong></p><ol type="1"><li>自变量取值范围任意实数，值域 <span class="math inline">\([0,1]\)</span>，利于分类</li><li>数学特性好，求导容易：<span class="math inline">\(g′(z)= g(z)\cdot(1-g(z))\)</span></li></ol><h1 id="推导过程">推导过程</h1><p>解释：将任意的输入映射到 <span class="math inline">\([0,1]\)</span> 的区间。我们在线性回归中可以得到一个预测值，再将该值映射到 Sigmoid 函数中，就完成了由值到概率的转换，也就是分类任务</p><p><strong>预测函数</strong>：<span class="math inline">\(h(\theta)=\frac{1}{1+e^{-\theta^Tx}}\)</span>，其中 <span class="math inline">\(\theta_0+\theta_1x_1+ ... +\theta_nx_n=\displaystyle\sum_{i=1}^n=\theta^Tx\)</span></p><p><strong>分类任务</strong>：<span class="math inline">\(\begin{cases} P(y=1|x;\theta)=h_\theta(x) \\ P(y=0|x;\theta)=1-h_\theta(x) \end{cases}\)</span>，整合：<span class="math inline">\(P(y|x;\theta)=(h_\theta(x))^y(1-h_\theta(x))^{1-y}\)</span></p><p>解释：对于二分类任务<span class="math inline">\((0,1)\)</span>，整合后 y 取 0 只保留 <span class="math inline">\((1-h_\theta(x))^{1-y}\)</span>，y 取 1 只保留<span class="math inline">\((h_\theta(x))^y\)</span></p><p><strong>似然函数</strong>：<span class="math inline">\(L(\theta)=\displaystyle\prod_{i=1}^mP(y_i|x_i;\theta)=\displaystyle\prod_{i=1}^m(h_\theta(x_i))^{y_i}(1-h_\theta(x_i))^{1-{y_i}}\)</span></p><p>用对数似然降低复杂度</p><p><strong>对数似然</strong>：<span class="math inline">\(l(\theta)=\log L(\theta)=\displaystyle\sum_{i=1}^m(y_i\log h_\theta(x_i)+(1-y_i)\log (1-h_\theta(x_i)))\)</span></p><p>此时应用梯度上升求最大值，引入<span class="math inline">\(J(\theta)=-\frac{1}{m}l(\theta)\)</span>，反之梯度下降求最小值</p><p>求导过程：</p><p><span class="math inline">\(\frac{\delta}{\delta_{\theta_j}}J(\theta)=-\frac{1}{m}\displaystyle\sum_{i=1}^m (y_i\frac{1}{h_\theta(x_i)}\frac{\delta}{\delta_{\theta_j}}h_\theta(x_i)-(1-y_i)\frac{1}{1-h_\theta(x_i)}\frac{\delta}{\delta_{\theta_j}}h_\theta(x_i))\)</span></p><p><span class="math inline">\(=-\frac{1}{m}\displaystyle\sum_{i=1}^m (y_i\frac{1}{g(\theta^Tx_i)}-(1-y_i)\frac{1}{1-g(\theta^Tx_i)})\frac{\delta}{\delta_{\theta_j}}g(\theta^Tx_i)\)</span></p><p><span class="math inline">\(=-\frac{1}{m}\displaystyle\sum_{i=1}^m (y_i\frac{1}{g(\theta^Tx_i)}-(1-y_i)\frac{1}{1-g(\theta^Tx_i)})g(\theta^Tx_i)(1-g(\theta^Tx_i))\frac{\delta}{\delta_{\theta_j}}\theta^Tx_i\)</span></p><p><span class="math inline">\(=-\frac{1}{m}\displaystyle\sum_{i=1}^m (y_i(1-g(\theta^Tx_i))-(1-y_i)g(\theta^Tx_i))x_i^j\)</span></p><p><span class="math inline">\(=-\frac{1}{m}\displaystyle\sum_{i=1}^m (y_i-g(\theta^Tx_i))x_i^j\)</span></p><p><span class="math inline">\(=\frac{1}{m}\displaystyle\sum_{i=1}^m (h_\theta(x_i)-y_i)x_i^j\)</span></p><p><strong>参数更新</strong>：<span class="math inline">\(\theta_j:=\theta_j-\alpha\frac{1}{m}\displaystyle\sum_{i=1}^m (h_\theta(x_i)-y_i)x_i^j\)</span></p><h2 id="多分类问题">多分类问题</h2><p>逻辑回归常用与解决二分类问题，那么它可以用来解决多分类问题吗？</p><p>其实也是可以的。之前的逻辑回归可以很好地解决二分类问题，一个样本不是正类就是父类，关于多分类问题的求解可以依靠这个基本原理。常用的多分类思路是“一对多”（one vs all），它的基本思想简单粗暴，构建多个分类器（每个分类器针对一个估计函数）针对每个类别，每个分类器学会识别“是或者不是”该类别，这样就简化为多个二分类问题。用多个逻辑回归作用于待预测样本，返回的最高值作为最后的预测值。</p><h1 id="python-实现">python 实现</h1><blockquote><p>通过建立一个逻辑回归模型来预测一个学生是否被大学录取。假设知道两次考试的成绩。有以前的申请人的历史数据，你可以用它作为逻辑回归的训练集，根据考试成绩估计入学概率。</p></blockquote><p>导入所需包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure><p>读取并查看<a href="https://pan.baidu.com/s/1xU_JH55X3wDrW2M5zhSXUw">数据</a>(提取码: v7cd)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&quot;LogiReg_data.txt&quot;</span></span><br><span class="line">pdData = pd.read_csv(path, header=<span class="literal">None</span>, names=[<span class="string">&#x27;exam_1&#x27;</span>, <span class="string">&#x27;exam_2&#x27;</span>, <span class="string">&#x27;admitted&#x27;</span>])</span><br><span class="line">pdData.head()</span><br><span class="line">pdData.shape</span><br></pre></td></tr></table></figure><pre><code>    exam_1  exam_2  admitted0   34.623660   78.024693   01   30.286711   43.894998   02   35.847409   72.902198   03   60.182599   86.308552   14   79.032736   75.344376   1(100, 3)</code></pre><p>根据 <code>admitted</code> 画出数据图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">positive = pdData[pdData[<span class="string">&#x27;admitted&#x27;</span>] == <span class="number">1</span>] <span class="comment"># returns the subset of rows such Admitted = 1, i.e. the set of *positive* examples</span></span><br><span class="line">negative = pdData[pdData[<span class="string">&#x27;admitted&#x27;</span>] == <span class="number">0</span>] <span class="comment"># returns the subset of rows such Admitted = 0, i.e. the set of *negative* examples</span></span><br><span class="line"></span><br><span class="line">plt.subplots(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">plt.scatter(positive[<span class="string">&#x27;exam_1&#x27;</span>], positive[<span class="string">&#x27;exam_2&#x27;</span>], s=<span class="number">30</span>, c=<span class="string">&#x27;b&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;Admitted&#x27;</span>)</span><br><span class="line">plt.scatter(negative[<span class="string">&#x27;exam_1&#x27;</span>], negative[<span class="string">&#x27;exam_2&#x27;</span>], s=<span class="number">30</span>, c=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;x&#x27;</span>, label=<span class="string">&#x27;Not Admitted&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Exam_1 Score&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Exam_2 Score&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0, 0.5, &#39;Exam_2 Score&#39;)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200228002518441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p>逻辑回归类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;逻辑回归类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.STOP_ITER = <span class="number">0</span></span><br><span class="line">        self.STOP_COST = <span class="number">1</span></span><br><span class="line">        self.STOP_GRAD = <span class="number">2</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">self, z</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            sigmoid函数</span></span><br><span class="line"><span class="string">            将预测值映射成概率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">model</span>(<span class="params">self, X, theta</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            预测函数：返回预测值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.sigmoid(np.dot(X, theta.T))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost</span>(<span class="params">self, X, y, theta</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;损失函数&quot;&quot;&quot;</span></span><br><span class="line">        left = np.multiply(-y, np.log(self.model(X, theta)))</span><br><span class="line">        right = np.multiply(<span class="number">1</span> - y, np.log(<span class="number">1</span> - self.model(X, theta)))</span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">sum</span>(left - right) / (<span class="built_in">len</span>(X))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">self, X, y, theta</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算梯度&quot;&quot;&quot;</span></span><br><span class="line">        grad = np.zeros(theta.shape)</span><br><span class="line">        error = (self.model(X, theta)- y).ravel()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theta.ravel())): <span class="comment">#for each parmeter</span></span><br><span class="line">            term = np.multiply(error, X[:,j])</span><br><span class="line">            grad[<span class="number">0</span>, j] = np.<span class="built_in">sum</span>(term) / <span class="built_in">len</span>(X)</span><br><span class="line">        <span class="keyword">return</span> grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stopCriterion</span>(<span class="params">self, <span class="built_in">type</span>, value, threshold</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            停止标准函数：</span></span><br><span class="line"><span class="string">                1.迭代次数</span></span><br><span class="line"><span class="string">                2.损失值变化</span></span><br><span class="line"><span class="string">                3.梯度变化</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == self.STOP_ITER:</span><br><span class="line">            <span class="keyword">return</span> value &gt; threshold</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span> == self.STOP_COST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(value[-<span class="number">1</span>]-value[-<span class="number">2</span>]) &lt; threshold</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span> == self.STOP_GRAD:</span><br><span class="line">            <span class="keyword">return</span> np.linalg.norm(value) &lt; threshold</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffleData</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;洗牌&quot;&quot;&quot;</span></span><br><span class="line">        np.random.shuffle(data)</span><br><span class="line">        cols = data.shape[<span class="number">1</span>]</span><br><span class="line">        X = data[:, <span class="number">0</span>:cols-<span class="number">1</span>]</span><br><span class="line">        y = data[:, cols-<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> X, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">descent</span>(<span class="params">self, data, theta, batchSize, stopType, thresh, alpha</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;梯度下降求解&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        init_time = time.time()</span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># 迭代次数</span></span><br><span class="line">        k = <span class="number">0</span> <span class="comment"># batch</span></span><br><span class="line">        X, y = self.shuffleData(data)</span><br><span class="line">        grad = np.zeros(theta.shape) <span class="comment"># 计算的梯度</span></span><br><span class="line">        costs = [self.cost(X, y, theta)] <span class="comment"># 损失值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            grad = self.gradient(X[k:k+batchSize], y[k:k+batchSize], theta)</span><br><span class="line">            k += batchSize <span class="comment">#取batch数量个数据</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;= self.n:</span><br><span class="line">                k = <span class="number">0</span></span><br><span class="line">                X, y = self.shuffleData(data) <span class="comment">#重新洗牌</span></span><br><span class="line">            theta = theta - alpha*grad <span class="comment"># 参数更新</span></span><br><span class="line">            costs.append(self.cost(X, y, theta)) <span class="comment"># 计算新的损失</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> stopType == self.STOP_ITER:</span><br><span class="line">                value = i</span><br><span class="line">            <span class="keyword">elif</span> stopType == self.STOP_COST:</span><br><span class="line">                value = costs</span><br><span class="line">            <span class="keyword">elif</span> stopType == self.STOP_GRAD:</span><br><span class="line">                value = grad</span><br><span class="line">            <span class="keyword">if</span> self.stopCriterion(stopType, value, thresh):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theta, i-<span class="number">1</span>, costs, grad, time.time() - init_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X, theta</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> self.model(X, theta)]</span><br></pre></td></tr></table></figure><p>处理数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pdData.insert(<span class="number">0</span>, <span class="string">&#x27;Ones&#x27;</span>, <span class="number">1</span>) <span class="comment"># in a try / except structure so as not to return an error if the block si executed several times</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set X (training data) and y (target variable)</span></span><br><span class="line">orig_data = pdData.as_matrix() <span class="comment"># convert the Pandas representation of the data to an array useful for further computations</span></span><br><span class="line">cols = orig_data.shape[<span class="number">1</span>]</span><br><span class="line">X = orig_data[:,<span class="number">0</span>:cols-<span class="number">1</span>]</span><br><span class="line">y = orig_data[:,cols-<span class="number">1</span>:cols]</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert to numpy arrays and initalize the parameter array theta</span></span><br><span class="line">theta = np.zeros([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">print(X[:<span class="number">5</span>])</span><br><span class="line">print(y[:<span class="number">5</span>])</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure><pre><code>array([[ 1.        , 34.62365962, 78.02469282],       [ 1.        , 30.28671077, 43.89499752],       [ 1.        , 35.84740877, 72.90219803],       [ 1.        , 60.18259939, 86.3085521 ],       [ 1.        , 79.03273605, 75.34437644]])       array([[0.],       [0.],       [0.],       [1.],       [1.]])       array([[0., 0., 0.]])</code></pre><p>功能函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">lr = LogisticRegression(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runExpe</span>(<span class="params">data, theta, batchSize, stopType, thresh, alpha</span>):</span></span><br><span class="line"></span><br><span class="line">    theta, <span class="built_in">iter</span>, costs, grad, dur = lr.descent(data, theta, batchSize, stopType, thresh, alpha)</span><br><span class="line">    print(theta)</span><br><span class="line">    name = <span class="string">&quot;Original&quot;</span> <span class="keyword">if</span> (data[:,<span class="number">1</span>]&gt;<span class="number">2</span>).<span class="built_in">sum</span>() &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">&quot;Scaled&quot;</span></span><br><span class="line">    name += <span class="string">f&quot; data / learning rate: <span class="subst">&#123;alpha&#125;</span> / &quot;</span></span><br><span class="line">    <span class="keyword">if</span> batchSize==<span class="number">1</span>:</span><br><span class="line">        strDescType = <span class="string">&quot;Stochastic&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> batchSize==n:</span><br><span class="line">        strDescType = <span class="string">&quot;Gradient&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        strDescType = <span class="string">f&quot;Mini-batch (<span class="subst">&#123;batchSize&#125;</span>)&quot;</span></span><br><span class="line">    name += strDescType + <span class="string">&quot; descent / Stop: &quot;</span></span><br><span class="line">    <span class="keyword">if</span> stopType == lr.STOP_ITER:</span><br><span class="line">        strStop = <span class="string">f&quot;<span class="subst">&#123;thresh&#125;</span> iterations&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> stopType == lr.STOP_COST:</span><br><span class="line">        strStop = <span class="string">f&quot;costs change &lt; <span class="subst">&#123;thresh&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        strStop = <span class="string">f&quot;gradient norm &lt; <span class="subst">&#123;thresh&#125;</span>&quot;</span></span><br><span class="line">    name += strStop</span><br><span class="line"><span class="comment">#     print(name)</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>\nTheta: <span class="subst">&#123;theta&#125;</span> / Iter: <span class="subst">&#123;<span class="built_in">iter</span>&#125;</span> / Last cost: <span class="subst">&#123;costs[-<span class="number">1</span>]:<span class="number">03.2</span>f&#125;</span> / Duration: <span class="subst">&#123;dur:<span class="number">03.2</span>f&#125;</span>s&quot;</span>)</span><br><span class="line">    plt.subplots(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">    plt.plot(np.arange(<span class="built_in">len</span>(costs)), costs, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Iterations&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Cost&#x27;</span>)</span><br><span class="line">    plt.xlim(-<span class="number">1</span>,)</span><br><span class="line">    plt.title(name.upper())</span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><p>基于次数的迭代策略的 batch 梯度下降(5000 次)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">theta = runExpe(orig_data, theta, n, <span class="number">0</span>, thresh=<span class="number">2000</span>, alpha=<span class="number">0.000001</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200228014359535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p>基于损失值的迭代策略的 batch 梯度下降（109901 次）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runExpe(orig_data, theta, n, <span class="number">1</span>, thresh=<span class="number">0.000001</span>, alpha=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200228020422840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p>根据梯度变化停止的 batch 梯度下降（40045 次）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runExpe(orig_data, theta, n, <span class="number">2</span>, thresh=<span class="number">0.05</span>, alpha=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200228020527177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p>看一看准确率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scaled_X = orig_data[:, :<span class="number">3</span>]</span><br><span class="line">y = orig_data[:, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">predictions = lr.predict(scaled_X, theta)</span><br><span class="line">correct = [<span class="number">1</span> <span class="keyword">if</span> ((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">1</span>) <span class="keyword">or</span> (a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> (a, b) <span class="keyword">in</span> <span class="built_in">zip</span>(predictions, y)]</span><br><span class="line">accuracy = (<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, correct)) % <span class="built_in">len</span>(correct))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;accuracy = &#123;0&#125;%&#x27;</span>.<span class="built_in">format</span>(accuracy))</span><br></pre></td></tr></table></figure><pre><code>accuracy = 60%</code></pre><p>尝试下对数据进行标准化 将数据按其属性(按列进行)减去其均值，然后除以其方差。最后得到的结果是，对每个属性/每列来说所有数据都聚集在 0 附近，方差值为 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing <span class="keyword">as</span> pp</span><br><span class="line"></span><br><span class="line">scaled_data = orig_data.copy()</span><br><span class="line">scaled_data[:, <span class="number">1</span>:<span class="number">3</span>] = pp.scale(orig_data[:, <span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>再基于梯度变化停止的 batch 梯度下降（139711 次）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runExpe(scaled_data, theta, n, <span class="number">2</span>, thresh=<span class="number">0.002</span>*<span class="number">2</span>, alpha=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20200228025828418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="再基于梯度变化停止的batch梯度下降" /><figcaption aria-hidden="true">再基于梯度变化停止的batch梯度下降</figcaption></figure><p>基于梯度变化停止的随机梯度下降（72605 次）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theta = runExpe(scaled_data, theta, <span class="number">1</span>, <span class="number">2</span>, thresh=<span class="number">0.002</span>/<span class="number">5</span>, alpha=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200228025132558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p>在看一下准确度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaled_X = scaled_data[:, :<span class="number">3</span>]</span><br><span class="line">y = scaled_data[:, <span class="number">3</span>]</span><br><span class="line">predictions = predict(scaled_X, theta)</span><br><span class="line">correct = [<span class="number">1</span> <span class="keyword">if</span> ((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">1</span>) <span class="keyword">or</span> (a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>)) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> (a, b) <span class="keyword">in</span> <span class="built_in">zip</span>(predictions, y)]</span><br><span class="line">accuracy = (<span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, correct)) % <span class="built_in">len</span>(correct))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;accuracy = &#123;0&#125;%&#x27;</span>.<span class="built_in">format</span>(accuracy))</span><br></pre></td></tr></table></figure><pre><code>accuracy = 89%</code></pre><p>再基于梯度变化停止的 mini-batch 的梯度下降（3051 次）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theta = runExpe(scaled_data, theta, <span class="number">16</span>, <span class="number">2</span>, thresh=<span class="number">0.002</span>*<span class="number">2</span>, alpha=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200228025340752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p>]]></content>
      
      
      <categories>
          
          <category> Machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> logic regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归及python代码实现</title>
      <link href="2020/02/26/006-Line-regression-python/"/>
      <url>2020/02/26/006-Line-regression-python/</url>
      
        <content type="html"><![CDATA[<h1 id="回归分析">回归分析</h1><p>监督学习中，如果预测的变量是离散的，我们称其为分类（如决策树，支持向量机等），如果预测的变量是连续的，我们称其为回归。</p><ul><li><strong>离散</strong>：连续的对应（就是反义词）就是离散 。离散就是不连续。例如像整数<code>1,2,3,4,5,...</code>这种就是离散的</li></ul><p>在统计学中，<strong>回归分析</strong>（<strong>regression analysis</strong>)指的是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。</p><p>在大数据分析中，<strong>回归分析</strong>是一种预测性的建模技术，它研究的是<strong>因变量</strong>（目标）和<strong>自变量</strong>（预测器）之间的关系。这种技术通常用于预测分析，时间序列模型以及发现变量之间的因果关系。例如，司机的鲁莽驾驶与道路交通事故数量之间的关系，最好的研究方法就是回归。</p><ol type="1"><li>回归分析按照<strong>涉及的变量的多少</strong>，分为一元回归和多元回归分析；</li><li>按照<strong>因变量的多少</strong>，可分为简单回归分析和多重回归分析；</li><li>按照<strong>自变量和因变量之间的关系类型</strong>，可分为线性回归分析和非线性回归分析 <br></li></ol><h1 id="线性回归">线性回归</h1><p>线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为 <span class="math inline">\(y = w&#39;x+e\)</span>，其中 <span class="math inline">\(e\)</span> 为误差服从均值为 0 的正态分布。</p><ul><li>回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。</li><li>如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。</li></ul><h4 id="例子">例子</h4><p>假如现在我想去找银行贷款，那我能不能在贷款之前先预测一下我能贷到多少钱呢？下面有这样一张表：</p><table><thead><tr class="header"><th>工资</th><th>年龄</th><th>贷款额度</th></tr></thead><tbody><tr class="odd"><td>4000</td><td>25</td><td>20000</td></tr><tr class="even"><td>8000</td><td>30</td><td>70000</td></tr><tr class="odd"><td>5000</td><td>28</td><td>35000</td></tr><tr class="even"><td>7500</td><td>33</td><td>50000</td></tr><tr class="odd"><td>12000</td><td>40</td><td>85000</td></tr></tbody></table><p>通过这张表我们可以比较明显的看到工资、年龄与贷款额度之间是有一个关系的，大概是工资越高、年龄越小贷款的额度就相应的越高。那么我能不能根据自己的工资和年龄去预测一个具体的贷款值？</p><p>这里我们就可以引入回归分析了，我们可以把<strong>工资</strong>和<strong>年龄</strong>当作两个<strong>自变量</strong>，<strong>贷款额度</strong>当作<strong>因变量</strong>，通过求解自变量和因变量的线性关系，从而得到一个线性回归方程。利用得到的线性回归方程我们就可以进行预测了，那这种统计分析中利用线性回归方程对自变量和应变量建模的回归分析就叫做线性回归。 <br></p><h1 id="函数拟合">函数拟合</h1><p>继续上面的问题，现在我们把工资和年龄设为 <span class="math inline">\(x_1,x_2\)</span> (<strong>特征值</strong>)，贷款额度设为 <span class="math inline">\(h\)</span> (<strong>目标值</strong>)，去求一个线性函数，那么我们可以假设方程为：<span class="math inline">\(h=\alpha_0+\alpha_1x_1+\alpha_2x_2\)</span>，接着假设定义<span class="math inline">\(x_0\)</span>的值为 1，上面的式子可以表示成: <span class="math inline">\(h = \displaystyle\sum_{i=0}^n \alpha_i x_i=\alpha^ T X\)</span>。</p><p>实际情况中，变量之间不一定有线性关系，这时我们就要通过拟合的方式来解决。也就是找到一组最佳的参数 <span class="math inline">\(\alpha_0,\alpha_1,\alpha_2\)</span> 使得预测值最接近真实值。最后我们可能得到这样的结果：</p><figure><img src="https://img-blog.csdnimg.cn/20200225214559219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" alt="dk-1" /><figcaption aria-hidden="true">dk-1</figcaption></figure><p>线性回归模型经常用<strong>最小二乘</strong>逼近来拟合，当然也可能用别的方法来拟合。 <br></p><h1 id="高斯分布">高斯分布</h1><p>通过上面的图，可以看出真实值和预测值之间一般是存在误差(用 <span class="math inline">\(\epsilon\)</span> 来表示误差)，于是(真实值) <span class="math inline">\(y =\displaystyle\sum_{i=0}^n \alpha_i x_i=\alpha^ T X+\epsilon\)</span>，对于每个样本有: <span class="math inline">\(y^{(i)} = \alpha^Tx^{(i)}+\epsilon^{(i)}\)</span>，误差<span class="math inline">\(\epsilon^{(i)}\)</span>是独立并且具有相同的分布，并且服从均值为 0，方差为<span class="math inline">\(\sigma^2\)</span>的高斯分布。</p><p>通常我们认为误差往往是很微小的，根据“<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86?fr=aladdin">中心极限定理</a>” ：在自然界与生产中，一些现象受到许多相互独立的随机因素的影响，如果每个因素所产生的影响都很微小时，总的影响可以看作是服从正态分布的。中心极限定理就是从数学上证明了这一现象 。所以高斯分布对误差假设来说是一种很好的模型。。</p><p>正态分布（Normal distribution），也称“常态分布”，又名高斯分布（Gaussian distribution）;正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线。</p><p>若随机变量<span class="math inline">\(X\)</span>服从一个数学期望为<span class="math inline">\(\mu\)</span>、方差为<span class="math inline">\(\sigma^2\)</span>的正态分布，记为<span class="math inline">\(N(\mu,\sigma^2)\)</span>。其概率密度函数为正态分布的期望值<span class="math inline">\(\mu\)</span>决定了其位置，其标准差<span class="math inline">\(\sigma\)</span>决定了分布的幅度。当<span class="math inline">\(\mu=0,\sigma=1\)</span>时的正态分布是标准正态分布。</p><p>通过概率密度函数来定义高斯分布：</p><p><img src="https://img-blog.csdnimg.cn/20200226004806895.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70#pic_center" /></p><p>高斯分布的概率密度函数：<span class="math inline">\(p(y)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(y-\mu)^2}{2\sigma^2}}\)</span></p><p>由于误差服从高斯分布，将其带入正太分布函数中(<span class="math inline">\(\mu=0\)</span>)，可以得到：<span class="math inline">\(p(y^{(i)}|x^{(i)};\alpha)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(y^{(i)} - \alpha ^Tx^{(i)})^2}{2\sigma^2}}\)</span> <br></p><h1 id="似然函数">似然函数</h1><p>在数理统计学中，似然函数是一种关于统计模型中的参数的函数，表示模型参数中的似然性。<strong>似然性</strong>是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。给定输出 x 时，关于参数 <span class="math inline">\(\theta\)</span> 的似然函数 <span class="math inline">\(L(\theta|x)\)</span>（在数值上）等于给定参数 <span class="math inline">\(\theta\)</span> 后变量 X 的概率：</p><p><span class="math display">\[L(\theta|x)=p(X=x|\theta)\]</span></p><p>似然函数的主要用法在于比较它相对取值，虽然这个数值本身不具备任何含义。例如，考虑一组样本，当其输出固定时，这组样本的某个未知参数往往会倾向于等于某个特定值，而不是随便的其他数，此时，似然函数是最大化的。</p><p><strong>最大似然估计</strong>：对同一个似然函数，如果存在一个参数值，使得它的函数值达到最大的话，那么这个值就是最为“合理”的参数值。是似然函数最初也是最自然的应用。在 <span class="math inline">\(\theta\)</span> 的所有取值上，使这个函数最大化。这个使可能性最大的值即被称为 <span class="math inline">\(\theta\)</span> 的最大似然估计。</p><p>现在我们要求解的就是最佳参数，也就是满足最大似然估计的 <span class="math inline">\(\alpha\)</span> ，所以将 <span class="math inline">\(p(y^{(i)}|x^{(i)};\alpha)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(y^{(i)} - \alpha ^Tx^{(i)})^2}{2\sigma^2}}\)</span>带入：</p><p><span class="math display">\[L(\alpha)=\displaystyle\prod_{i=1}^mp(y^{(i)}|x^{(i)};\alpha)=\displaystyle\prod_{i=1}^m\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(y^{(i)} - \alpha ^Tx^{(i)})^2}{2\sigma^2}}\]</span></p><p><strong>对数似然</strong>：涉及到似然函数的许多应用中，更方便的是使用似然函数的自然对数形式，即“对数似然函数”。求解一个函数的极大化往往需要求解该函数的关于未知参数的偏导数。由于对数函数是单调递增的，而且对数似然函数在极大化求解时较为方便，所以对数似然函数常用在最大似然估计及相关领域中。</p><p><span class="math display">\[\log  L(\alpha)=\log \displaystyle\prod_{i=1}^mp(y^{(i)}|x^{(i)};\alpha)=\log \displaystyle\prod_{i=1}^m\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(y^{(i)} - \alpha^T x^{(i)})^2}{2\sigma^2}}\]</span></p><p><span class="math display">\[= \displaystyle\sum_{i=1}^m\log\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(y^i - \alpha^T x^i)^2}{2\sigma^2}}\]</span></p><p><span class="math display">\[\quad \quad =m\log \frac{1}{\sigma\sqrt{2\pi}}-\frac{1}{\sigma^2}\cdot\frac{1}{2}\displaystyle\sum_{i=1}^m(y^{(i)} - \alpha^T x^{(i)})^2\]</span></p><p>目标是要使的对数似然函数最大，<span class="math inline">\(m\log \frac{1}{\sigma\sqrt{2\pi}}\)</span>是一个常数，所以就得让后面减去的最小，得到目标函数：</p><p><span class="math display">\[J(\alpha)=\frac{1}{2}\displaystyle\sum_{i=1}^m(y^{(i)} - \alpha^T x^{(i)})^2=\frac{1}{2}\displaystyle\sum_{i=1}^m(Y(x^{(i)})-y^{(i)})^2=\frac{1}{2}(X\alpha-y)^T(X\alpha-y) \]</span></p><p>对 <span class="math inline">\(\alpha\)</span> 求偏导：</p><p><span class="math display">\[\nabla_\alpha J(\alpha)=\nabla_\alpha(\frac{1}{2}(X\alpha-y)^T(X\alpha-y))=\nabla_\alpha(\frac{1}{2}(\alpha^TX^T-y^T)(X\alpha-y))\]</span></p><p><span class="math display">\[=\nabla_\alpha\frac{1}{2}(\alpha^TX^TX\alpha-\alpha^TX^Ty-y^TX\alpha-y+y^Ty))\]</span></p><p><span class="math display">\[ =\frac{1}{2}(2X^TX\alpha-X^Ty-(y^TX)^T)=X^TX\alpha-X^Ty\]</span></p><p>令偏导等于 0：</p><p><span class="math display">\[\alpha=(X^TX)^{-1}X^Ty\quad\quad（最小二乘）\]</span> <br></p><h1 id="最小二乘法">最小二乘法</h1><p>假如我们在研究两个变量<span class="math inline">\(（x,y）\)</span>之间的相互关系时，通常可以得到一系列成对的数据<span class="math inline">\(（x1,y1.x2,y2... xm,ym）\)</span>；将这些数据描绘在 <code>x-y</code> 直角坐标系中，若发现这些点在一条直线附近,可以设这条直线方程为：<span class="math inline">\(y_i=a_0+a_1x(其中 a_0、a_1任意实数)\)</span>。</p><p>为了建立这条直线，那么我们就要确定<span class="math inline">\(a_0\)</span>和<span class="math inline">\(a_1\)</span>的值，我们将实际值 <span class="math inline">\(y_i\)</span>与计算值 <span class="math inline">\(y_j(y_j=a_0+a_1x )\quad[1]\)</span> 的差<span class="math inline">\((y_i-y_j)\)</span>的平方和 <span class="math inline">\(\varphi=\displaystyle\sum_{i=1}^{n} (y_i-y_j)^2\quad[2]\)</span> 最小作为<strong>优化判据</strong>。</p><p>我们把[1]式带入[2]式中，得到 <span class="math inline">\(\varphi=\displaystyle\sum_{i=1}^{n} (y_i-a_0-a_1x_i )^2 \quad[3]\)</span></p><p>为了使 <span class="math inline">\(\varphi\)</span> 的值最小，我们可以通过求解最小值的方法，让函数 <span class="math inline">\(\varphi\)</span> 对 <span class="math inline">\(a_0、a_1\)</span> 求偏导，令两个偏导数等于零。这样我们就的到了式[4]和式[5]。</p><p><span class="math display">\[\begin{cases}\displaystyle\sum_{i=1}^{n} 2(a_0+a_1x_i-y_i )=0 \quad[4]\\\displaystyle\sum_{i=1}^{n} 2x_i(a_0+a_1x_i-y_i )=0 \quad[5]\end{cases}\]</span></p><p>求解方程组，可以得到 <span class="math inline">\(a_0=\frac{1}{n}\displaystyle\sum_{i=1}^n(y_i-a_1x_i) , a_1=\frac{n\displaystyle\sum_{i=1}^nx_iy_i-\displaystyle\sum_{i=1}^nx_i\displaystyle\sum_{i=1}^ny_i}{n\displaystyle\sum_{i=1}^nx_i^2-\displaystyle\sum_{i=1}^nx_i\displaystyle\sum_{i=1}^nx_i}\)</span> ，将 <span class="math inline">\(a_0\)</span> 和 <span class="math inline">\(a_1\)</span> 带入[1]式中就的到了我们的一元线性方程，即：数学模型。</p><p>这里以最简单的一元线性模型来解释最小二乘法。回归分析中，如果只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。对于二维空间线性是一条直线；对于三维空间线性是一个平面，对于多维空间线性是一个超平面。 <br></p><h1 id="梯度下降">梯度下降</h1><p>梯度下降是迭代法的一种,沿着这个函数下降的方向找，逼近最小值,可以用于求解最小二乘问题。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。</p><p>在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。</p><p>其迭代公式为 <span class="math inline">\(a_{k+1}=a_k+\rho k^{\bar{s}^{(k)}}\)</span> ,其中 <span class="math inline">\(\bar{s}^{(k)}\)</span> 代表梯度负方向，<span class="math inline">\(\rho k\)</span> 表示梯度方向上的搜索步长。梯度方向我们可以通过对函数求导得到，步长的确定比较麻烦，太大了的话可能会发散，太小收敛速度又太慢。 <br></p><h1 id="评估">评估</h1><p>通常使用 RSE（残差标准差）和 R 来评估模型</p><p><span class="math inline">\(R^2=1-\frac{RSS}{TSS}=1-\frac{\displaystyle\sum_{i=1}^m(\hat{y_i}-y_i)^2}{\displaystyle\sum_{i=1}^m(y_i-\bar{y})^2}\quad\quad\quad\quad \frac{残差平方和}{类似方差项}\)</span></p><p><span class="math inline">\(R^2\)</span> 可以衡量因变量的变化比例，并用自变量 <span class="math inline">\(x\)</span> 表述。因此，假设在一个线性方程中，自变量 <span class="math inline">\(x\)</span> 可以解释因变量，那么变化比例就高， <span class="math inline">\(R^2\)</span> 将接近 1。反之，则接近 0。所以 <span class="math inline">\(R^2\)</span>的取值越接近 1 ，我们就认为模型拟合的与好 <br></p><h1 id="简单线性回归-python-案例">简单线性回归 python 案例</h1><p>导入用到的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>生成数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置随机生成算法的初始值</span></span><br><span class="line">np.random.seed(<span class="number">300</span>)</span><br><span class="line">data_size = <span class="number">100</span></span><br><span class="line"><span class="comment">#  生出size个符合均分布的浮点数，取值范围为[low, high)，默认取值范围为[0, 1.0)</span></span><br><span class="line">x = np.random.uniform(low=<span class="number">1.0</span>, high=<span class="number">10.0</span>, size=data_size)</span><br><span class="line">y = x * <span class="number">20</span> + <span class="number">10</span> + np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">10.0</span>, size=data_size)</span><br></pre></td></tr></table></figure><p>查看数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(y.shape)</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>[5.06010312 2.98920108 4.32173127 3.61698133 3.16970135 8.0384179 8.29984929 4.60711487 1.23399282 6.48435743 6.66179289 6.86728789 8.72731994 6.28122472 7.33751513 5.37311508 7.15974709 2.01131411 2.64152172 7.27343316 4.31517483 4.84567523 4.59836046 6.83840906 4.7201361  2.47241009 5.57532693 5.65184176 4.13384671 3.72027221 3.04603181 1.49130937 7.68238581 3.78143155 9.79455216 4.27478265 5.42937585 7.76009388 5.53962905 2.12052548 8.35322843 4.32938243 3.18827513 8.28250053 3.09192118 3.2946656  4.92652317 8.48630166 6.78218775 7.45073433 7.36576515 7.96927182 4.13018028 7.03576017 6.43589797 7.3106855  9.21539573 9.0112781  9.5537087  7.9801062 5.44528565 6.62427759 4.46709413 5.58802991 8.67279532 3.2084603 9.61530432 8.82526244 2.18656259 5.71768665 7.5517145  3.89302569 8.74359262 2.08295081 5.91832925 5.46471639 9.43168746 1.58599839 7.63747752 4.87551191 8.56518562 7.88432931 3.48748529 1.72525194 6.83057399 2.76268027 6.48435105 8.16047282 2.30107294 2.63178986 8.74522455 5.82819158 6.58947199 5.36626558 4.85639013 6.27787997 3.56740106 7.88396527 1.66851535 4.97195607](100,)</code></pre><p><img src="https://img-blog.csdnimg.cn/20200226164326462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p>区分训练集和测试集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个随机排列</span></span><br><span class="line">shuffled_index = np.random.(data_size)</span><br><span class="line">x = x[shuffled_index]</span><br><span class="line">y = y[shuffled_index]</span><br><span class="line">split_index = <span class="built_in">int</span>(data_size * <span class="number">0.75</span>)</span><br><span class="line">x_train = x[:split_index]</span><br><span class="line">y_train = y[:split_index]</span><br><span class="line">x_test = x[split_index:]</span><br><span class="line">y_test = y[split_index:]</span><br></pre></td></tr></table></figure><p>线性回归类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinerRegression</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, learning_rate=<span class="number">0.01</span>, max_iter=<span class="number">100</span>, seed=<span class="literal">None</span></span>):</span></span><br><span class="line">        np.random.seed(seed)</span><br><span class="line">        self.lr = learning_rate</span><br><span class="line">        self.max_iter = max_iter</span><br><span class="line">        self.a = np.random.normal(<span class="number">1</span>, <span class="number">0.1</span>)</span><br><span class="line">        self.b = np.random.normal(<span class="number">1</span>, <span class="number">0.1</span>)</span><br><span class="line">        self.loss_arr = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.max_iter):</span><br><span class="line">            self._train_step()</span><br><span class="line">            self.loss_arr.append(self.loss())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_f</span>(<span class="params">self, x, a, b</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;一元线性函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> x * a + b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, x=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;预测&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            x = self.x</span><br><span class="line">        y_pred = self._f(x, self.a, self.b)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, y_true=<span class="literal">None</span>, y_pred=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;损失&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> y_true <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> y_pred <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            y_true = self.y</span><br><span class="line">            y_pred = self.predict(self.x)</span><br><span class="line">        <span class="keyword">return</span> np.mean((y_true - y_pred)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_calc_gradient</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;梯度&quot;&quot;&quot;</span></span><br><span class="line">        d_a = np.mean((self.x * self.a + self.b - self.y) * self.x)</span><br><span class="line">        d_b = np.mean(self.x * self.a + self.b - self.y)</span><br><span class="line">        print(d_a, d_b)</span><br><span class="line">        <span class="keyword">return</span> d_a, d_b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_train_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;训练频度&quot;&quot;&quot;</span></span><br><span class="line">        d_a, d_b = self._calc_gradient()</span><br><span class="line">        self.a = self.a - self.lr * d_a</span><br><span class="line">        self.b = self.b - self.lr * d_b</span><br><span class="line">        <span class="keyword">return</span> self.a, self.b</span><br></pre></td></tr></table></figure><p>训练数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regr = LinerRegression(learning_rate=<span class="number">0.01</span>, max_iter=<span class="number">10</span>, seed=<span class="number">314</span>)</span><br><span class="line">regr.fit(x_train, y_train)</span><br></pre></td></tr></table></figure><p>展示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f&#x27;cost: \t<span class="subst">&#123;regr.loss():<span class="number">.3</span>&#125;</span>&#x27;</span>)</span><br><span class="line">print(<span class="string">f&quot;f=<span class="subst">&#123;regr.a:<span class="number">.2</span>&#125;</span> x + <span class="subst">&#123;regr.b:<span class="number">.2</span>&#125;</span>&quot;</span>)</span><br><span class="line">plt.scatter(np.arange(<span class="built_in">len</span>(regr.loss_arr)), regr.loss_arr, marker=<span class="string">&#x27;o&#x27;</span>, c=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>cost:   1.11e+02f=2.1e+01 x+4.2</code></pre><p><img src="https://img-blog.csdnimg.cn/20200226180220573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" /></p><p><img src="https://img-blog.csdnimg.cn/20200226181102306.gif" /></p><p>评估</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regr.predict(x_test)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt_R</span>(<span class="params">y_pred, y_test</span>):</span></span><br><span class="line">    y_c = y_pred - y_test</span><br><span class="line">    rss = np.mean(y_c ** <span class="number">2</span>)</span><br><span class="line">    y_t = y_test - np.mean(y_test)</span><br><span class="line">    tss = np.mean(y_t ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - rss / tss)</span><br><span class="line">r = sqrt_R(y_pred, y_test)</span><br><span class="line">print(<span class="string">f&quot;R: <span class="subst">&#123;r&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>R: 0.9327511073300032</code></pre><p><br></p><h1 id="sklearn-案例">sklearn 案例</h1><p>导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, SGDRegressor, Ridge</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br></pre></td></tr></table></figure><p>载入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;线性回归预测房子价格&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">lb = load_boston()</span><br><span class="line">print(lb)</span><br></pre></td></tr></table></figure><p>处理数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分割数据集 （训练集、测试集）</span></span><br><span class="line">x_train, x_text, y_train, y_test = train_test_split(lb.data, lb.target, test_size=<span class="number">0.25</span>)</span><br><span class="line"><span class="comment"># 进行标准化</span></span><br><span class="line"><span class="comment"># 特征值 目标值 都标准化</span></span><br><span class="line">std_x = StandardScaler()</span><br><span class="line">x_train = std_x.fit_transform(x_train)</span><br><span class="line">x_text = std_x.fit_transform(x_text)</span><br><span class="line"></span><br><span class="line">std_y = StandardScaler()</span><br><span class="line">y_train = std_y.fit_transform(y_train.reshape(-<span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># 传入数据必须二维</span></span><br><span class="line">y_test = std_y.fit_transform(y_test.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>方程求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># estimator预测</span></span><br><span class="line"><span class="comment"># 正规方程求解方式</span></span><br><span class="line">lr = LinearRegression()</span><br><span class="line">lr.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(lr.coef_)</span></span><br><span class="line"></span><br><span class="line">y_lr_predict = std_y.inverse_transform(lr.predict(x_text))</span><br><span class="line"><span class="comment"># print(&quot;预测：\n&quot;, y_lr_predict)</span></span><br><span class="line">print(<span class="string">&quot;均方误差：&quot;</span>, mean_squared_error(std_y.inverse_transform(y_test), y_lr_predict))</span><br><span class="line">print(<span class="string">f&quot;R : <span class="subst">&#123;lr.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>[[-0.10633041  0.10911523  0.00409775  0.06205962 -0.23187842  0.29700813  -0.00083156 -0.32863065  0.2570794  -0.18807137 -0.22742163  0.10321854  -0.39041034]均方误差： 21.92038221080247R : 0.6956028823910707</code></pre><p>梯度下降</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 梯度下降方式</span></span><br><span class="line">sgd = SGDRegressor()</span><br><span class="line">sgd.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">y_sgd_predict = std_y.inverse_transform(sgd.predict(x_text))</span><br><span class="line">print(y_sgd_predict)</span><br><span class="line">print(<span class="string">&quot;均方误差：&quot;</span>, mean_squared_error(std_y.inverse_transform(y_test), y_sgd_predict))</span><br><span class="line">print(<span class="string">f&quot;R : <span class="subst">&#123;sgd.score(x_test, y_test)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>均方误差： 17285.95206027733R : 0.6907551016044395</code></pre>]]></content>
      
      
      <categories>
          
          <category> Machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> line regression </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制台文件管理器-Ranger</title>
      <link href="2020/02/23/031-Range_useage-and-introduce/"/>
      <url>2020/02/23/031-Range_useage-and-introduce/</url>
      
        <content type="html"><![CDATA[<p>今天给大家介绍一款特别的软件。在终端上，我们可以通过 <code>ls</code> 来查看文件，同过 <code>ls</code> 命令我们只能看到当前目录下的文件。那么有没有办法可以在终端中清晰的看到目录的层级关系，方便的查看文件呢？ 如果你有这样的想法或需求，那么 <code>Ranger</code> 绝对是你想要的。<code>Ranger</code> 是具有 VI 键绑定的控制台文件管理器。它提供了一个简约而美观的 <code>curses</code> 界面，并具有目录层次结构的视图。它附带了<code>rifle</code>（一个文件启动器），该文件启动器擅长自动找出用于哪种文件类型的程序。看看效果 <img src="https://img-blog.csdnimg.cn/20200225174158198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="01" /></p><h2 id="安装">安装</h2><p>如何安装 <code>Ranger</code> 呢？首先 <code>Ranger</code>是依赖 Python 的，所以你的电脑里需要有 Python（<code>&gt;=2.6或&gt;=3.1</code>） 我们可以通 PyPI 的方式安装<code>Ranger</code>： <code>sudo pip install ranger</code> 安装完成后打开终端输入 <code>ranger</code> 回车，我们就可以开启 <code>Ranger</code> 之旅了 <img src="https://img-blog.csdnimg.cn/20200225174231650.gif" width="100%"></p><h2 id="入门">入门</h2><p>启动 <code>Ranger</code> 后，你会看到三个面板</p><ul><li>中间一个包含当前目录的内容，</li><li>左侧显示父目录，突出显示当前目录，</li><li>右边的提供各种预览。</li></ul><p>您可以使用箭头键或 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 进行导航，<code>Enter</code> 打开文件或 <code>q</code> 退出。 <img src="https://img-blog.csdnimg.cn/20200225174413155.gif" alt="在这里插入图片描述" /> 当前文件的属性可以在底部看到，而当前目录路径可以在顶部看到。 <img src="https://img-blog.csdnimg.cn/20200225174348856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNDk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="进阶">进阶</h2><p>如果你熟悉 <code>vim</code>，那么使用 <code>ranger</code> 将十分容易。<code>ranger</code> 借鉴了许多 <code>vim</code> 语法。例如：<code>yy</code>复制文件（在 <code>vim</code> 中复制一行），<code>pp</code> 粘贴，<code>dd</code> 剪切文件。还可以使用 <code>:</code>（冒号）调用的命令行中调用更复杂的函数。</p><p>要打开文件并让 <code>Ranger</code> 选择要使用的程序（通过<code>rifle</code>）打开 ，只需按 <code>Enter</code>。要选择自己，请按 <code>r</code>，然后从列表中选择或键入要使用的程序。你也可以使用命令 <code>:open_with</code>。 <img src="https://img-blog.csdnimg.cn/20200225174441939.gif" width="100%"></p><p>如果你一次要在一个以上的目录中工作，则可以为每个要快速访问的目录创建选项卡。选项卡已编号。要切换到第 N 个标签，请按 <code>Alt-N</code>，其中 N 是标签编号。如果这样的标签还不存在，它将被创建。要关闭选项卡，请按<code>q</code>（如果关闭最后一个选项卡，则整个 ranger 过程将关闭）。</p><p><img src="https://img-blog.csdnimg.cn/20200225174616637.gif" width="100%"></p><p><strong>Ranger</strong>: <a href="https://ranger.github.io/index.html">https://ranger.github.io/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Celery 介绍与入门</title>
      <link href="2020/01/23/005-What-is-celery/"/>
      <url>2020/01/23/005-What-is-celery/</url>
      
        <content type="html"><![CDATA[<p>Do you know what <code>celery</code> is? Let's take a look and learn how to use it.</p><a id="more"></a><h1 id="celery-简介和原理">Celery 简介和原理</h1><p><strong>Celery(芹菜)是一个异步任务队列/基于分布式消息传递的作业队列。它侧重于实时操作</strong>，但对调度支持也很好。Celery 用于生产系统每天处理数以百万计的任务。Celery 是用 Python 编写的，但该协议可以在任何语言实现。</p><p>简单来说就是你可以交给 celery 一些工作，它可以帮你同时的完成，而你并不需要等着。说白了就是一打工仔，但是 celery 一个顶很多个。</p><p><strong>Celery 是怎么顶多个打工仔的呢？</strong> 其实是因为<code>celery workers</code> ，它是 Celery 的一个工作队列，里面有多少<code>worker(任务执行单元)</code>就可以同时干多少件任务。</p><p>这时我们又必须说到 Celery 中的另一个概念了：<code>broker</code>。 <code>broker</code>是一个消息中间件，可以理解成一个邮箱。如果没有<code>broker</code>，当你丢给 Celery 任务时，如果恰好所有的<code>worker</code>都在工作，那么你就必须等待有一个<code>worker</code>完成任务才可以。<code>broker</code>的引入正好解决可这个问题，你只需要把任务告诉 broker，它就会帮你传递给 worker。</p><p>但这样又出现了新的问题，你无法得知<code>broker</code>什么时候传递任务，也无法得知<code>worker</code>什么时候完成任务。为此，Celery 实现了一个<code>backend</code>用于任务完成的结果。</p><h3 id="原理图">原理图</h3><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWXJldkhBcHBBSG1pYjZkWFFuTXRqQnlFTmJCNE01Y2liRzZXaHUyRGlhZUJUeEJaZTRmWkRyckJ0SGhZY2FDNFh4aWJUeFA1OTV0aWFkRUlRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>Celery 本身不提供消息服务，但是可以方便的使用第三发提供，如：<code>RabbitMQ</code> <code>Redis</code> <code>Amazon SQS</code></p><p>Worker 是 Celery 提供的任务执行的单元，worker 并发的运行在分布式的系统节点中</p><p>Celery 支持以不同的方式存储任务的结果，如：<code>AMQP, redis，memcached, mongodb，SQLAlchemy, Django ORM，Apache Cassandra, IronCache ....</code></p><h1 id="celery-的安装">Celery 的安装</h1><h3 id="安装">安装</h3><p>您可以通过 python 的 pip 安装或通过源代码进行安装 Celery，使用 pip 进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U Celery</span><br><span class="line"></span><br><span class="line"> -U 不存在下载celery，存在更新celery</span><br></pre></td></tr></table></figure><h3 id="捆绑">捆绑</h3><p>Celery 自定义了一组用于安装 Celery 和特定功能的依赖。</p><p>您可以在中括号加入您需要依赖，并可以通过逗号分割需要安装的多个依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install <span class="string">&quot;celery[librabbitmq]&quot;</span></span><br><span class="line">$ pip install <span class="string">&quot;celery[librabbitmq,redis,auth,msgpack]&quot;</span></span><br></pre></td></tr></table></figure><h1 id="celery-的简单使用">Celery 的简单使用</h1><p>Celery 上手比较简单，不需要配置文件就可以直接运行，大多数情况下，使用默认的配置就可以满足。</p><p><strong>这是一个简单的 Demo</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># broker指定中间人，我选择的是redis</span></span><br><span class="line"><span class="comment"># backend指定存储任务结果的数据库，我没有使用</span></span><br><span class="line">app = Celery(<span class="string">&#x27;hello&#x27;</span>, broker=<span class="string">&#x27;redis://127.0.0.1:3679/1&#x27;</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>然后在 shell 中启动 celery</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">celery -A hello worker --loglevel=info</span><br><span class="line"><span class="comment"># -A 是Application的首字母</span></span><br><span class="line"><span class="comment"># hello是应用的所在</span></span><br><span class="line"><span class="comment"># --loglevel=info 指定log等级</span></span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> hello</span><br><span class="line">hello.delay()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常用命令总结</title>
      <link href="2020/01/12/004-Redis-note/"/>
      <url>2020/01/12/004-Redis-note/</url>
      
        <content type="html"><![CDATA[<p>Here are some common commands for redis, similar to a simple manual.</p><a id="more"></a><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用 C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。</p><h2 id="linux">linux</h2><p>安装 <code>sudo apt-get install redis</code></p><p>启动 <code>redis-server /etc/redis.conf</code> or <code>systemctl start redis.service</code></p><p>连接 <code>redis-cli</code> or <code>reids-cli -h host -p port -a password</code></p><p>关闭 <code>kill -9 PID</code> or <code>redis-cli shutdown</code></p><p>配置文件 <code>/etc/redis.conf</code></p><blockquote><p><code>daemonize</code> 是否为后台运行，<code>requirepas</code> 设置密码, <code>logfile</code> 设置 log 日志位置</p></blockquote><hr /><h2 id="windows">windows</h2><p>redis 目录下<code>redis.windows.conf</code></p><p>387 行添加<code>requirepass admin123</code></p><p>455 行添加<code>maxheap 1024000000</code></p><p>启动命令:<code>redis-server.exe redis.windows.conf</code></p><p>连接命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe<span class="comment"># 连接</span></span><br><span class="line">auth &amp;apos;admin123&amp;apos;<span class="comment"># 输入密码</span></span><br></pre></td></tr></table></figure><h2 id="key-通用操作">key 通用操作</h2><p><code>DEL key</code> : key 存在时删除 key（删除任何类型）</p><p><code>DUMP key</code> : 序列化 key，返回序列化的值</p><p><code>EXISTS key</code> : 判断 key 是否存在 ，返回值（1：存在，0：不存在）</p><p><code>EXPIRE key seconds</code> : 设置 key 过期时间（单位：s）</p><p><code>PEXPIRE key milliseconds</code> : 设置 key 过期时间（单位：ms）</p><p><code>TTL key</code> : 返回 key 剩余存活时间（单位：s ）</p><p><code>PTTL key</code> : 返回 key 剩余存活时间（单位：ms ）</p><p><code>PERSIST key</code> : 移除 key 过期时间，持久保持</p><p><code>KEYS pattern</code> : 查找符合 pattern 的 key，通配符（<code>*</code>：所有，<code>？</code>：任一字符）</p><p><code>RANDOM key</code> : 当前数据库，随机返回一个 key</p><p><code>RENAME key newname</code> : 修改 key 名</p><p><code>MOVE key db</code> : 移动 key 到指定数据库</p><p><code>TYPE key</code> : 返回 key 所存储值的类型</p><blockquote><p>推荐：key 的命名要有规范 ，如：<code>users:1:name</code></p></blockquote><hr /><h2 id="string">String</h2><p>String 是 redis 最基本的类型，一个 key 对应一个 value，最大存储 512M，String 是<code>二进制安全</code>的，可以存储任何数据类型。</p><blockquote><p>二进制安全是指，在传输数据时，保证二进制信息的安全，不被篡改、破译等，如果被攻击，也能及时检测到。</p></blockquote><p><strong>设置</strong></p><p><code>SET key value</code> : 设置键值对，key 存在时覆盖</p><p><code>SETNX key value</code> : 设置键值对，仅当 key 不存在时</p><p><code>SETEX key seconds value</code> : 设置键、过期时间、值</p><p><code>MSET key value [key value ...]</code> : 同时设置多个键值对</p><p><strong>获取</strong></p><p><code>GET key</code> : 获取 key 的值</p><p><code>MGET key [key ...]</code> : 获取多个 key 的值</p><p><code>GETRANGE key start end</code> : 获取 key 值字符串的字串（截取范围有 star t 到 end，<strong>start 和 end 都包含在内</strong>）</p><p><code>GETSET key value</code> : 设置 key 的值，并返回 key 的旧值，key 不存在返回 null</p><p><code>STRLEN key</code> : 返回 key 值的长度</p><p><strong>运算</strong></p><p>value 是数字类型，value 加一减一操作：<code>INCR key</code> and <code>DECR key</code></p><p>value 加减整数操作：<code>INCRBY key increment</code> and <code>DECRBY key increment</code></p><p><code>APPEND key value</code> : 在 key 值末尾追加，key 不存在时赋值</p><hr /><h2 id="hash-存储对象">Hash 存储对象</h2><p>hash 是一个 string 类型的 field 和 value 的映射表，特被适合用于<code>存储对象</code>，每个 hash 可以存储 <span class="math inline">\(2^{32}\)</span>-1 键值对。</p><blockquote><p>hash 是最接近关系型数据库结构的数据类型，可以将一条数据记录或一个对象转换成一个 hashmap 存储在 redis 中。</p></blockquote><p><strong>设置</strong></p><p><code>HSET key field value</code> : 设置单值（field 和 value 为键值对）</p><p><code>HMSET key field value [field value ...]</code> : 同时设置多个值</p><p><code>HSETNX key field value</code> : 当 field 不存在才设置值</p><p><strong>获取</strong></p><p><code>HGET key field</code> : 获取指定属性的值</p><p><code>HMGET key field [field ...]</code> : 同时获取多个属性的值</p><p><code>HGETALL key</code> : 获取所有属性和值</p><p><code>HKEYS key</code> : 获取所有属性</p><p><code>HVALS key</code> : 获取所有值</p><p><code>HLEN key</code> : 获取包含属性个数</p><p><code>HSTRLEN key fidld</code> : 获取指定属性的长度</p><p><strong>其他</strong></p><p><code>HDEL key field [field ...]</code> : 删除属性</p><p><code>HEXISTS key field</code> : 判断属性是否存在</p><p><code>HINCRBY key field increment</code> : value 加整数</p><p><code>HINCRBYFLOAT key field increment</code> : value 加浮点数</p><hr /><h2 id="list">list</h2><p>list 的元素类型为 String，按照插入顺序排列，在头或尾添加元素。</p><p><strong>设置</strong></p><p><code>LPUSH key value [value ...]</code> 在头部插入</p><p><code>RPUSH key value [value ...]</code> 在尾部插入</p><p><code>LINSERT key BEFORE|AFTER pivot value</code> 在指定元素 前/后 插入</p><p><code>LSET key index value</code> 设置指定索引的元素值</p><p><strong>获取</strong></p><p><code>LRANGE key start stop</code> 返回指定范围中的元素</p><p><code>LLEN key</code> 获取包含属性个数</p><p><code>LINDEX key index</code> 返回索引对应值</p><p><code>LPOP key</code> 返回并删除 key 对应 list 的首元素</p><p><code>RPOP key</code> 返回并删除 key 对应 list 的尾元素</p><p><code>LTRIM key start stop</code> 裁剪</p><p><code>BLPOP key [key ...] timeout</code> 返回并删除首元素，不存在则等待到超时时间</p><p><code>BRPOP key [key ...] timeout</code> 返回并删除尾元素，不存在则等待到超时时间</p><blockquote><p>0 代表第一个元素，-1 代表最后一个元素</p></blockquote><p><strong>高级</strong></p><p><code>RPOPLPUSH source destination</code> 移除 source 尾元素，添加到 destination 头部，并返回该值</p><blockquote><p>RPOPLPUSH l1 l1 循环队列</p></blockquote><hr /><h2 id="set">set</h2><p>set 为无序集合，元素类型为 String，元素有唯一性</p><blockquote><p>底层使用了 intset 和 hashtable 来那个中数据结构存储，<code>insert</code> 理解为数组，<code>hashtable</code>就是普通哈希表， <code>insert</code>内部是有序的，查找时通过二分查找</p></blockquote><p><strong>设置</strong></p><p><code>SADD key member [member ...]</code> 添加元素</p><p><strong>获取</strong></p><p><code>SMEMBERS key</code> 获取所有元素</p><p><code>SCARD key</code> 获取元素个数</p><p><code>SISMEMBER key member</code> 判断元素是否是集合成员</p><p><code>SRANDMEMBER key [count]</code> 随机返回 count 个数成员</p><p><strong>删除</strong></p><p><code>SREM key member [member ...]</code> 删除成员</p><p><code>SPOP key [count]</code> 移除并返回 count 个成员</p><p><strong>其他</strong></p><p><code>SMOVE source destination member</code> 将指定 member 从 source 移动到 destination 集合</p><p><code>SINTER key [key ...]</code> 返回多个集合交集</p><p><code>SINTERSTORE destination key [key ...]</code> 返回多个集合交集，并存储到 destination</p><p><code>SDIFF key [key ...]</code> 返回多个集合差集</p><p><code>SDIFFSTORE destination key [key ...]</code> 返回多个集合差集，并存储到 destination</p><p><code>SUNION key [key ...]</code> 返回多个集合并集</p><p><code>SUNIONSTROE destination key [key ...]</code> 返回多个集合并集，并存储到 destination</p><h2 id="zset">zset</h2><p>zset 为有序集合，元素类型为 String，元素有唯一性；每个元素有 double 类型的权重(<code>score</code>)，通过权重排序，权重可相同</p><p><strong>设置</strong></p><p><code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code> 添加元素</p><ul><li>XX: 仅仅更新存在的成员，不添加新成员。</li><li>NX: 不更新存在的成员。只添加新成员。</li><li>CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不被计算在内。</li><li>INCR: 当 ZADD 指定这个选项时，成员的操作就等同 ZINCRBY 命令，对成员的分数进行递增操作。 &gt; 注：在通常情况下，ZADD 返回值只计算新添加成员的数量。</li></ul><p><strong>获取</strong></p><p><code>ZCARD key</code> 获取元素个数</p><p><code>ZSCORE key menber</code> 返回指定 menber 的 score</p><p><code>ZRANGE key start stop</code> 返回指定 index 范围元素（分数低到高）</p><p><code>ZREVRANGE key start stop</code> 返回指定 index 范围元素（分数高到低）</p><p><code>ZCOUNT key min max</code> 返回指定 score 范围元素个数</p><p><code>ZRANK key member</code> 返回指定成员的索引</p><p><strong>删除</strong></p><p><code>ZREM key member [member ...]</code> 移除指定成员</p><p><code>ZREMRANGEBYSCORE key min max</code> 移除制定分数间的成员</p><p><code>ZREMRANGEBYRANK key start stop</code> 移除指定索引间的成员</p><hr /><p><a href="http://redis.cn/commands.html#generic">redis 命令网站</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 仅限位置参数介绍</title>
      <link href="2019/12/01/003-Python-Positional-only-parameters/"/>
      <url>2019/12/01/003-Python-Positional-only-parameters/</url>
      
        <content type="html"><![CDATA[<p>The new feature of Python3.8 is <code>Positional-only parameters</code>, you know? Let's find out.</p><a id="more"></a><p>在 python3.8 之前，python 中有<strong>位置参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>和<strong>关键字参数</strong>。在此，我们先回顾一下，下面先给出两个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_name</span>(<span class="params">name</span>):</span></span><br><span class="line">  print(<span class="string">&quot;I am %s&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>在调用这两个方法时，按照参数的位置将参数给进去，这种方式就是位置参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line"><span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>接下来，看看默认参数，比如下面有一个 <code>power</code>方法可以计算 <code>x</code> 的 <code>n</code>次方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">x, n</span>):</span></span><br><span class="line">  <span class="keyword">return</span> x ** n</span><br></pre></td></tr></table></figure><p>那我们可不可以让它在默认的情况下就计算平方呢？我们可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">x, n=<span class="number">2</span></span>):</span></span><br><span class="line">  <span class="keyword">return</span> x ** n</span><br></pre></td></tr></table></figure><p>这样在不传入 <code>n</code>的情况下，<code>n</code>就使用默认给的值，如果在调用时给了 <code>n</code> 的值，那么<code>n</code>的值就会被覆盖，这种就属于默认参数</p><p>再接着就一起看看，可变参数和关键字参数，有这样一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, gender, age=<span class="number">18</span>, city=<span class="string">&quot;Beijing&quot;</span>, *args, **kwargs</span>):</span></span><br><span class="line">  print(<span class="string">&quot;My name is %s. I&#x27;am a %s.&quot;</span> % (name, gender))</span><br><span class="line">  print(<span class="string">&quot;I&#x27;m %d years old. I come from %s&quot;</span> % (age, city))</span><br><span class="line">  print(args)</span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs:</span><br><span class="line">    print(key, value)</span><br></pre></td></tr></table></figure><p>用<code>*</code>修饰参数就是一个可变参数，函数内部接受到的是一个 <code>tuple</code>，所以我们可以先组装一个 <code>list</code> 或<code>tuple</code> 再传入; 用 <code>**</code> 修饰的就是一个关键字参数，函数内部接受到的是一个 <code>dict</code>，同样我们可以先组装一个 <code>dict</code> 再传入。</p><p>让我们看看使用的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: person(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;boy&quot;</span>, <span class="number">20</span>, <span class="string">&quot;wuhan&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hi&quot;</span>,hoby=<span class="string">&quot;football&quot;</span>)</span><br><span class="line">My name <span class="keyword">is</span> tom. I<span class="string">&#x27;am a boy.</span></span><br><span class="line"><span class="string">I&#x27;</span>m <span class="number">20</span> years old. I come <span class="keyword">from</span> wuhan</span><br><span class="line">(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;hoby&#x27;</span>: <span class="string">&#x27;football&#x27;</span>&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">In [<span class="number">6</span>]: args = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;I&#x27;m so happy&quot;</span>]</span><br><span class="line">In [<span class="number">7</span>]: kwargs = &#123;<span class="string">&#x27;fathre&#x27;</span>:<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;mother&#x27;</span>:<span class="string">&#x27;lily&#x27;</span>&#125;</span><br><span class="line">In [<span class="number">8</span>]: person(<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;boy&quot;</span>, <span class="number">20</span>, *args, **kwargs)</span><br><span class="line">My name <span class="keyword">is</span> tom. I<span class="string">&#x27;am a boy.</span></span><br><span class="line"><span class="string">I&#x27;</span>m <span class="number">20</span> years old. I come <span class="keyword">from</span> hello world</span><br><span class="line">(<span class="string">&quot;I&#x27;m so happy&quot;</span>,)</span><br><span class="line">&#123;<span class="string">&#x27;fathre&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;mother&#x27;</span>: <span class="string">&#x27;lily&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>然后，在 python3.8 中加入了<strong>仅限位置形参</strong>，新增了一个函数形参语法 <code>/</code> 用来指明某些函数形参必须使用仅限位置而非关键字参数的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">a, b, c, d, e, f</span>):</span></span><br><span class="line">    print(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure><p>在上面 <code>f1()</code> 中，如下几种方式都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br><span class="line">f1(<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br><span class="line">f1(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, f=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>让我们来看看 <code>f2()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span></span><br><span class="line">    print(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure><p>在 <code>f2()</code> 中只有第一种是正确的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)   <span class="comment"># b cannot be a keyword argument</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, f=<span class="number">60</span>)           <span class="comment"># e must be a keyword argument</span></span><br></pre></td></tr></table></figure><p>因为在函数中 <code>/</code>和 <code>*</code> 限制参数的类型，在 <code>/</code> 左边必须是位置参数，在 <code>*</code>右边必须是关键字参数，而在 <code>/</code> 和 <code>*</code>直接的则两者都可以。</p><p>这样可以在不需要参数名称时排除掉关键字参数，避免了这种笨拙的调用形式。而且由于在 / 左侧的形参不会被公开为可用关键字，其他形参名仍可在 **kwargs 中使用，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, b, /, **kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    print(a, b, kwargs)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">10</span>, <span class="number">20</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)         <span class="comment"># a and b are used in two ways</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>参考资料 [1]Python Developer's Guide: https://www.python.org/dev/peps/pep-0570/</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 matplotlib 绘制图标</title>
      <link href="2019/11/02/002-Matplotlib-use/"/>
      <url>2019/11/02/002-Matplotlib-use/</url>
      
        <content type="html"><![CDATA[<p>怎么用 Python 绘制图标呢? 最常用的一定是 matplotlib 库吧. 那么来看看怎么使用吧.</p><a id="more"></a><p>首先绘制一张简单的图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>绘图的结果：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2NUQxb0tHc0l5NHllNGR2MzAxZmlhbERJQk16eWJON3RENHR4Z28xR3Fwck9YS0VDd1hySjdjUS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>很容易，你只需要导入包、输入数据，然后你就可以得到你想要的图表了。</p><p>但是看起来似乎十分的单调，让我们来看看下面这段代码。</p><h3 id="折线图">折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">plt.plot(a, a*<span class="number">1.5</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, label=<span class="string">&quot;Firstline&quot;</span>, color=<span class="string">&quot;gold&quot;</span>)</span><br><span class="line">plt.plot(a, a*<span class="number">2.5</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, label=<span class="string">&quot;Secondline&quot;</span>)</span><br><span class="line">plt.plot(a, a*<span class="number">3.5</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Thirdline&quot;</span>)</span><br><span class="line">plt.plot(a, a*<span class="number">4.5</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, label=<span class="string">&quot;Fourthline&quot;</span>)</span><br><span class="line"><span class="comment"># linestyle supported values are &#x27;-&#x27;, &#x27;--&#x27;, &#x27;-.&#x27;, &#x27;:&#x27;, &#x27;None&#x27;, &#x27; &#x27;, &#x27;&#x27;, &#x27;solid&#x27;, &#x27;dashed&#x27;, &#x27;dashdot&#x27;, &#x27;dotted&#x27;</span></span><br><span class="line">plt.title(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y label&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2NVpza3JKM1VzTDY0RkswMWliVmxRMDIyVUtDQXpsU3poellhNTBSRHRSQ1ZIeTMxdU9ySmZpYXcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>现在图表是不是看起来好多了。在代码中我们可以通过 title 来指定图表的标题，通过<code>xlablel</code>和<code>ylabel</code>来指定<code>x</code>轴和<code>y</code>轴的标题。在绘制折线图的<code>plot()</code>方法中可以通过<code>color</code>参数来指定颜色，<code>linestyle</code>参数来指定线的样式。通过<code>legend()</code> 方法可以让图表显示图例，图例的文字可以通过 plot 中的<code>label</code>参数来指定。</p><p>花完了折线图，接下来让我们条形图和直方图</p><p>有了 plt.plot()的基础之后，对后面的理解就很容易了。</p><p>直接上例子：</p><h3 id="条形图">条形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">plt.bar([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)], label=<span class="string">&quot;Example one&quot;</span>)</span><br><span class="line">plt.bar([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>],[random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)], label=<span class="string">&quot;Example two&quot;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;bar number&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;bar height&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Bar Title&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2WmRxVUJhVkNsV1FITkltSmtDWVdMVkJDNzQ1akFncWJtcDBuZEgyOERpYm9NeHoycDBQbW8wQS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>利用<code>bar()</code>方法就可绘制条形图了</p><p>接下来我们尝试添加一些属性信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">r1 = plt.bar([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [random.randint(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)], label=<span class="string">&quot;Example one&quot;</span>, align=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">r2 = plt.bar([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>], [random.randint(<span class="number">1</span>, <span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)], label=<span class="string">&quot;Example two&quot;</span>, color=<span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">             align=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;bar number&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;bar height&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Bar Title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴</span></span><br><span class="line">_xtick_lables = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>]</span><br><span class="line">plt.xticks([i / <span class="number">1.5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">18</span>, <span class="number">3</span>)], _xtick_lables, rotation=<span class="number">45</span>)</span><br><span class="line">plt.grid(alpha=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加值标</span></span><br><span class="line"><span class="keyword">for</span> rec <span class="keyword">in</span> r1:</span><br><span class="line">    x = rec.get_x()</span><br><span class="line">    height = rec.get_height()</span><br><span class="line">    plt.text(x + <span class="number">0.3</span>, <span class="number">1.02</span> * height, <span class="built_in">str</span>(height))</span><br><span class="line"><span class="keyword">for</span> rec <span class="keyword">in</span> r2:</span><br><span class="line">    x = rec.get_x()</span><br><span class="line">    height = rec.get_height()</span><br><span class="line">    plt.text(x + <span class="number">0.3</span>, <span class="number">1.02</span> * height, <span class="built_in">str</span>(height))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2WlBhaEVnVFhoSUNndlQ1M2JpYXZYWExHT3ZxNDZZeVJPaWFQZE96QXhYOWNvODNtbW1sVGpzVUEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>看完了条形图，接下来看看直方图：</p><h3 id="直方图">直方图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">population_ages = [random.randint(<span class="number">0</span>, <span class="number">130</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)]</span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">110</span>, <span class="number">120</span>, <span class="number">130</span>]</span><br><span class="line">plt.hist(population_ages, bins, histtype=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>, fontsize=<span class="string">&#x27;large&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>, rotation=<span class="number">0</span>, fontsize=<span class="string">&#x27;large&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2VzBQblZVWk9maWJIZUdEdVRkaWE1Nzc3dWdtbThzREVMT24xN256NzhyNFRNc3M4WlJ5VmhPMmcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>直方图用的是<code>hist()</code>方法，是不是看起和条形图来很像，其实两者区别非常大</p><ul><li>条形图的长度是当前类别的频数，而它的宽是没有意义的，各个矩阵之间通常是分开排列的，主要是用于展示分类数据</li><li>直方图使用矩阵的面积表示各组频度的，高代表频率、宽为组距，由于分组之间的数据具有连续性通常矩形直之间连续排列，主要用于展示数值型数</li></ul><p>最后让我们来看看散点图和饼图：</p><h3 id="散点图">散点图</h3><p>直接甩代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">x = [random.randint(<span class="number">25</span>,<span class="number">50</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)]</span><br><span class="line">y = [random.randint(<span class="number">25</span>,<span class="number">50</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)]</span><br><span class="line"></span><br><span class="line">x1 = [random.randint(<span class="number">1</span>,<span class="number">25</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)]</span><br><span class="line">y1 = [random.randint(<span class="number">1</span>,<span class="number">25</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)]</span><br><span class="line">plt.scatter(x,y, label=<span class="string">&#x27;dot-1&#x27;</span>, color=<span class="string">&quot;red&quot;</span>, s=<span class="number">25</span>, marker=<span class="string">&quot;o&quot;</span>)</span><br><span class="line">plt.scatter(x1,y1, label=<span class="string">&#x27;dot-2&#x27;</span>, color=<span class="string">&quot;gold&quot;</span>, s=<span class="number">25</span>, marker=<span class="string">&quot;o&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Title&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2cjJ1cmZjaWEwYkhEZG1CazFPZEtpYkcwb0kxSjZ5eFI3UW9CZ0w2MElTRXRkSlFuYU83YTVLaWJBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>散点图是指在回归分析中，数据点在直角坐标系平面上的分布图，散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。</p><p>用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联或总结坐标点的分布模式。散点图将序列显示为一组点。值由点在图表中的位置表示。类别由图表中的不同标记表示。散点图通常用于比较跨类别的聚合数据。</p><h3 id="饼状图">饼状图</h3><p>通常，饼图用于显示部分对于整体的情况，通常以<code>％</code>为单位。幸运的是，Matplotlib 会处理切片大小以及一切事情，我们只需要提供数值。</p><p>示例程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">slices = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">activities = [<span class="string">&quot;sleeping&quot;</span>, <span class="string">&quot;eating&quot;</span>, <span class="string">&quot;working&quot;</span>, <span class="string">&quot;studying&quot;</span>, <span class="string">&quot;playing&quot;</span>]</span><br><span class="line">cols = [<span class="string">&#x27;grey&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;gold&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">plt.pie(slices, labels=activities, colors=cols, startangle=<span class="number">90</span>, shadow=<span class="literal">True</span>, explode=(<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Title&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ickZyUUZ3QUIwWVhVdHVHaWJlYlBXN2tSUWZlNVI5aWI2cFRKUklkWkp0NUJtdmJKNDZYR3VtY3VpYndiaWNpYjlpYlN3aWJzWGNMSGFTWWVmN2VzeWlhaWJqaGJYdy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>在<code>pie()</code>中，我们需要通过指定切片，这是每个部分的大小，它会自动求出百分比。</p><p>然后，我们通过<code>labels</code>指定每个部分的名称，通过<code>colors</code>指定颜色列表。</p><p>接下来，我们可以选择指定图形的起始角度。这使你可以在任何地方开始绘图。例子中，我们为饼图选择了 90 度角。</p><p>我们也可以选择给绘图添加一个字符大小的阴影，我们甚至可以使用<code>explode</code>拉出一个切片，使用 explode 参数就可以了，如果我们不想拉出任何切片，我们传入 0,0,0,0,0。如果我们想要拉出第一个切片，我们传入 0,0.1,0,0,0。</p><p>最后，我们使用<code>autopct</code>，选择将百分比放置到图表上面。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2018/12/11/001-Hello-world/"/>
      <url>2018/12/11/001-Hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
